The solutions described thus far all assume languages with a heavyweight,
garbage-collected runtime.  However, two recent systems seek
to support timed code with fewer dependencies: the $C\forall$
language~\cite{delisle:wcs2018} and a C thread library for realtime systems (here,
``\textit{RT}'') developed by Mollison and Anderson~\cite{mollison:rtas2013}.
Both perform preemption using timer interrupts, as proposed in the early Scheme
engines literature.  They install a periodic signal handler for scheduling
tasks and migrating them between cores, a lightweight approach that achieves
competitive scheduling latencies.
However, as explained later in this section, the compromise is interoperability with
existing code.

\textit{Shinjuku}~\cite{Kaffes:nsdi2019} is an operating system designed to perform
preemption at microsecond scale.  Built on the Dune framework~\cite{Belay:osdi2012},
it runs tasks on a worker thread pool controlled by a single centralized
dispatcher thread.  The latter polices how long each task has been running and
sends an inter-processor interrupt (IPI) to any worker whose task has timed out.
The authors study the cost of IPIs and the overheads
imposed by performing them within a VT-x virtual machine, as required by Dune.  They
then implement optimizations to reduce these overheads at the expense of Shinjuku's
isolation from the rest of the system.

As seen in Section~\ref{sec:intro}, nonreentrant interfaces are
incompatible with externally-imposed time limits.  Because such interfaces are
prolific in popular dependencies, no prior work allows timed code to transparently
call into third-party libraries.  Scheme engines and
Lilt avoid this issue by only supporting functional code, which cannot have shared
state.  Go is able to preempt goroutines written in the language itself, but a
goroutine that makes any foreign calls to other languages is treated as
nonpreemptible by the runtime's scheduler~\cite{www-golang-fficall}.
The C$\forall$ language's preemption model is only safe for functions guarded
by its novel monitors:\@ the authors caution that ``any challenges that are not [a
result of extending monitor semantics] are considered as solved problems and
therefore not discussed.''
With its focus on realtime embedded systems, RT assumes
that the timed code in its threads will avoid shared state; this assumption mostly
precludes
calls to third-party libraries, though the system supports the dynamic memory
allocator by treating it as specifically nonpreemptible.  Rather than dealing with
shared state itself, Shinjuku asks application authors to annotate any code with
potential concurrency concerns using a nonpreemptible \texttt{call\_safe()} wrapper.
