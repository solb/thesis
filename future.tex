\section{Future work}

One of our contributions is asynchronous cancellation, something rarely supported by
the state of the art.  In Section~\ref{sec:libinger:cancel}, we noted our lack of
support for automated resource cleanup; however, we outlined a possible approach for
languages such as Rust, which we intend to investigate further.  Cancellation is
currently
our most expensive operation because of the libset reinitialization described in
Section~\ref{sec:gotchainit}, but we plan to improve this by restoring only the
writeable regions of each module.

In a significant divergence from the \textit{Shinjuku} design, we make each thread
responsible for its own preemption rather than sending signals from a shared watchdog
thread.  A back-of-the-envelope calculation based on \textit{Shinjuku}'s comparison of
interprocessor interrupt (IPI) and Linux signal latencies suggests possible
performance improvements enabled by our design.
Although Shinjuku reports that IPIs take an average of only 1,993 cycles, compared to
4,950 for signals (roughly 1:2.5), their sender/receiver breakdown of the latter
number suggests significant latency savings by avoiding cross-core signaling:
First, 343 of those cycles (6.9\%) are spent propagating the signal between the two
cores; we do not expect our system to be affected.  Second, 2,084 cycles (42\%)
are incurred by the sending core; assuming the interrupt controller supports
periodic timer interrupts at the necessary frequency, this cost does not need to be
paid between each interrupt, suggesting measurable savings here too.  Although
our prototype is not yet optimized to this extent, we expect it is possible for a
system built on intra-thread Linux signals to achieve an average preemption latency
within 2x that of Shinjuku's custom operating system.  The savings from such
optimization could be used either to support finer preemption granularity or to
reduce the timer-imposed throughput penalty during preemptible function execution.

We believe the lightweight preemptible function abstraction naturally supports
common features of large-scale systems.  For example:  An ad renderer might implement
graceful degradation by rendering frames of an animation in a preemptible function,
dropping unfinished ones to meet its SLO.  An RPC server might preserve work by
processing each request in a preemptible function and memoizing the continuations; if
a request timed out but was later retried by the client, the server could resume
executing it from where it left off.

\solb{Might want to support nested preemptible functions?}
