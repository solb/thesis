\section{Future work}
\label{sec:future}

This being preliminary work, there remain security problems in need of addressing.
While a couple of them represent unresolved limitiations in our implementation, most
of these are simply defense in depth to ensure that an unexpected failure (e.g., due
to a compiler bug or the operator allowing use of a buggy or malicious library) is
contained.  We endeavor to catalog many of these here, along with proposed solutions
that we intend to implement going forward.

\paragraph{Non-reentrancy}
Most importantly, the described preemption approach using Rust panics to unwind the
stack doesn't yet reliably leave the worker process in a usable state because it
can corrupt the internal state of certain functions if it happens to interrupt them;
most of the Rust standard library is reentrant, but a notable example is the dynamic
allocator.  We have a couple possible fixes in mind:\ we could blacklist certain
functions and wait to preempt until they were no longer running, or replace the
allocator with a custom one that manages a separate heap for each microservice.  The
latter approach would also open the possiblity of one-shot memory deallocation by
simply ``deallocating'' an entire heap.

\paragraph{Dispatch process}
We believe it would be unwise to run the system in production without isolating the
dispatch process from interference or corruption by a misbehaving worker.  In
practice, this should include at least:\ running the workers in separate,
unprivileged user accounts (that cannot, for example, write or delete other
customers' microservice shared objects); auditing all interactions with the shared
memory region to ensure invalid or inconsistent data originating from the host cannot
create an unrecoverable dispatch error; handling the \texttt{SIGCHLD} signal to
detect a worker that has somehow crashed; and keeping a recovery log in the dispatch
process so that any user jobs lost to a problem dispatch process can be reassigned to
operational workers.

\paragraph{System calls}
Of the Linux system calls, there are many that a microservice simply has no business
executing.  A few examples:  A call to \texttt{setitimer()}, \texttt{signal()},
\texttt{sigaction()}, \texttt{sigprocmask}, or a similar entry point could be used to
disable preemption.  While access to a private temporary area may be useful,
unmonitored filesystem access seems like a recipe for disaster.  The creation of
kernel threads via [\texttt{v}]\texttt{fork()}, \texttt{spawn()}, \texttt{clone()},
or \texttt{pthread\_create()} could create resource problems or make a microservice
hard to clean up after.  The \texttt{nice()} and \texttt{sched\_.*()} calls could
create competition between processes, adversely affecting performance or even causing
starvation.  An \texttt{exit}[\texttt{\_group}]\texttt{()} or \texttt{kill()} could
be used to terminate the entire worker.

We suggest that each worker process use the \texttt{seccomp()} system call to lock
itself down during initialization, restricting the accessible syscalls to a
whitelisted set.  The process should handle \texttt{SIGSYS} and tear down the running
microservice if it is ever received.

\paragraph{Library functions}
It may be desirable to further restrict the worker process's actions by blocking
certain libc functions.  This could be accomplished either by using the dynamic
linker to interpose stub implementations, or by linking against a custom build of the
library.  Similar steps may be needed in the Rust standard library as well; for
instance, we currently have no way to stop a user from catching the panic we trigger
and preventing control from returning to the worker loop loop, although this could be
accomplished using static analysis or even a simple search when we compiled submitted
code.

\paragraph{Resource leaks}
For all the memory safety it provides, there are properties that Rust does not
guarantee of safe code~\cite{www-rustlang-nu}; one example is that destructor
invocation is not guaranteed, not least because of the language's choice of reference
counting in lieu of garbage collection.  This means that our stack unwinding--based
preemption is not guaranteed to free all of a microservice's memory or other
resources.  Memory leaks could be prevented by interposing on the dynamic allocator
to record tracking information (likely proving expensive); alternatively, this may be
a definitive argument for the aforementioned suggestion of per-microservice heaps.
As for other resources, we suspect the right approach is for the worker to check for
certain likely leaks---such as unclosed file descriptors---between microservice
invocations and clean up anything it discovers.  If some such checks proved too
expensive, they could be run only after so many tasks had run or the system load was
sufficiently low, and/or the system could track which microservices were (likely)
responsible for resource leaks and impose warnings or bans.

\paragraph{Side channels}
As this year's Meltdown~\cite{Lipp2018} and Spectre~\cite{Kocher2018} CPU
vulnerabilities reminded our community, the peril of timing attacks and other
sidechannels can lurk at any abstraction layer and deserves careful consideration.
We are aware of at least two significant pieces of state that are observable in our
approach: microservices have access to the memory addresseses and timings of dynamic
memory allocations, as well as the numbers of opened file descriptors.  We would not
be surprised if an enterprising attacker could use this information to reconstruct
private details of recently-executed microservices.  However, we believe that some of
the steps proposed for addressing resource leaks could help block these side
channels as well.  In the worst case, however, we may need to modify the Rust
standard library (e.g., to prevent access to pointer addresses via debug formatting
and/or disallow safe access to file descriptor numbers).

We freely admit that the pervasive design changes proposed herein require more
rigorous verification to catalog and mitigate side-channels; however, we believe this
shortcoming is not limited to this project, but that many such severe attacks will be
discovered in existing systems, both in the months to come and after the introduction
of much-needed tooling to support the looming pervasive vulnerability search.

\paragraph{Potpourri}
The reader may be disheartened by the number of attack vectors we've considered, or
even that we've failed to consider.  However, there is a small piece of good news:\
because that the worker processes should be well-isolated from the rest of the
system, solutions can be inexact, with the dispatcher restarting a failed worker and
automatically banning suspect microservices in the worst case.
