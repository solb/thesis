\section{Future Work}
\label{sec:future}

As noted above, our exploration is preliminary; this section outlines several
open questions.  These questions fall into two categories: shortcomings in our
current implementation and defense-in-depth safeguards against unexpected
failures (e.g., compiler bug or the operator allowing use of a buggy or malicious library).

% This being preliminary work, there remain security problems in need of addressing.
% While a couple of them represent unresolved limitations in our implementation, most
% of these are simply defense in depth to ensure that an unexpected failure (e.g., due
% to a compiler bug or the operator allowing use of a buggy or malicious library) is
% contained.  We endeavor to catalog many of these here, along with proposed solutions
% that we intend to implement going forward.

\paragraph{Non-reentrancy.}
Our proposal to use Rust panics to unwind the stack during preemption can
corrupt the internal state of non-reentrant functions (e.g., Rust's dynamic
allocator).  Possible fixes include blacklisting these functions and delaying
preemption until they are finished or replacing the problematic function with a
safe one (e.g., a custom memory allocator).
%allocator with a custom one that manages a separate heap for each microservice.  The
%latter approach would also open the possiblity of one-shot memory deallocation by
%simply ``deallocating'' an entire heap.

\paragraph{Dispatch process.}
Our current implementation does not provide isolation between the dispatcher
and worker processes.  We propose using standard OS techniques to reduce
the chance of corruption or interference by a misbehaving worker.  Examples
include auditing interactions with the shared memory region to ensure invalid
or inconsistent data originating from the host cannot create an unrecoverable
dispatch error; handling the \texttt{SIGCHLD} signal to detect a worker that has
somehow crashed; and keeping a recovery log in the dispatch process so that any
user jobs lost to a problem dispatch process can be reassigned to operational
workers.

%We believe it would be unwise to run the system in production without isolating the
%dispatch process from interference or corruption by a misbehaving worker.  In
%practice, this should include at least:\

\paragraph{System calls.}
The system must restrict microservices from accessing certain system calls.
\texttt{setitimer()}, \texttt{signal()}, \texttt{sigaction()}, and
\texttt{sigprocmask} could be used to
disable preemption.  Calls that create
kernel threads (\texttt{fork()}, \texttt{spawn()}, \texttt{clone()},
or \texttt{pthread\_create()}) can create resource problems or make a
microservice hard to clean up after.
The \texttt{nice()} and \texttt{sched\_.*()} calls could
create competition between processes.
An \texttt{exit}[\texttt{\_group}]\texttt{()} or \texttt{kill()} could
be used to terminate the entire worker.
Finally, user functions should not have unmonitored file system access.
% The system must restrict microservices from accessing certain system calls.
% \texttt{setitimer()}, \texttt{signal()}, \texttt{sigaction()}, and
% \texttt{sigprocmask} could be used to
% disable preemption.  Other examples include system calls that provide
% unmonitored filesystem access, the creation of
% kernel threads via [\texttt{v}]\texttt{fork()}, \texttt{spawn()}, \texttt{clone()},
% or \texttt{pthread\_create()} could create resource problems or make a microservice
% hard to clean up after.  The \texttt{nice()} and \texttt{sched\_.*()} calls could
% create competition between processes, adversely affecting performance or even causing
% starvation.  An \texttt{exit}[\texttt{\_group}]\texttt{()} or \texttt{kill()} could
% be used to terminate the entire worker.

We propose forcing each worker process to use the \texttt{seccomp()} system call
to lock itself down during initialization, thereby limiting the process to a
whitelisted set of system calls. \mk{need to cite seccomp} Finally, the process
should handle \texttt{SIGSYS} and tear down the running microservice if it is
ever received.

\paragraph{Library functions.}
As with system calls, blocking access to library functions (e.g., \texttt{libc}
or the Rust standard library) is important for isolation and security.  Possible
options include using the dynamic linker to interpose stub implementations or
linking against a custom build of the library.

Using Rust's panic handler for preemption opens the possibility that a user
function could catch the panic and prevent control from returning to the
worker. Options here include detecting this behavior using static analysis.

% Similar steps may be needed in the Rust standard library as well; for
% instance, we currently have no way to stop a user from catching the panic we trigger
% and preventing control from returning to the worker loop loop, although this could be
% accomplished using static analysis or even a simple search when we compiled submitted
% code.
% simple search when we compiled submitted code.

\paragraph{Resource leaks.}
Safe Rust code provides memory safety, but it cannot prevent memory
leaks~\cite{www-rustlang-nu}.  For example, destructor invocation is not
guaranteed using Rust's default reference counting-based reclamation; therefore,
unwinding the stack during preemption is not guaranteed to free all of a
microservice's memory or other resources.  Potential solutions are interposing
on the dynamic allocator to record tracking information (likely proving
expensive) or using per-microservice heaps that main worker process can simply
deallocation when terminating a microservice.  The work can also deallocate
other resources, such as unclosed file descriptors.  If these checks end up
being too expensive, the worker could execute its cleanup after a certain number
of microservices have run or when the load is. sufficiently low.
%, and/or the system could track which microservices were (likely)
%responsible for resource leaks and impose warnings or bans.

\paragraph{Side channels.}
Our current approach is vulnerable to side-channel
attacks~\cite{Lipp2018,Kocher2018}.  For example, microservices have access to
the memory addresses and timings of dynamic memory allocations, as well as the
numbers of opened file descriptors.  Although side-channels exist in many
systems, the short duration of microservice functions may
make mitigating such attacks more challenging; nevertheless, standard
preventative practices found in the literature should apply.

% As this year's Meltdown~\cite{Lipp2018} and Spectre~\cite{Kocher2018} CPU
% vulnerabilities reminded our community, the peril of timing attacks and
% other sidechannels can lurk at any abstraction layer and deserves careful
% consideration.  We are aware of at least two significant pieces of state
% that are observable in our approach: microservices have access to the memory
% addresses and timings of dynamic memory allocations, as well as the numbers of
% opened file descriptors.  We would not be surprised if an enterprising attacker
% could use this information to reconstruct private details of recently-executed
% microservices.  However, we believe that some of the steps proposed for
% addressing resource leaks could help block these side channels as well.  In the
% worst case, however, we may need to modify the Rust standard library (e.g., to
% prevent access to pointer addresses via debug formatting and/or disallow safe
% access to file descriptor numbers).
%
% We freely admit that the pervasive design changes proposed herein require more
% rigorous verification to catalog and mitigate side-channels; however, we believe this
% shortcoming is not limited to this project, but that many such severe attacks will be
% discovered in existing systems, both in the months to come and after the introduction
% of much-needed tooling to support the looming pervasive vulnerability search.

% The reader may be disheartened by the number of attack vectors we've considered, or
% even that we've failed to consider.  However, there is a small piece of good news:\
% because that the worker processes should be well-isolated from the rest of the
% system, solutions can be inexact, with the dispatcher restarting a failed worker and
% automatically banning suspect microservices in the worst case.

~\\
Despite the security challenges of running microservice as functions, worker
processes are still well-isolated from the rest of the system.
Worst case, the central dispatcher can restart a failed worker and
automatically ban suspect microservices.
