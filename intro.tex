\section{Introduction}
\label{sec:intro}

After years of struggling to gain adoption, the coroutine has finally become a
mainstream abstraction for cooperatively scheduling function invocations.  Languages
as diverse as C\#, JavaScript, Kotlin, Python, and Rust now support ``async
functions,'' each of which expresses its dependencies by ``awaiting'' a
\textbf{future} (or promise); rather than polling, the language translates this to a
yield if the result is not yet available.

Key to the popularity of this concurrency abstraction is the ease and seamlessness of
parallelizing it.  Underlying every major futures runtime is a green threading
library, typically consisting of a scheduler that distributes work to a pool of
OS-managed worker threads.  Note that without uncommon kernel
support (e.g., scheduler activations~\cite{anderson:sosp1991}), this logical
threading model renders the operating system unaware of individual tasks, meaning
context switches are purely cooperative.

This leads us to an abstraction that is \textit{not} available in modern languages:\@
an easy way of \textit{preemptively} scheduling functions (e.g., calling a function
with a timeout).  An implementation of such \textbf{preemptible functions} based on
OS threads suggests itself, where the function would run on a new thread that
could be cancelled upon timeout.  Unfortunately, the existence of nonreentrant
functions makes cancelling a thread hard.  UNIX's pthreads provide
asynchronous cancelability, but according to the Linux documentation, it ``is rarely
useful.  Since the thread could be cancelled at \textit{any} time, it cannot safely
reserve resources (e.g.  allocating memory with \texttt{malloc()}), acquire mutexes,
semaphores, or locks, and so on... some internal data structures (e.g., the linked
list of free blocks managed by the \texttt{malloc()} family of functions) may be left
in an inconsistent state if cancellation occurs in the middle of the function
call''~\cite{pthreadsetcanceltype-manpage}.  The same is true on Windows, whose API
documentation warns that asynchronously terminating a thread ``can result in the
following problems: If the target thread owns a critical section, the critical
section will not be released.  If the target thread is allocating memory from the
heap, the heap lock will not be released...'' and goes on from
there~\cite{www-microsoft-terminatethread}.

One might instead seek to implement preemptible functions via the UNIX
\texttt{fork()} function.  Even ignoring the high overhead, this would require
careful configuration of shared memory
to ensure that objects created outside the function were accessible inside, and worse
yet, that allocations performed inside remained available after it exited.
Furthermore, the inverse is equally desirable and potentially trickier because the
allocations would need to outlive a return from the function.  And all this is
without addressing the difficulty of even calling \texttt{fork()} in a multithreaded
program:\@ because doing so effectively cancels all threads in the child process
except the calling one, that process can experience the same problems as with the
thread approach~\cite{baumann:hotos2019}.

These na\"ive designs share another shortcoming:\@ in reducing
preemptible functions to a problem of parallelism, they hurt performance by placing
thread creation on the critical path and limit composability by increasing the
abstraction's complexity.  We observe that, when calling a function with
a timeout, it is concurrency alone---and not parallelism---that is fundamental.

In this paper, we propose lightweight preemptible functions, a userland abstraction
for making function calls with a timeout that differs significantly from the state of
the art:  (1) Unlike threading abstractions such as coroutines, it \textit{runs
functions synchronously on the caller's thread}.  (2) It supports \textit{preemption
at granularities in the 10s of microseconds}, orders of magnitude finer than
contemporary OS schedulers' millisecond scale.  (3) It is \textit{language agnostic},
being implemented in userland without relying on any particular compiler or managed
runtime.
