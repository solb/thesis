\subsection{Safe concurrency}
\label{sec:libinger:concurrency}

Automatically handling shared state arising from nonreentrant library interfaces is
needed because the sharing is transparent to the programmer.  A
different problem arises when a programmer explicitly shares state between a
preemptible function and any other part of the program.  Unlike third-party library
authors, this programmer knows they are using preemptible functions, a
concurrency mechanism.

When using the C interface, the programmer bears complete responsibility for writing
race-free code (e.g., by using atomics and mutexes wherever necessary).
The \textit{libinger} Rust API, however, leverages the
language's first-class concurrency support to prevent such mistakes from compiling:\@
\texttt{launch()}'s signature requires the wrapped function to be \texttt{Send} safe
(only reference state in a thread-safe manner)~\cite{www-rustlang-conc}.

While the Rust compiler rejects all code that shares state unsafely, it is still
possible to introduce
correctness bugs such as deadlock~\cite{www-rustlang-nu}.  For example, a program
might block on a mutex held by
the preemptible function's caller (recall that invocation is synchronous, so blocking
in a preemptible function does not cause it to yield!).  It is sometimes necessary to
acquire such a mutex, so \textit{libinger} provides a way to do it:  The API has an
additional function, \texttt{pause()}, that is a rough analog of yield.  After
performing a
try-lock operation, a preemptible function can call \texttt{pause()} to immediately
return to its caller as if it had timed out.  The caller can tell whether a function
paused via a flag on its continuation.
