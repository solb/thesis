\section{Evaluation}
\label{sec:eval}

We now evaluate the performance of the preemptible functions software stack,
presenting a suite of microbenchmarks and two examples of their application to
existing systems to improve resilience to malicious or otherwise long-running
requests.  All experiments were run on an Intel Xeon E5-2683 v4 (Broadwell)
server running Linux 4.12.6, rustc 1.36.0, gcc 9.2.1, and glibc 2.29.

\solb{Should we mark every test we run without global variable interposition?}


\subsection{Microbenchmarks}

\begin{table}
\begin{center}
\begin{tabular}{c | c}
Operation & Duration ($\mu{s}$) \\
\hline
\texttt{launch()} & $4.6 \pm 0.05$ \\
\texttt{resume()} & $4.4 \pm 0.02$ \\
\texttt{cancel()} & $4,767.7 \pm 1,168.7$ \\
\hline
\texttt{fork()} & $207.5 \pm 79.3$ \\
\texttt{pthread\_create()} & $32.5 \pm 8.0$
\end{tabular}
\end{center}
\caption{Latency of preemptible function interface}
\solb{Rerun with the latest version of libinger.}
\label{tab:libinger}
\end{table}

Table~\ref{tab:libinger} shows the overhead of \textit{libinger}'s core functions.
Each test makes use of hundreds of preemptible functions, each with its own stack and
continuation, but sharing an implementation that immediately calls \texttt{pause()}.
For comparison, we also measured the cost of calling \texttt{fork()} then
\texttt{exit()} and \texttt{pthread\_create()} with an empty function; the parent
thread waits using \texttt{waitpid()} or \texttt{pthread\_join()}, respectively.

The results show that, as long as preemptible functions are eventually allowed to run
to completion, they are an order of magnitude faster than spawning a thread and two
orders of magnitude faster than forking a process.  Although cancellation takes
milliseconds in the benchmark application, this operation need not lie on the
critical unless the application is cancelling tasks frequently enough to exhaust its
supply of libsets.

\solb{What do we want to say about throughput degradation?  Is it
necessary/enough/possible to cite our benchmark from the microservices paper?}

\solb{We also don't currently discuss process startup times.}

\begin{table*}
	\begin{minipage}{2\columnwidth}
	\centering
	\begin{tabular}{c | c c}
	Symbol resolution scheme & Time without \textit{libgotcha} ($ns$) & Time with \textit{libgotcha} ($ns$) \\
	\hline
	eager (load time) & $2 \pm 0$ & $14 \pm 0$ \\
	lazy (runtime) & $100 \pm 1$ & $125 \pm 0$ \\
	global variable & $0 \pm 0$ & $3,438 \pm 13$
	\end{tabular}
	\subcaption{Generic symbols, with and without \textit{libgotcha}}
	\label{tab:libgotcha:symb}
	\end{minipage}

	\begin{minipage}{\columnwidth}
	\centering
	\begin{tabular}{c | c}
	Baseline & Time without \textit{libgotcha} ($ns$) \\
	\hline
	\texttt{gettimeofday()} & $19 \pm 0$ \\
	\texttt{getpid()} & $44 \pm 0$
	\end{tabular}
	\subcaption{Library functions and syscalls without \textit{libgotcha}}
	\label{tab:libgotcha:baseline}
	\end{minipage}
%
	\begin{minipage}{\columnwidth}
	\centering
	\begin{tabular}{c | c}
	Trigger & Time with \textit{libgotcha} ($ns$) \\
	\hline
	Whitelisted call & $21 \pm 0$ \\
	Whitelisted call + callback & $25 \pm 0$
	\end{tabular}
	\subcaption{Whitelisted calls triggering a libset switch}
	\label{tab:libgotcha:whitelist}
	\end{minipage}
\caption{Runtime overheads of accessing dynamic symbols}
\end{table*}

Recall that linking an application against \textit{libgotcha} imposes additional
overhead on every dynamic symbol access; we report these overheads in
Table~\ref{tab:libgotcha:symb}.  Eager function calls account for almost all of a
modern program's dynamic symbol accesses:  Direct access to global variables is rarer
now that thread safety is a pervasive concern, with libc removing the \texttt{errno}
symbol in favor of an \texttt{\_\_errno\_location()} helper
function~\cite{www-lsb-errno}, and compilers translating thread-local variable
accesses into calls to \texttt{\_\_tls\_get\_addr()} or offsets from a segment
register~\cite{drepper:spec2013}.  As explained in Section~\ref{sec:libgotcha}, lazy
resolution only occurs the first time an object file calls a particular function, and
can be avoided altogether by asking the dynamic linker to resolve all symbols at load
time.

Table~\ref{tab:libgotcha:baseline} shows that the \textit{libgotcha} eager function
call overhead is on par with the cost of a trivial C library function and one-third
the cost of a simple system call.  This affects the entire program, regardless of the
current libset at the time of the call.  Additionally, calls to whitelisted
nonpreemptible functions from within a preemptible function incur several extra
nanoseconds of latency to switch back to the main namespace as described in
Section~\ref{sec:libgotcha}; Table~\ref{tab:libgotcha:whitelist} breaks this down to
show the cost of notification callbacks at the conclusion of such a call (always
required by \textit{libinger}).
