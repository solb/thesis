\chapter{Function calls with timeouts, revisited: \\ the \textit{libinger} library}
\label{chap:libinger}

\ifdefined\chapquotes
\vspace{-0.5in}
\begin{chapquote}[1.5in]{David Mitchell, \textit{Cloud Atlas}}
A half-read book is a half-finished love affair.
\end{chapquote}
\fi

In Chapter~\ref{chap:functions}, we introduced and motivated lightweight preemptible
functions, a novel concurrency abstraction pairing synchronous invocation with
preemption.  At that time, we covered the design principles underlying the API for
managing preemptible functions; in this chapter, we will discuss the API itself in
more detail and the design and implementation of \textit{libinger}, the library that
provides preemptible functions.

We start by giving the full \textit{libinger} C interface in
Listing~\ref{lst:ingerfullapi}.  The \texttt{launch()} and \texttt{resume()}
functions work as already described:\@ the former creates a new preemptible function
and lets it run on the caller's thread for the specified number of microseconds
(which may be zero), and the latter resumes a preemptible function that had become
paused after exhausting its time budget.  The new \texttt{cancel()} function allows
the caller to discontinue a paused preemptible function rather than allowing it to
run to completion.  Finally, the \texttt{pause()} function may be called from within
a preemptible function to cooperatively yield.  It immediately pauses the function
and returns to its caller, just as if the function had been preempted.

The Rust interface appears in Listing~\ref{lst:ingerrustapi} and differs in several
important ways:

\begin{figure}
\begin{lstlisting}[label=lst:ingerfullapi,caption=Preemptible functions extended C interface,morekeywords=uint64_t]
struct linger_t {
	bool is_complete;
	cont_t continuation;
};

typedef void (*Function)(void *);

linger_t launch(Function func,
                  uint64_t time_us,
                  void *args);
void resume(linger_t *cont, uint64_t time_us);
void cancel(linger_t *cont);
void pause(void);
\end{lstlisting}
\end{figure}

\begin{figure}
\begin{lstlisting}[label=lst:ingerrustapi,caption=Preemptible functions Rust interface,morekeywords={fn,impl,mut,pub,self,u64,Drop,Result,Send}]
pub enum Linger<T> {
	Completion(T),
	Continuation(Continuation),
	Poison,
}

pub fn launch<T: Send>(func: impl FnOnce() -> T + Send,
			 time_us: u64) -> Result<Linger<T>>;
pub fn resume<T>(func: &mut Linger<T>,
		   time_us: u64) -> Result<&mut Linger<T>>;
pub fn pause();

impl<T> Linger<T> {
	pub fn yielded(&self) -> bool;
}

impl Drop for Continuation { ... }
\end{lstlisting}
\end{figure}

\paragraph{Closure support.}
We leverage Rust's first-class closures to enable the caller to pass
\texttt{launch()} a function that captures state from its environment.  We expect the
caller to provide any inputs to the function in this manner.  Unlike with the C
interface, there is no need to wrap the arguments in a struct when there are
multiple, or to pass an empty value when there are none.


\paragraph{Type safety.}
The aforementioned interface change means that the Rust wrapper functions do not
erase the types of the preemptible function's parameters by diluting them to a
\texttt{void *}; thus, the preemptible function does not have to perform an unsafe
cast before using them, and the compiler can still type check the program.
Furthermore, both \texttt{launch()} and \texttt{resume()} are generic on the
preemptible function's return type:\@ instead of a \texttt{linger\_t}, they return a
tagged union.  Once the preemptible function runs to completion, the caller may
destructure this type to retrieve the function's return value.  Because the union is
tagged, it is impossible to destructure it to retrieve the return value unless the
function has truly run to completion.


\paragraph{RAII.}
Our Rust interface adheres to the RAII (Resource Allocation Is Initialization) idiom,
allowing continuation deallocation to happen automatically.  Unlike the C interface,
the Rust one has no \texttt{cancel()} function; instead, its continuation objects
implement the language's \texttt{Drop} trait.  Whenever a continuation goes out of
scope without being consumed by running to completion, the language calls its
destructor, which implicitly performs a cancellation.


\paragraph{Safe concurrency.}
The \texttt{launch()} function requires that the preemptible function closure
implement the language's \texttt{Send} trait, which is true provided that all of the
values it captures have this trait.  In Rust, a type is \texttt{Send} if and only if
ownership of it can be safely transferred between threads.  This includes all objects
that do not contain any references, as well as those that do but only to data that is
safe to access concurrently (\texttt{Sync} in Rust parlance).  This restriction on
the closure means that any attempt to share state between a caller and its
preemptible function without the use of appropriate concurrency control will fail at
compile time.


\paragraph{Flexibility.}
The requirement that Rust preemptible functions be \texttt{Send} is similar to the
restrictions imposed by the standard library's thread \texttt{spawn()} interface.
However, \texttt{launch()} differs in an important way:\@ unlike a thread, a
preemptible function is not restricted to the \texttt{'static} lifetime, and so is
able to accept references to local variables and other dynamically-allocated data.
In contrast, attempts to transfer such references to a thread would result in a
compile error.  What makes it safe to use all lifetimes with preemptible functions is
the fact that they execute synchronously, and therefore cannot outlive the calling
context without first becoming paused.  If a preemptible function times out, the Rust
compiler knows the lifetime of any references it has captured, so any attempt to pass
the paused closure to a scope where its shared data no longer exists will be met with
a compile error.
\\

We now turn our attention from how one interacts with \textit{libinger} to how it
works.


\begin{promotesubsections}
\input[functions]{inger_pause}
\end{promotesubsections}

\solb{Reflow because this was moved from another chapter}

\solb{Be sure to emphasize that concurrency has always been hard}

\solb{Ability to query whether it yielded}

\solb{\textbf{(Sub)section on custom mutex idea}}


\begin{promotesubsections}
\input[functions]{inger_stacks}

\solb{Mention that this preallocation is not fundamental}

\solb{Cover cool disaggregation trick for growable stacks}

\solb{\textbf{Section on POSIX contexts} (which might have once existed in paper)}

\thesis{Give a tour of \textit{libtimetravel}?}

\solb{Fix (mis)uses of the term continuation}


\input[functions]{inger_interrupts}
\end{promotesubsections}

\solb{\textbf{Section on deferred preemption}}

\solb{Include specialized version UML call diagram}


\section{Cancellation}

Should a caller decide not to finish running a timed-out preemptible function, it
must deallocate it.  In Rust, deallocation happens implicitly via the
\texttt{linger\_t} type's destructor, whereas users of the C interface are responsible
for explicitly calling the \textit{libinger} \texttt{cancel()} function.

As discussed in Chapter~\ref{chap:libgotcha}, \textit{libgotcha} returns a
preemptible function's libset to the pool for reuse when that function returns
normally.  However, when a function is cancelled before it finishes, none of the
modules in its libset is safe to reuse in general:\@ a library function might have
been in the middle of executing.  To avoid future problems with the libset, as part
of a cancellation, \textit{libinger} instructs \textit{libgotcha} to reinitialize the
function's libset before returning it to the pool.

Cancellation cleans up \textit{libinger} resources allocated by \texttt{launch()};
however, the current implementation does not automatically release resources already
claimed by the preemptible function itself.  However, we have prototyped a solution
that demonstrates the feasibility of such cleanup in RAII languages such as Rust.
We detail this approach in Chapter~\ref{chap:ingerc}.


\section{Evaluation}

\input[functions]{eval_testbed}


\subsection{Microbenchmarks}

\input[functions]{eval_uinger}


\subsection{Image decompression}

Unlike state of the art approaches, lightweight preemptible functions support
cancellation.
\begin{sloppypar}
\input[functions]{eval_cancel}
\end{sloppypar}
