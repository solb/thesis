\chapter{Function calls with timeouts, revisited: \\ the \textit{libinger} library}
\label{chap:libinger}

\ifdefined\chapquotes
\vspace{-0.5in}
\begin{chapquote}[1.5in]{David Mitchell, \textit{Cloud Atlas}}
A half-read book is a half-finished love affair.
\end{chapquote}
\fi

\solb{Reflow this paragraph because we moved safe concurrency to after it}

Chapter~\ref{chap:functions} motivated the need for lightweight preemptible functions
and introduced the shared state problem.  Therein, we concluded that explicitly
handling state shared between a preemptible function and the rest of the program must
necessarily be the responsibility of the programmer using the preemptible function,
as is the case for any concurrency abstraction.  However, we also reasoned that
requiring the programmer to reason about all shared state in the program and its
dependencies was not a tenable approach to solving the other half of the problem.
Instead, we introduced the \textit{libgotcha} runtime for automatically establishing
memory isolation boundaries within the process.  Now that we have covered how said
runtime works in Chapter~\ref{chap:libgotcha}, we are ready to discuss the
implementation of the preemptible function abstraction itself.

In this chapter, we turn our attention to the \textit{libinger} library that provides
the wrapper functions for invoking and working with preemptible functions.  We begin
by showing a summary of the library's API surface, expanded from that first presented
in Section~\ref{sec:libinger}.  Figure~TODO shows the C interface; the Rust interface
differs in a few ways:

\thesis{Add listing of the interface, including \texttt{cancel()} and \texttt{pause()}.}

\thesis{Maybe list it in both languages so we can refer back to it for safety discussion}

\begin{figure}
\begin{lstlisting}[label=lst:ingerfullapi,caption=Preemptible functions extended interface]
struct linger_t {
	bool is_complete;
	cont_t continuation;
};

linger_t launch(Function func,
                  u64 time_us,
                  void *args);
void resume(linger_t *cont, u64 time_us);
\end{lstlisting}
\end{figure}

\paragraph{Closure support.}
We leverage Rust's first-class closures to enable the caller to pass
\texttt{launch()} a function that captures state from its environment.  We expect the
caller to provide any inputs to the function in this manner, so there is no need to
wrap the arguments or pass an empty value when the function expects no inputs.


\paragraph{Type safety.}
The aforementioned interface change means that the Rust wrapper functions do not
erase the types of the preemptible function's parameters by diluting them to a
\texttt{void *}; thus, the preemptible function does not have to perform an unsafe
cast before using them, and any type mismatch is caught at compile time.
Furthermore, both \texttt{launch()} and \texttt{resume()} are generic on the
preemptible function's return type:\@ instead of a \texttt{linger\_t}, they return a
tagged union.  Once the preemptible function runs to completion, the caller may
destructure this type to retrieve the function's return value.


\paragraph{Safe concurrency.}
The \texttt{launch()} function requires that the preemptible function closure
implement the language's automatic \texttt{Send} trait.  This means that any attempt
to pass a closure that shares external state without the use of concurrency control
will cause a compilation failure.


\paragraph{Flexibility.}
The requirement that Rust preemptible functions be \texttt{Send} is similar to the
restrictions imposed by the standard library's thread \texttt{spawn()} interface.
However, \texttt{launch()} differs in an important way:\@ unlike a thread, a
preemptible function is not restricted to the \texttt{'static} lifetime, and so is
able to accept references to local variables and other dynamically-allocated data.
Attempts to transfer such references to a thread would result in a compile error.
The difference that makes it safe to use all lifetimes with preemptible functions is
the fact that they execute synchronously, and therefore cannot outlive the calling
context without becoming paused.  If a preemptible function times out, the Rust
compiler knows the lifetime of any references it has captured, so any attempt to pass
the paused closure to a scope where its shared data no longer exists will be met with
a compile error.


\paragraph{RAII.}
Our Rust interface adheres to the RAII (Resource Allocation Is Initialization) idiom,
allowing continuation deallocation to happen automatically.  Unlike the C interface,
the Rust one has no \texttt{cancel()} function; instead, its continuation objects
implement the \texttt{Drop} trait, and their destructor performs cancellation
whenever they go out of scope.
\\

We now turn our attention from how one interacts with \textit{libinger} to how it
works.

\solb{Interface is generic}

\solb{Use of Rust enum (tagged union)}


\begin{promotesubsections}
\input[functions]{inger_pause}
\end{promotesubsections}

\solb{Reflow because this was moved from another chapter}

\solb{Be sure to emphasize that concurrency has always been hard}

\solb{Ability to query whether it yielded}

\solb{\textbf{(Sub)section on custom mutex idea}}


\begin{promotesubsections}
\input[functions]{inger_stacks}

\solb{Mention that this preallocation is not fundamental}

\solb{Cover cool disaggregation trick for growable stacks}

\solb{\textbf{Section on POSIX contexts} (which might have once existed in paper)}

\thesis{Give a tour of \textit{libtimetravel}?}

\solb{Fix (mis)uses of the term continuation}


\input[functions]{inger_interrupts}
\end{promotesubsections}

\solb{\textbf{Section on deferred preemption}}

\solb{Include specialized version UML call diagram}


\section{Cancellation}

Should a caller decide not to finish running a timed-out preemptible function, it
must deallocate it.  In Rust, deallocation happens implicitly via the
\texttt{linger\_t} type's destructor, whereas users of the C interface are responsible
for explicitly calling the \textit{libinger} \texttt{cancel()} function.

As discussed in Chapter~\ref{chap:libgotcha}, \textit{libgotcha} returns a
preemptible function's libset to the pool for reuse when that function returns
normally.  However, when a function is cancelled before it finishes, none of the
modules in its libset is safe to reuse in general:\@ a library function might have
been in the middle of executing.  To avoid future problems with the libset, as part
of a cancellation, \textit{libinger} instructs \textit{libgotcha} to reinitialize the
function's libset before returning it to the pool.

Cancellation cleans up \textit{libinger} resources allocated by \texttt{launch()};
however, the current implementation does not automatically release resources already
claimed by the preemptible function itself.  However, we have prototyped a solution
that demonstrates the feasibility of such cleanup in RAII languages such as Rust.
We detail this approach in Chapter~\ref{chap:ingerc}.


\section{Evaluation}

\input[functions]{eval_testbed}


\subsection{Microbenchmarks}

\input[functions]{eval_uinger}


\subsection{Image decompression}

Unlike state of the art approaches, lightweight preemptible functions support
cancellation.
\begin{sloppypar}
\input[functions]{eval_cancel}
\end{sloppypar}
