\chapter{Function calls with timeouts, revisited: \\ the \textit{libinger} library}
\label{chap:libinger}

\ifdefined\chapquotes
\vspace{-0.5in}
\begin{chapquote}[1.5in]{David Mitchell, \textit{Cloud Atlas}}
A half-read book is a half-finished love affair.
\end{chapquote}
\fi

In Chapter~\ref{chap:functions}, we introduced and motivated lightweight preemptible
functions, a novel concurrency abstraction pairing synchronous invocation with
preemption.  At that time, we covered the design principles underlying the API for
managing preemptible functions; in this chapter, we will discuss the API itself in
more detail and the design and implementation of \textit{libinger}, the library that
provides preemptible functions.

We start by giving the full \textit{libinger} C interface in
Listing~\ref{lst:ingerfullapi}.  The \texttt{launch()} and \texttt{resume()}
functions work as already described:\@ the former creates a new preemptible function
and lets it run on the caller's thread for the specified number of microseconds
(which may be zero), and the latter resumes a preemptible function that had become
paused after exhausting its time budget.  The new \texttt{cancel()} function allows
the caller to discontinue a paused preemptible function rather than allowing it to
run to completion.  Finally, the \texttt{pause()} function may be called from within
a preemptible function to cooperatively yield.  It immediately pauses the function
and returns to its caller, just as if the function had been preempted.

The Rust interface appears in Listing~\ref{lst:ingerrustapi} and differs in several
important ways:

\begin{figure}
\begin{lstlisting}[label=lst:ingerfullapi,caption=Preemptible functions extended C interface,morekeywords=uint64_t]
struct linger_t {
	bool is_complete;
	cont_t continuation;
};

typedef void (*Function)(void *);

linger_t launch(Function func,
                  uint64_t time_us,
                  void *args);
void resume(linger_t *cont, uint64_t time_us);
void cancel(linger_t *cont);
void pause(void);
\end{lstlisting}
\end{figure}

\begin{figure}
\begin{lstlisting}[label=lst:ingerrustapi,caption=Preemptible functions Rust interface,morekeywords={fn,impl,mut,pub,self,u64,Drop,FnOnce,Result,Send}]
pub enum Linger<T> {
	Completion(T),
	Continuation(Continuation),
	Poison,
}

pub fn launch<T: Send>(func: impl FnOnce() -> T + Send,
			 time_us: u64) -> Result<Linger<T>>;
pub fn resume<T>(func: &mut Linger<T>,
		   time_us: u64) -> Result<&mut Linger<T>>;
pub fn pause();

impl<T> Linger<T> {
	pub fn yielded(&self) -> bool;
}

impl Drop for Continuation { ... }
\end{lstlisting}
\end{figure}


\paragraph{Closure support.}
We leverage Rust's first-class closures to enable the caller to pass
\texttt{launch()} a function that captures state from its environment.  We expect the
caller to provide any inputs to the function in this manner.  Unlike with the C
interface, there is no need to wrap the arguments in a struct when there are
multiple, or to pass an empty value when there are none.


\paragraph{Type safety.}
The aforementioned interface change means that the Rust wrapper functions do not
erase the types of the preemptible function's parameters by diluting them to a
\texttt{void *}; thus, the preemptible function does not have to perform an unsafe
cast before using them, and the compiler can still type check the program.
Furthermore, both \texttt{launch()} and \texttt{resume()} are generic on the
preemptible function's return type:\@ instead of a \texttt{linger\_t}, they return a
tagged union.  Once the preemptible function runs to completion, the caller may
destructure this type to retrieve the function's return value.  Because the union is
tagged, it is impossible to destructure it to retrieve the return value unless the
function has truly run to completion.


\paragraph{RAII.}
Our Rust interface adheres to the RAII (Resource Allocation Is Initialization) idiom,
allowing continuation deallocation to happen automatically.  Unlike the C interface,
the Rust one has no \texttt{cancel()} function; instead, its continuation objects
implement the language's \texttt{Drop} trait.  Whenever a continuation goes out of
scope without being consumed by running to completion, the language calls its
destructor, which implicitly performs a cancellation.


\paragraph{Safe concurrency.}
The \texttt{launch()} function requires that the preemptible function closure
implement the language's \texttt{Send} trait, which is true provided that all of the
values it captures have this trait.  In Rust, a type is \texttt{Send} if and only if
ownership of it can be safely transferred between threads.  This includes all objects
that do not contain any references, as well as those that do but only to data that is
safe to access concurrently (\texttt{Sync} in Rust parlance)~\cite{www-rustlang-conc}.
This restriction on
the closure means that any attempt to share state between a caller and its
preemptible function without the use of appropriate concurrency control will fail at
compile time.


\paragraph{Flexibility.}
The requirement that Rust preemptible functions be \texttt{Send} is similar to the
restrictions imposed by the standard library's thread \texttt{spawn()} interface.
However, \texttt{launch()} differs in an important way:\@ unlike a thread, a
preemptible function is not restricted to the \texttt{'static} lifetime, and so is
able to accept references to local variables and other dynamically-allocated data.
In contrast, attempts to transfer such references to a thread would result in a
compile error.  What makes it safe to use all lifetimes with preemptible functions is
the fact that they execute synchronously, and therefore cannot outlive the calling
context without first becoming paused.  If a preemptible function times out, the Rust
compiler knows the lifetime of any references it has captured, so any attempt to pass
the paused closure to a scope where its shared data no longer exists will be met with
a compile error.


\paragraph{Composability.}
In addition to the closure being \texttt{Send}, the opaque \texttt{Continuation} type
is as well.  This means that a preemptible function can be launched on one thread,
become paused, then be moved to another thread and resumed there.  Applications may
use this trick to move long-running tasks off the critical path, but it is especially
important for implementing thread libraries.  In fact, as we will see in
Chapter~\ref{chap:libturquoise}, it makes it easy to implement preemptive thread
libraries in userland.


\section{Shared responsibility for concurrency control}

The preceding points about concurrency restrictions in the Rust API may seem
incongruous with Chapter~\ref{chap:libgotcha}, which spent dozens of pages
introducing selective relinking, a technique billed as solving the concurrency perils
of preemptible functions.  In fact, that runtime exists to address a completely
separate (but equally critical) problem.

Adding preemptible functions to an application actually introduces two distinct forms
of concurrency.  Both stem from the fact that code within the same thread is now
allowed to interleave its execution at almost entirely arbitrary points, but they
differ in whether the code in question can possibly anticipate this problem, and
therefore have any hope of addressing it.

First, there is concurrency involving the libraries that the program depends on, many
of which were probably authored by third parties.  Although such libraries now
execute concurrently with preemptible functions by virtue of being used from the same
kernel thread, they conceptually ``predate'' preemptible functions' existence; that
is, they cannot even be expected to be aware of this concurrency.  The job of
\textit{libgotcha} is to reconcile this, first by establishing an isolation boundary
between each library (and the executable, for that matter) and the rest of the
program, and then by deferring preemption where shared state is still unavoidable.

Separately, there is concurrency involving the code that uses the preemptible
functions abstraction (i.e., implements and invokes preemptible functions).  Not only
\textit{can} this code take measures to ensure this concurrency is safe:\@ it has to
be the one to do so.  This is because there is often a legitimate need to explicitly
exchange information between a preemptible function and the surrounding program, in
which case the possibility of interleaving must be directly confronted.  As a simple
example, consider a preemptible function that is populating some data structure for
later use by the rest of the program.  If we imagine that the function exhausts its
time budget and the application is running behind schedule and opts to cancel it.
Should the application need to retrieve the work done so far, it must use its
knowledge of how the preemptible function mutates the data structure to individually
validate each portion thereof before trusting it to be in a consistent state.

Even without using cancellation, the traditional hazards of concurrency arise, just
as they do with state-of-the-art abstractions.  This problem space has long posed a
challenge to systems programmers, and we do not pursue any novel solution.  When
using the C interface, the programmer bears complete responsibility for writing code
that is free of data races.  Our Rust API, however, leverages that language's
first-class concurrency support so the compiler can catch such mistakes.


\subsection{Locking and deadlocks}

While the Rust compiler rejects all code that shares state unsafely, it is still
possible to introduce correctness bugs such as deadlock~\cite{www-rustlang-nu}.  This
is nothing new, a common cause being an ordinary function blocking on a
mutual-exclusion lock that is already held by its caller.  But it is especially easy
to make this mistake with preemptible functions.  The developer must remember that
each preemptible function runs on the same thread as its caller, so blocking is not a
legitimate way for a preemptible function to synchronize except with independent
threads.

Still, it is sometimes necessary for a preemptible function to protect a non-atomic
resource from other code on the same thread.  This is possible to do with yielding.
When a preemptible function needs to acquire a mutex, it should use a try lock
operation instead of a blocking lock.  If it fails to acquire exclusive access, it
should call \texttt{pause()} and wait for the caller to reschedule it at a later time
when the resource is hopefully available.  To make this more ergonomic, one could
easily build a custom mutex type that used this algorithm to implement its ``blocking
lock'' operation when called from a preemptible function.

The Rust API includes a \texttt{yielded()} method that the caller can use to
determine whether a preemptible function paused cooperatively.  This can be used to
implement the equivalent of deadlock detection for situations where multiple
preemptible functions are contending for a resource.


\section{Launching a preemptible function}

Invoking the \texttt{launch()} wrapper function with a nonzero time limit does the
following:
\begin{enumerate}
\item Allocates and installs a private thread control block specific to the preemptible function (Section~\ref{sec:libinger:tcbs})
\item Captures a snapshot of the kernel thread's execution context (Section~\ref{sec:libinger:contexts})
\item Allocates and switches to a private execution stack specific to the preemptible function (Section~\ref{sec:libinger:stacks})
\item Allocates a preemption signal specific to the kernel thread (Section~\ref{sec:libinger:signals})
\item Records a timestamp shortly before invoking the preemptible function (Section~\ref{sec:libinger:pausing})
\item Allocates and switches to a private libset specific to the preemptible function (Section~\ref{sec:libinger:isolation})
\item Invokes the preemptible function (Section~\ref{sec:libinger:jumps})
\end{enumerate}

Several of these steps involve allocating resources assigned to each preemptible
function.  Some of these allocations are slow as currently implemented, but the
resources are reusable once a preemptible function has completed or been cancelled.
We use pool allocators to automatically reuse released resources when available.  To
take expensive operations off the critical path, some of the allocators preallocate a
number of instances up front.

The following sections discuss each of the preemptible function invocation steps in
detail.


\section{Thread control blocks}
\label{sec:libinger:tcbs}

As discussed in Section~\ref{sec:libgotcha:tls}, \textit{libgotcha} leaves it to
control libraries to decide the scope of thread-local variables.  However, the
preemptible functions Rust API constrains \textit{libinger}'s choice in the matter.
Because the \texttt{Continuation} type is \texttt{Send}, preemptible functions may
resume execution on a different thread than they were running on before becoming
paused.  To prevent their thread-local variables from changing out from under them,
we therefore associate thread-local variables with the preemptible function instead
of the thread.  Application programmers should be aware that, unlike global
variables, thread locals' values are not shared between a preemptible function and
its defining module.\footnote{Users of thread pools built on top of preemptible
functions need not be aware of this detail, or even of preemptible functions.  This
is because thread pool users must already assume their task will be scheduled on a
different thread than the code that submitted it.}

To allocate a thread control block, \textit{libinger} calls the dynamic linker's
\texttt{\_dl\_allocate\_tls()} function (the same one used by
\texttt{pthread\_create()}).  This function creates a TCB and accompanying TLS area,
but only initializes the latter.  Unfortunately, there are a few TCB fields that must
be initialized for the thread to operate properly, so \textit{libinger} manually sets
those.\footnote{Two of these are self-referential pointers back to the beginning of
the TCB:  One of these is for locating the TLS area, which is located just before the
TCB.  The other is the thread identifier returned by \texttt{pthread\_self()}.  There
is also a pointer guard field that glibc uses to decode some of its internal pointers
that are mangled as an exploit mitigation, and a field containing the kernel's thread
identifier.}  It then calls \texttt{\_\_ctype\_init()} to select the correct
\texttt{ctype.h} implementations for the locale.  Thread control blocks are one of
the resources it pool allocates and reuses unless a preemptible function is
cancelled.  This choice was informed by the expense of allocating TCBs as seen in
Section~\ref{sec:libgotcha:libtlsblock}; however, it is possible to instead reduce
this cost using a technique like the one we prototyped in that section.

To install the TCB, we need to load it into the thread segment register using
\texttt{\_\_arch\_prctl()}.  This is one of the functions that \textit{libgotcha}
wraps (Section~\ref{sec:libgotcha:interpose}); since \textit{libinger} is an internal
control library, it calls \texttt{libgotcha\_arch\_prctl()} instead to also notify
\textit{libgotcha} of the change.


\section{Execution contexts}
\label{sec:libinger:contexts}

The \texttt{Continuation} type inside a paused preemptible function must contain
enough information to resume the function's execution from where it left off, which
could be any program point because we interrupt synchronously.  To capture a snapshot
of the machine registers, we use POSIX contexts, a mechanism for non-local jumps.
Unlike the better known \texttt{setjmp()}/\texttt{longjmp()} interface from the C
standard, POSIX contexts permit capturing an execution snapshot on one thread and
resuming it on another.

One of \texttt{launch()}'s early actions is to snapshot its own execution context.
It keeps this snapshot available while the preemptible function is running; if the
function times out, \textit{libinger} will use the snapshot to jump directly back
into \texttt{launch()} (or \texttt{resume()}), which will populate the
\texttt{Continuation} type and return it to the caller.


\subsection{Using POSIX contexts safely}

Any nontrivial use of the POSIX contexts interface requires some boilerplate code
that is unfortunately subtle in a few ways.  Like the \texttt{setjmp()} function, the
\texttt{getcontext()} function can return multiple times:\@ it always returns once
when the snapshot is initially captured, but each subsequent restoration of the
context causes it to return again.  Unfortunately, it provides no indication of
whether it is returning for the first time, even though the caller almost always
needs to know.  For instance, we only want to launch the preemptible function after
we capture the snapshot, not after it is restored (in which case we want to package
the \texttt{Continuation} and return).  A simple boolean flag does not work because
the compiler is likely to store it in a register, so any updates after the capture
will be undone by the restore.  At a minimum, one must store the flag in a volatile
variable~\cite{getcontext-manpage}.

In C, getting the flag right would be enough boilerplate to use the context, as long
as we did so sensibly.  However, RAII in languages such as Rust makes it very easy to
implicitly create memory corruption.  Consider the example in
Listing~\ref{lst:ingerdoublefree}, which is correct as written deceivingly brittle.
It prints:
\begin{lstlisting}[language=]
  Snapshot was captured!
  About to restore snapshot!
  Snapshot was restored!
  Deallocating `closure`, `capturing`, and `snapshot`!
\end{lstlisting}

\begin{figure}
\begin{lstlisting}[label=lst:ingerdoublefree,caption=Subtly unsound use of POSIX contexts from Rust,morekeywords={let,mut,unsafe}]
unsafe {
	// Closure that runs once right after we capture the snapshot
	let closure = |snapshot| {
		println!("About to restore snapshot!");
		setcontext(snapshot);
	};

	// Flag to track whether we are capturing or restoring the snapshot
	let mut capturing = Volatile::from(true);

	// Checkpoint in the program
	let mut snapshot = MaybeUninit::uninit();
	getcontext(snapshot.as_mut_ptr());

	if capturing.read() {
		println!("Snapshot was captured!");
		capturing.write(false);
		closure(snapshot.assume_init_ref());
	} else {
		println!("Snapshot was restored!");
	}

	println!("Deallocating `closure`, `capturing`, and `snapshot`!");
}
\end{lstlisting}
\end{figure}

The closure here is of type \texttt{Fn(\&ucontext\_t) -> ()}, which means it takes a
reference to a POSIX context and returns nothing.  However, changing the code in the
closure might affect that type.  For example, imagine we had a type
\texttt{OneTimePadded} for storing data that could only be unwrapped once.  We might
want \texttt{closure} to capture such a value and ``decode'' it:
\begin{lstlisting}
  let secret = OneTimePadded::from("About to restore snapshot!");
  let closure = move |snapshot| {
  	println!("{}", secret.into_inner());
	setcontext(snapshot);
  };
\end{lstlisting}

If we make this substitution, the code still compiles.  The program's output
describes when the existing variables go out of scope, but how about the new
\texttt{secret} variable?  Recall that it can only be unwrapped once; therefore the
\texttt{secret.into\_inner()} call consumes it (by taking ownership).  When that call
returns, it will go out of scope and its destructor will be invoked.  This should be
troubling:\@ we said earlier that \texttt{closure} was in scope until the end of the
\texttt{unsafe} block, so it would seem that \texttt{closure} would have to live that
long as well (so that \texttt{secret} would still be deallocated if \texttt{closure}
were never called).

In fact, the Rust compiler is aware that the closure ``uses up'' its captured
variable.  The most important implication of this is that the closure can never be
called more than once, so the compiler has changed its type to
\texttt{FnOnce(\&ucontext\_t) -> ()}.  As with our imagined \texttt{into\_inner()}
method, calling a \texttt{FnOnce} closure consumes the closure.  For this reason, the
scope of \texttt{closure} has changed and it now gets deallocated either when it is
called or at the end of the \texttt{unsafe} block, depending on which branch is
taken.  Unfortunately, when we restore the snapshot, Rust does not know that the
\texttt{if} has already been taken, so it assumes it is in the latter situation and
deallocates \texttt{closure} at the end, calling \texttt{secret}'s destructor in the
process.  If \texttt{secret} includes any heap-allocated memory, this is a double
free.  Note that this unsoundness was introduced not because \texttt{closure} now
captures a variable, but because it \textit{consumes} that variable.

Programmers might need to write preemptible functions that consume variables, so we
want to support this case.  In order for \texttt{launch()} to safely accept a
\texttt{FnOnce}, however, we need to fix the potential double free.  To do so, we
need to make Rust ``leak'' \texttt{closure} in the \texttt{else} branch.  We can do
this by passing it to the standard library function \texttt{mem::forget()}, which
takes ownership of its argument but wraps it in an untagged union so the compiler is
unable to invoke its destructor.  Doing so will leak any of \texttt{closure}'s locals
or captured variables that are still in scope when it called \texttt{setcontext()},
so it should make sure to explicitly deallocate them before doing so by calling the
standard library function \texttt{drop()}.\footnote{The reader might notice that this
will leak the closure itself.  This is inconsequential unless the closure was
allocated on the heap, in which case the disclaimer from
Section~\ref{sec:libinger:cancellation} applies.}  The \textit{libinger}
implementation is careful to do this with its internal variables, but the preemptible
function cannot because pausing is preemptive and can occur at any point in its body
(or that of most functions it might call).  If it is eventually run to completion,
all its variables will go out of scope normally.  Alternatively, it might be
cancelled before this happens (Section~\ref{sec:libinger:cancellation}).

A more obvious thing that a user of POSIX contexts can do wrong is to restore a
snapshot after the function that captured it has returned.  This is undefined
behavior because the stack may have been clobbered, taking with it any local
variables and the return pointer.  To avoid this and the above problems with the flag
and destructors, \textit{libinger} encapsulates boilerplate code with the solutions
we have developed into a \texttt{getcontext()} wrapper function that restricts the
scope of the snapshot to that of a callback function (called in the same place as
\texttt{closure} from the example):
\begin{lstlisting}[morekeywords={fn,impl,FnOnce}]
  fn getcontext(impl FnOnce(&ucontext_t) -> ())
\end{lstlisting}


\section{Execution stacks}
\label{sec:libinger:stacks}

When a preemptible function times out, \textit{libinger} returns a continuation
object.  The caller might pass this object around the program while the function is
paused, then later call \texttt{resume()} from a different stack frame.  Were
\textit{libinger} not careful, this would be equivalent to restoring a POSIX context
whose stack frame had already returned.  To avoid this unsoundness, \texttt{launch()}
allocates a dedicated execution stack and switches to it before calling the
preemptible function.

Figure~\ref{fig:twostacks} shows the frames of both stacks just after we have
transferred control to the user-supplied preemptible function \texttt{\textit{F}()}.
Note that the preemptible function can call functions normally, but that if it
finishes and returns, it will reach the bottom of its stack.  We need a return to
transfer control back to \texttt{launch()} (or \texttt{resume()}, so we must plant a
``return'' address within one of those functions' code at the bottom of the
preemptible function's stack.  To do this, we use the \texttt{makecontext()}
convenience function, which patches a POSIX context with a dedicated stack so that it
restores another context when it returns.  We use the snapshot we captured before
switching stacks (Section~\ref{sec:libinger:contexts}) as the context to restore.
This means that execution proceeds from the same point in \texttt{launch()} or
\texttt{resume()} regardless of whether the function returned normally or timed out.

\begin{figure}
\includegraphics[width=\columnwidth]{figs/twostacks}
\caption{The stacks just after the preemptible function \texttt{\textit{F}()} has been invoked}
\label{fig:twostacks}
\end{figure}

If the function becomes paused, we store its stack in the \texttt{Continuation}
alongside the TCB so neither gets released until the program is done with the
preemptible function.  It is infeasible to relocate a stack in virtual memory while a
preemptible function is paused, so \textit{libinger} currently preallocates large
2-MB stacks to avoid having to resize them (as this should be large enough for any
function that does not stack allocate large locals).  As an implementation shortcut,
it currently allocates the stacks with \texttt{malloc()} but reuses the pool
allocator code to preallocate and reuse stacks (regardless of whether the preemptible
function ended in cancellation).

Neither of these limitations is fundamental.  If one wanted to avoid preallocating
stacks to reduce startup time and physical memory requirements, one could allocate
stacks with \texttt{mmap()} to avoid faulting the pages.  This technique would also
allow one to make resizeable stacks by requesting even ``bigger'' stacks that would
expand to meet functions' needs (up to some fixed maximum size) using demand paging.
If one needed truly ``boundless'' stack sizes, one could place an unmapped guard page
at the top of each stack; if the stack tried to grow into this space, one would
allocate another stack somewhere else and chain them together with another synthetic
return address.


\begin{promotesubsections}
\begin{swallowfigures}
\input[functions]{inger_interrupts}
\end{swallowfigures}
\end{promotesubsections}

\solb{\textbf{Section on deferred preemption}}

\solb{Include specialized version UML call diagram}


\section{Pausing a running preemptible function}
\label{sec:libinger:pausing}


\section{Preemptible function isolation}
\label{sec:libinger:isolation}

\solb{Include discussion of deferred preemption}


\section{Calls and returns}
\label{sec:libinger:jumps}

\solb{Remind them that we end up in the same place regardless of whether they returned or timed out}

\solb{Mention that we save the return value when the preemptible function returns normally}

\solb{Explain that we tell between the two cases by checking whether a return value is present}

\solb{Discuss exception catching and FFI safety}


\section{Canceling a paused preemptible function}
\label{sec:libinger:cancellation}

Should a caller decide not to finish running a timed-out preemptible function, it
must deallocate it.  In Rust, deallocation happens implicitly via the
\texttt{linger\_t} type's destructor, whereas users of the C interface are responsible
for explicitly calling the \textit{libinger} \texttt{cancel()} function.

As discussed in Chapter~\ref{chap:libgotcha}, \textit{libgotcha} returns a
preemptible function's libset to the pool for reuse when that function returns
normally.  However, when a function is cancelled before it finishes, none of the
modules in its libset is safe to reuse in general:\@ a library function might have
been in the middle of executing.  To avoid future problems with the libset, as part
of a cancellation, \textit{libinger} instructs \textit{libgotcha} to reinitialize the
function's libset before returning it to the pool.

Cancellation cleans up \textit{libinger} resources allocated by \texttt{launch()};
however, the current implementation does not automatically release resources already
claimed by the preemptible function itself.  However, we have prototyped a solution
that demonstrates the feasibility of such cleanup in RAII languages such as Rust.
We detail this approach in Chapter~\ref{chap:ingerc}.


\section{Evaluation}

\input[functions]{eval_testbed}


\subsection{Microbenchmarks}

\input[functions]{eval_uinger}


\subsection{Image decompression}

Unlike state of the art approaches, lightweight preemptible functions support
cancellation.
\begin{sloppypar}
\input[functions]{eval_cancel}
\end{sloppypar}
