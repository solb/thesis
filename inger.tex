\chapter{Function calls with timeouts, revisited: \\ the \textit{libinger} library}
\label{chap:libinger}

\ifdefined\chapquotes
\vspace{-0.5in}
\begin{chapquote}[1.5in]{David Mitchell, \textit{Cloud Atlas}}
A half-read book is a half-finished love affair.
\end{chapquote}
\fi

In Chapter~\ref{chap:functions}, we introduced and motivated lightweight preemptible
functions, a novel concurrency abstraction pairing synchronous invocation with
preemption.  At that time, we covered the design principles underlying the API for
managing preemptible functions; in this chapter, we will discuss the API itself in
more detail and the design and implementation of \textit{libinger}, the library that
provides preemptible functions.

We start by giving the full \textit{libinger} C interface in
Listing~\ref{lst:ingerfullapi}.  The \texttt{launch()} and \texttt{resume()}
functions work as already described:\@ the former creates a new preemptible function
and lets it run on the caller's thread for the specified number of microseconds
(which may be zero), and the latter resumes a preemptible function that had become
paused after exhausting its time budget.  The new \texttt{cancel()} function allows
the caller to discontinue a paused preemptible function rather than allowing it to
run to completion.  Finally, the \texttt{pause()} function may be called from within
a preemptible function to cooperatively yield.  It immediately pauses the function
and returns to its caller, just as if the function had been preempted.

The Rust interface appears in Listing~\ref{lst:ingerrustapi} and differs in several
important ways:

\begin{figure}
\begin{lstlisting}[label=lst:ingerfullapi,caption=Preemptible functions extended C interface,morekeywords=uint64_t]
struct linger_t {
	bool is_complete;
	cont_t continuation;
};

typedef void (*Function)(void *);

linger_t launch(Function func,
                  uint64_t time_us,
                  void *args);
void resume(linger_t *cont, uint64_t time_us);
void cancel(linger_t *cont);
void pause(void);
\end{lstlisting}
\end{figure}

\begin{figure}
\begin{lstlisting}[label=lst:ingerrustapi,caption=Preemptible functions Rust interface,morekeywords={fn,impl,mut,pub,self,u64,Drop,Result,Send}]
pub enum Linger<T> {
	Completion(T),
	Continuation(Continuation),
	Poison,
}

pub fn launch<T: Send>(func: impl FnOnce() -> T + Send,
			 time_us: u64) -> Result<Linger<T>>;
pub fn resume<T>(func: &mut Linger<T>,
		   time_us: u64) -> Result<&mut Linger<T>>;
pub fn pause();

impl<T> Linger<T> {
	pub fn yielded(&self) -> bool;
}

impl Drop for Continuation { ... }
\end{lstlisting}
\end{figure}


\paragraph{Closure support.}
We leverage Rust's first-class closures to enable the caller to pass
\texttt{launch()} a function that captures state from its environment.  We expect the
caller to provide any inputs to the function in this manner.  Unlike with the C
interface, there is no need to wrap the arguments in a struct when there are
multiple, or to pass an empty value when there are none.


\paragraph{Type safety.}
The aforementioned interface change means that the Rust wrapper functions do not
erase the types of the preemptible function's parameters by diluting them to a
\texttt{void *}; thus, the preemptible function does not have to perform an unsafe
cast before using them, and the compiler can still type check the program.
Furthermore, both \texttt{launch()} and \texttt{resume()} are generic on the
preemptible function's return type:\@ instead of a \texttt{linger\_t}, they return a
tagged union.  Once the preemptible function runs to completion, the caller may
destructure this type to retrieve the function's return value.  Because the union is
tagged, it is impossible to destructure it to retrieve the return value unless the
function has truly run to completion.


\paragraph{RAII.}
Our Rust interface adheres to the RAII (Resource Allocation Is Initialization) idiom,
allowing continuation deallocation to happen automatically.  Unlike the C interface,
the Rust one has no \texttt{cancel()} function; instead, its continuation objects
implement the language's \texttt{Drop} trait.  Whenever a continuation goes out of
scope without being consumed by running to completion, the language calls its
destructor, which implicitly performs a cancellation.


\paragraph{Safe concurrency.}
The \texttt{launch()} function requires that the preemptible function closure
implement the language's \texttt{Send} trait, which is true provided that all of the
values it captures have this trait.  In Rust, a type is \texttt{Send} if and only if
ownership of it can be safely transferred between threads.  This includes all objects
that do not contain any references, as well as those that do but only to data that is
safe to access concurrently (\texttt{Sync} in Rust parlance)~\cite{www-rustlang-conc}.
This restriction on
the closure means that any attempt to share state between a caller and its
preemptible function without the use of appropriate concurrency control will fail at
compile time.


\paragraph{Flexibility.}
The requirement that Rust preemptible functions be \texttt{Send} is similar to the
restrictions imposed by the standard library's thread \texttt{spawn()} interface.
However, \texttt{launch()} differs in an important way:\@ unlike a thread, a
preemptible function is not restricted to the \texttt{'static} lifetime, and so is
able to accept references to local variables and other dynamically-allocated data.
In contrast, attempts to transfer such references to a thread would result in a
compile error.  What makes it safe to use all lifetimes with preemptible functions is
the fact that they execute synchronously, and therefore cannot outlive the calling
context without first becoming paused.  If a preemptible function times out, the Rust
compiler knows the lifetime of any references it has captured, so any attempt to pass
the paused closure to a scope where its shared data no longer exists will be met with
a compile error.


\section{Shared responsibility for concurrency control}

The preceding points about concurrency restrictions in the Rust API may seem
incongruous with Chapter~\ref{chap:libgotcha}, which spent dozens of pages
introducing selective relinking, a technique billed as solving the concurrency perils
of preemptible functions.  In fact, that runtime exists to address a completely
separate (but equally critical) problem.

Adding preemptible functions to an application actually introduces two distinct forms
of concurrency.  Both stem from the fact that code within the same thread is now
allowed to interleave its execution at almost entirely arbitrary points, but they
differ in whether the code in question can possibly anticipate this problem, and
therefore have any hope of addressing it.

First, there is concurrency involving the libraries that the program depends on, many
of which were probably authored by third parties.  Although such libraries now
execute concurrently with preemptible functions by virtue of being used from the same
kernel thread, they conceptually ``predate'' preemptible functions' existence; that
is, they cannot even be expected to be aware of this concurrency.  The job of
\textit{libgotcha} is to reconcile this, first by establishing an isolation boundary
between each library (and the executable, for that matter) and the rest of the
program, and then by deferring preemption where shared state is still unavoidable.

Separately, there is concurrency involving the code that uses the preemptible
functions abstraction (i.e., implements and invokes preemptible functions).  Not only
\textit{can} this code take measures to ensure this concurrency is safe:\@ it has to
be the one to do so.  This is because there is often a legitimate need to explicitly
exchange information between a preemptible function and the surrounding program, in
which case the possibility of interleaving must be directly confronted.  As a simple
example, consider a preemptible function that is populating some data structure for
later use by the rest of the program.  If we imagine that the function exhausts its
time budget and the application is running behind schedule and opts to cancel it.
Should the application need to retrieve the work done so far, it must use its
knowledge of how the preemptible function mutates the data structure to individually
validate each portion thereof before trusting it to be in a consistent state.

Even without using cancellation, the traditional hazards of concurrency arise, just
as they do with state-of-the-art abstractions.  This problem space has long posed a
challenge to systems programmers, and we do not pursue any novel solution.  When
using the C interface, the programmer bears complete responsibility for writing code
that is free of data races.  Our Rust API, however, leverages that language's
first-class concurrency support so the compiler can catch such mistakes.


\subsection{Locking and deadlocks}

While the Rust compiler rejects all code that shares state unsafely, it is still
possible to introduce correctness bugs such as deadlock~\cite{www-rustlang-nu}.  This
is nothing new, a common cause being an ordinary function blocking on a
mutual-exclusion lock that is already held by its caller.  But it is especially easy
to make this mistake with preemptible functions.  The developer must remember that
each preemptible function runs on the same thread as its caller, so blocking is not a
legitimate way for a preemptible function to synchronize except with independent
threads.

Still, it is sometimes necessary for a preemptible function to protect a non-atomic
resource from other code on the same thread.  This is possible to do with yielding.
When a preemptible function needs to acquire a mutex, it should use a try lock
operation instead of a blocking lock.  If it fails to acquire exclusive access, it
should call \texttt{pause()} and wait for the caller to reschedule it at a later time
when the resource is hopefully available.  To make this more ergonomic, one could
easily build a custom mutex type that used this algorithm to implement its ``blocking
lock'' operation when called from a preemptible function.

The Rust API includes a \texttt{yielded()} method that the caller can use to
determine whether a preemptible function paused cooperatively.  This can be used to
implement the equivalent of deadlock detection for situations where multiple
preemptible functions are contending for a resource.


\section{Launching a preemptible function}

Invoking the \texttt{launch()} wrapper function with a nonzero time limit does the
following:
\begin{enumerate}
\item Allocates and installs a private thread control block specific to the preemptible function (Section~\ref{sec:libinger:tcbs})
\item Captures a snapshot of the kernel thread's execution context (Section~\ref{sec:libinger:contexts})
\item Allocates and switches to a private execution stack specific to the preemptible function (Section~\ref{sec:libinger:stacks})
\item Allocates a preemption signal specific to the kernel thread (Section~\ref{sec:libinger:signals})
\item Records a timestamp shortly before invoking the preemptible function (Section~\ref{sec:libinger:pausing})
\item Allocates and switches to a private libset specific to the preemptible function (Section~\ref{sec:libinger:isolation})
\item Invokes the preemptible function (Section~\ref{sec:libinger:jumps})
\end{enumerate}

The following sections discuss each of these steps in detail.


\section{Thread control blocks}
\label{sec:libinger:tcbs}

As discussed in Section~\ref{sec:libgotcha:tls}, \textit{libgotcha} leaves it to
control libraries to decide the scope of thread-local variables.  However, the
preemptible functions Rust API constrains \textit{libinger}'s choice in the matter.
Because the \texttt{Continuation} type is \texttt{Send}, preemptible functions may
resume execution on a different thread than they were running on before becoming
paused.  To prevent their thread-local variables from changing out from under them,
we therefore associate thread-local variables with the preemptible function instead
of the thread.  Application programmers should be aware that, unlike global
variables, thread locals' values are not shared between a preemptible function and
its defining module.\footnote{Users of thread pools built on top of preemptible
functions need not be aware of this detail, or even of preemptible functions.  This
is because thread pool users must already assume their task will be scheduled on a
different thread than the code that submitted it.}

To allocate a thread control block, \textit{libinger} calls the dynamic linker's
\texttt{\_dl\_allocate\_tls()} function (the same one used by
\texttt{pthread\_create()}).  This function creates a TCB and accompanying TLS area,
but only initializes the latter.  Unfortunately, there are a few TCB fields that must
be initialized for the thread to operate properly, so \textit{libinger} manually sets
those.\footnote{Two of these are self-referential pointers back to the beginning of
the TCB:  One of these is for locating the TLS area, which is located just before the
TCB.  The other is the thread identifier returned by \texttt{pthread\_self()}.  There
is also a pointer guard field that glibc uses to decode some of its internal pointers
that are mangled as an exploit mitigation, and a field containing the kernel's thread
identifier.}  It then calls \texttt{\_\_ctype\_init()} to select the correct
\texttt{ctype.h} implementations for the locale.

To install the TCB, we need to load it into the thread segment register using
\texttt{\_\_arch\_prctl()}.  This is one of the functions that \textit{libgotcha}
wraps (Section~\ref{sec:libgotcha:interpose}); since \textit{libinger} is an internal
control library, it calls \texttt{libgotcha\_arch\_prctl()} instead to also notify
\textit{libgotcha} of the change.


\section{Execution contexts}
\label{sec:libinger:contexts}

\thesis{Give a tour of \textit{libtimetravel}?}


\begin{promotesubsections}
\input[functions]{inger_stacks}
\label{sec:libinger:stacks}

\solb{Mention that this preallocation is not fundamental}

\solb{Cover cool disaggregation trick for growable stacks}

\solb{Fix (mis)uses of the term continuation}


\input[functions]{inger_interrupts}
\end{promotesubsections}

\solb{\textbf{Section on deferred preemption}}

\solb{Include specialized version UML call diagram}


\section{Pausing a running preemptible function}
\label{sec:libinger:pausing}


\section{Preemptible function isolation}
\label{sec:libinger:isolation}


\section{Calls and returns}
\label{sec:libinger:jumps}


\section{Canceling a paused preemptible function}

Should a caller decide not to finish running a timed-out preemptible function, it
must deallocate it.  In Rust, deallocation happens implicitly via the
\texttt{linger\_t} type's destructor, whereas users of the C interface are responsible
for explicitly calling the \textit{libinger} \texttt{cancel()} function.

As discussed in Chapter~\ref{chap:libgotcha}, \textit{libgotcha} returns a
preemptible function's libset to the pool for reuse when that function returns
normally.  However, when a function is cancelled before it finishes, none of the
modules in its libset is safe to reuse in general:\@ a library function might have
been in the middle of executing.  To avoid future problems with the libset, as part
of a cancellation, \textit{libinger} instructs \textit{libgotcha} to reinitialize the
function's libset before returning it to the pool.

Cancellation cleans up \textit{libinger} resources allocated by \texttt{launch()};
however, the current implementation does not automatically release resources already
claimed by the preemptible function itself.  However, we have prototyped a solution
that demonstrates the feasibility of such cleanup in RAII languages such as Rust.
We detail this approach in Chapter~\ref{chap:ingerc}.


\section{Evaluation}

\input[functions]{eval_testbed}


\subsection{Microbenchmarks}

\input[functions]{eval_uinger}


\subsection{Image decompression}

Unlike state of the art approaches, lightweight preemptible functions support
cancellation.
\begin{sloppypar}
\input[functions]{eval_cancel}
\end{sloppypar}
