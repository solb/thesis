\chapter{Conclusions and continuations}
\label{chap:thatsawrap}

At the start of this thesis, we presented our contributions in this thesis statement:
\begin{quote}
\input{statement}
\end{quote}

We now break this down and briefly recap our work pertaining to each of its claims
(Section~\ref{sec:thatsawrap:contributions}), discuss applications and directions for
future work (Section~\ref{sec:thatsawrap:applications}), review a selection of the
technical challenges we had to overcome (Section~\ref{sec:thatsawrap:challenges}),
and distill a few lessons for future systems builders
(Section~\ref{sec:thatsawrap:lessons}).


\section{Contributions}
\label{sec:thatsawrap:contributions}

The thesis statement makes specific references to key contributions throughout this
thesis.  We collect these references here, along with pointers back to the relevant
chapters and sections.

\paragraph{Novel programming abstractions for isolation of both time and memory}
These abstractions are lightweight preemptible functions and selective relinking.
They are introduced in Chapter~\ref{chap:functions} and Chapter~\ref{chap:libgotcha},
respectively.

\paragraph{Preemption at sub-millisecond timescales}
We found in Section~\ref{sec:libinger:quantum} that the modern systems stack is
capable of supporting timer signals with periods on the order of microseconds.  We
argued that the design of lightweight preemptible functions is compatible with
preemption quanta down to at least the tens of microseconds, with scaling limited by
increasing CPU time overheads.  We also demonstrated that the latency of invoking a
preemptible function is in the same order of magnitude
(Section~\ref{sec:libinger:ueval}).  This is one order of magnitude faster than
forking a new process and two orders of magnitude than the typical operating system
preemption quantum.

\paragraph{Tasks defined at the level of a function call}
Both lightweight preemptible functions and selective relinking explicitly treat
function calls as an isolation boundary.  The former expresses this boundary by
asking the programmer to annotate preemptible functions by invoking them with a
wrapper function (Section~\ref{sec:libinger}); the latter does so by intercepting
calls to dynamically-linked functions based on the context of the call
(Section~\ref{sec:libsets}) and knowledge of specific functions that cannot be
protected solely through memory isolation (Section~\ref{sec:libgotcha:unint}).  That
our system understands function calls is significant because traditionally both
preemption and memory isolation have operated exclusively at the granularity of a
kernel thread.

\paragraph{New functionality for application programmers}
It is worth emphasizing that our abstractions are available in userland and
accessible to any programmer experienced with concurrency.  They expose powerful APIs
that we summarize in Listings~\ref{lst:ingerfullapi} and \ref{lst:ingerrustapi}
(lightweight preemptible functions) and Listings~\ref{lst:gotchaapi} and
\ref{lst:gotchacbapi} (selective relinking).  The preemptible functions Rust API is
even type safe and usable in contexts where the standard library does not allow
thread spawns (Chapter~\ref{chap:libinger}).  Preemptible functions themselves serve
as an example application for selective relinking, and
Chapters~\ref{chap:strobelight} and
\ref{chap:microservices} present case studies in building systems atop preemptible
functions.  Simpler applications include detection of pathological cases such as
adversarially-constructed compressed images (Section~\ref{sec:libinger:bombs}) and
graceful degradation by dropping video frames.

\paragraph{Unmanaged systems programming languages}
Unlike prior art, our abstractions are restricted neither to purely functional code
nor to managed languages with heavyweight, garbage-collected runtimes
(Section~\ref{sec:related}).  In principle, their only operating system and runtime
requirements are timer signals (Section~\ref{sec:libinger:signals}) and dynamic
linking (Section~\ref{sec:libgotcha:portability}).\footnote{It helps to also have
exception handling, as per Section~\ref{sec:ingerc:raii}.}  We officially support the
low-level C and Rust systems programming languages.  We have tried to keep the API
language agnostic, and the fact that many languages include C foreign-function
interfaces means that some of them may already be able to use preemptible functions
out of the box.

\paragraph{Without requiring changes to the existing systems stack}
We implement everything entirely in userland by building on existing abstractions
such as dynamic linking, memory protection, POSIX signals and timers, and exception
handling.  Where we alter the behavior of the dynamic linker and C runtime, we make
those changes at load time (Section~\ref{sec:gotchainit}).  (While we do not in
principle require a custom glibc, one must rebuild from source with a different
configuration macro for full functionality, as explained in
Section~\ref{sec:libgotcha:scalability}.  The only component of the system that
absolutely requires the developer of an application to rebuild its dependencies is
cancellation resource cleanup, per Sections~\ref{sec:ingerc:start},
\ref{sec:ingerc:boundary}, and \ref{sec:ingerc:cancellation}.)

\paragraph{Synchronous invocation}
Unlike threads and callback-based futures, preemptible functions are invoked
synchronously.  This eliminates the need for an external scheduler and the associated
overhead in cases where the programmer is willing to manually manage which
preemptible function to launch or resume next (Chapter~\ref{chap:functions}).  It
also allows a preemptible closure to safely capture local variables in Rust
(Chapter~\ref{chap:libinger}).

\paragraph{Compose naturally with existing concurrency abstractions}
Both abstractions are usable in multithreaded contexts.  In fact, one can even take a
paused preemptible function that was executing one one kernel thread and resume it
on a different one (Section~\ref{sec:libinger:tcbs}), a property that allows
schedulers to treat preemptible functions like any other task.  Preemptible functions
can be used to construct preemptible futures (Section~\ref{sec:libturquoise:prefuts})
and even mutexes with \texttt{await}-style call with current continuation semantics
(Section~\ref{sec:libinger:locks}).

\paragraph{Asynchronous cancellation of threads}
It has long proven difficult to cancel running threads, both at the operating system
level (Chapter~\ref{chap:functions}) and at the language level
(Chapter~\ref{chap:strobelight}).  We
discover that we can leverage the memory isolation provided by selective relinking to
enable asynchronous cancellation of POSIX threads, a feature that is almost unusable
as shipped in the Unix operating system and its clones
(Chapter~\ref{sec:safety:acsafe}).  Although resource leaks remain a problem
(Section~\ref{sec:safety:thread}), it may be possible to address them for languages
conforming to RAII (Chapter~\ref{chap:ingerc}).

\paragraph{Preemptive thread libraries in userland}
By modifying the thread pool from a Rust futures executor to use transparently wrap
tasks in preemptible futures, we have created arguably the first general-purpose
preemptive thread library implemented entirely in userland.  Details are in
Chapter~\ref{chap:libturquoise}.


\section{Applications and future work}
\label{sec:thatsawrap:applications}

This thesis leaves ample opportunity for future work on lightweight preemptible
functions and selective relinking.  Possible directions include exploring other
applications for our abstractions, conducting a deeper investigation of our example
applications, making performance improvements, lifting scalability restrictions,
adding defense in depth, improving application compatibility, and contributing more
of our discoveries upstream.

There are plenty of possible applications we have not explored.  We have focused on
preemptible functions that use timeouts as a resource limit, but the underlying
fine-grained preemption we developed to support them is actually more general.  One
can imagine applying it to real-time scheduling or imposing quotas based on resources
other than time, such as data transferred or number of page faults.
Chapter~\ref{chap:microservices} proposed the use of preemptible functions to merge
multiple cloud tenants' microservices into a single worker process, a technique that
could be applied to locally-running programs as well.  One could even write a tool
that took two or more dynamically-linked position-independent executables and merged
them into a single application that included in-process scheduling.  Selective
relinking, with its ability to intercept function calls and issue notification
callbacks, surely has applications in aspect-oriented programming.  Its techniques
could be applied to other problems as well, such as allowing applications to depend
on more than one version of a dynamic library.  Both abstractions enable many new use
cases, and we are sure there are many we have not thought of.

Those applications that we have explored also merit deeper study.
Section~\ref{sec:safety:assafe} demonstrated how selective relinking can be used to
lift the primary safety restriction on signal handlers.  Our treatment was brief, but
in our opinion it represents such a significant improvement to the signal abstraction
that it would be worth carrying beyond the prototype stage.  In creating an
implementation suitable for deployment, one might explore isolating each signal
handler from the others or defining a completely safe interface for signal handling
in Rust or another language with a sound type system.
Section~\ref{sec:safety:acsafe} gave a preliminary implementation of asynchronous
thread cancellation, a feature that operating systems and programming languages alike
have long struggled to support.  Refining this prototype might involve fixing the
resource leaks problem by integrating the automatic cleanup approach we sketched in
Chapter~\ref{chap:ingerc}.
We think that preemptible futures and preemptive userland threading hold enormous
potential for building scalable systems with better resistance to denial of service
attacks.  We implemented these concepts before we had proper support for thread-local
storage and at a time when the Rust ecosystem was in flux because the language was
just stabilizing futures and async/await.  As such, the majority of the preemptible
future code is compatibility calls to convert between different future interfaces,
and the thread pool works only with a very old version of the Tokio futures executor.
Porting to a modern futures executor and adding proper support for thread locals
would permit experiments on the latest high-performance systems.

The performance of our implementation could be improved in several ways.  As
Section~\ref{sec:libinger:quantum} noted, one current limitation is our use of a
globally constant preemption quantum.  We could reduce the throughput overhead while
preserving preemption granularity by varying the interval based on the requested
timeout and delaying the first signal for longer-running preemptible functions.  Even
more granular preemption might be achievable by using hardware interrupts directly
instead of paying the overhead of POSIX signals; options include a custom kernel
module or porting to the Dune system~\cite{Belay:osdi2012}.  We saw in
Section~\ref{sec:libgotcha:libtlsblock} that the increased TLS size has an impact on
thread spawn performance.  Incorporating a more robust implementation of the
workaround we prototyped in that section into \textit{libgotcha} would mitigate much
of this effect.  This might also eliminate the need to preallocate TCBs up front to
keep preemptible function launch latencies low.

Another area for improvement is scalability, as ours is currently constrained in
multiple ways.  Preemptible functions' stacks have a fixed size, but leveraging
demand paging would resolve this problem and also avoid having to preallocate them
(Section~\ref{sec:libinger:stacks}).  The fact that we need a dedicated preemption
signal for each preemptible function places a fixed upper bound on parallelism, but
(mis)using glibc's nonstandard \texttt{SIGEV\_THREAD\_ID} feature intended for thread
libraries could make a single signal sufficient (Section~\ref{sec:libinger:signals}).
That the dynamic linker supports a limited number of namespaces determined at compile
time places a fixed upper bound on concurrency, but one could port selective
relinking to an alternative dynamic linker such as drow
(Section~\ref{sec:libgotcha:scalability}).  Our current implementation reduces
runtime latency at the cost of startup time, which is fine for long-running processes
or where workers can be spawned from template ``zygote'' processes, but could pose
issues otherwise.  The performance and scalability improvements proposed thus far are
likely to make pool allocators unnecessary for TCBs and stacks, the largest resources
we preallocate.  Our remaining startup overhead comes from preparing all libsets at
load time, a tradeoff that one would already have to revisit in order to support a
variable number of libsets.

Applying our isolation mechanisms to multi-tenancy situations as proposed in
Chapter~\ref{chap:microservices} would require defense in depth.  Both
\textit{libgotcha} and \textit{libinger} would benefit from using forced
interposition (Section~\ref{sec:libgotcha:interpose}) to replace library functions
that could be used to circumvent selective relinking and preemption in isolated code
regions (e.g., by interfering with signals).  One might also consider expanding the
preemptible functions interface to allow configurable isolation of other actions that
could affect the rest of the application, such as raising exceptions
(Section~\ref{sec:libinger:jumps}).

There are a few enhancements that would improve compatibility, making more unmodified
existing code work with libsets and within preemptible functions.  One could replace
library functions that exhibit unusual signal interruption behavior with wrappers
that hid those differences (Section~\ref{sec:libinger:compatibility}).  One could
detect signals already used by the application to avoid conflicting allocation of the
same signals for preemption (Section~\ref{sec:libinger:signals}).  One could improve
interception of global variable accesses to properly support symbols of any size and
remove the reliance on heuristics that cannot handle certain instruction sequences
(Section~\ref{sec:libgotcha:globals}).  One could consider supporting preemptible
functions that spawned threads and/or forked new processes.  Finally, one could
implement support for nested preemptible functions.

While we have discovered and reported multiple bugs over the course of this project,
we have encountered other issues that may or may not be worth addressing upstream.
In some cases, it was unclear whether issues truly represented a misimplementation of
the relevant specification, or whether they were relevant outside our own specific
and arcane use of runtime features.  It is likely worth revisiting our workarounds
and considering which could be reimplemented upstream to benefit other users.
Examples include \texttt{\_Unwind\_RaiseException()}'s linker namespace limitations
(Section~\ref{sec:libgotcha:interpose}), GDB's reluctance to load symbols from
modules loaded in alternate namespaces (Section~\ref{sec:libgotcha:portability}),
scaling problems in glibc's allocation of TCBs
(Section~\ref{sec:libgotcha:libtlsblock}), certain glibc functions misbehaving in
alternate namespaces (Section~\ref{sec:libinger:compatibility}), and what may be an
off-by-one error in libgcc and libunwind's implementation of the DWARF specification
(Section~\ref{sec:ingerc:boundary}).


\section{Technical challenges}
\label{sec:thatsawrap:challenges}

\solb{Second reason \textit{libgotcha} is called that}

insight: \solb{Cross-module symbol references Section~\ref{sec:libgotcha:crossref} 3.3.1}

glibc: \solb{\texttt{NODELETE} shared libraries Section~\ref{sec:gotchainit} 3.4}

hacking: \solb{Need to write \texttt{procedure\_linkage\_override()} in assembly and design data structures and thread locals to be friendly to use Sections~\ref{sec:libgotcha:functions} and \ref{sec:libgotcha:tls} 3.5.1 3.7.2}

Rust: \solb{Clobbering Rust fat pointers in \texttt{procedure\_linkage\_override()}}

hacking: \solb{Generating executable PLOT stubs Section~\ref{sec:libgotcha:functions} 3.5.1}

insight: \solb{Pointer equality rewrite and subtly that pointers can be the same within a certain context without actually being resolved Section~\ref{sec:libgotcha:functions} 3.5.1}

insight: \solb{Rewriting relocations for lazily-resolved function calls Section~\ref{sec:libgotcha:functions} 3.5.1}

glibc: \solb{GNU indirect symbols caused mysterious crashes Section~\ref{sec:libgotcha:functions} 3.5.1}

hacking: \solb{Intercepting global variable accesses (segfault handler tricky to debug, assembler, heuristics) Section~\ref{sec:libgotcha:globals} 3.5.2}

glibc: \solb{Dealing with \texttt{\_\_rtld\_global} monkey patching and \texttt{\_dl\_open()} use of return address Section~\ref{sec:libgotcha:unintfuns} 3.6.1}

hacking: \solb{Can get callback to fire at end of uninterruptible region by adding a fake stack frame, but must ensure this cannot be triggered again from within the callback itself Section~\ref{sec:libgotcha:callbacks} 3.6.2}

hacking: \solb{Compiler optimizations and alias symbols to get interposition ``recursive'' calls to resolve correctly Section~\ref{sec:libgotcha:interpose} 3.7.1}

glibc: \solb{\texttt{\_Unwind\_RaiseException()} for namespaces Section~\ref{sec:libgotcha:interpose} 3.7.1}

hacking: \solb{Need paused preemptible functions to be able to travel between threads Section~\ref{sec:libgotcha:tls} 3.7.2}

glibc: \solb{Failing to raise our preemption signal in the \textit{libinger} callback Section~\ref{sec:libgotcha:tls} 3.7.2}

insight: \solb{TLS deferred reinitialization laziness scheme Section~\ref{sec:libgotcha:tls} 3.7.2}

glibc: \solb{Working around glibc 2.30's ban on \texttt{dlopen()}'ing executables Section~\ref{sec:libgotcha:portability} 3.8.1}

glibc: \solb{Growing \texttt{\_rtld\_global\_ro} region Section~\ref{sec:libgotcha:portability} 3.8.1}

glibc: \solb{Exhausting the static TLS space Section~\ref{sec:libgotcha:scalability} 3.8.2}

insight: \solb{\texttt{COPY} relocations Section~\ref{sec:limits} 3.8.3}

glibc: \solb{Getting \textit{libas-safe} and the POSIX test preload library to initialize as late as possible before \texttt{main()} Sections~\ref{sec:safety:assafe} and \ref{sec:libinger:compatibility}}

glibc: \solb{Critical TCB fields including self-referential ones Section~\ref{sec:libinger:tcbs} 5.3}

Rust: \solb{Self-referential field in POSIX contexts}

Rust: \solb{Bookkeeping and double frees with POSIX contexts Section~\ref{sec:libinger:boilerplate} 5.4.1}

insight: \solb{Portable thread-directed signals using a pool and convergence Section~\ref{sec:libinger:signals} 5.6}

insight: \solb{Restoring POSIX contexts obtained from signal handlers Section~\ref{sec:libinger:resuming} 5.7.1}

insight: \solb{Asynchronous exception handling Section~\ref{sec:ingerc:async} 6.4}


\section{Lessons for systems builders}
\label{sec:thatsawrap:lessons}

\solb{
Resuming is a useful feature that is cheap, but introduces concurrency.
Cannot get CPU time isolation without memory isolation.
Design abstractions modularly and with an eye to simple use cases (e.g., \textit{libgotcha} as a separate
runtime with a very small control API, things listed in the note on design).
Treat debuggability as a first-order concern (e.g., permit disabling features that interfere at
runtime, test and maintain support for running under debugging and diagnostic tools).
}

\solb{Debugging tools in 3.8 libgotcha limitations and 4.1.1 handler example program and 3.6.1 monkey patching warning and 5.4.1 plus debug build runtime checks}
