\chapter{Conclusions and continuations}
\label{chap:thatsawrap}

At the start of this thesis, we presented our contributions in this thesis statement:
\begin{quote}
\input{statement}
\end{quote}

We now break this down and briefly recap our work pertaining to each of its claims
(Section~\ref{sec:thatsawrap:contributions}), discuss applications and directions for
future work (Section~\ref{sec:thatsawrap:applications}), review a selection of the
technical challenges we had to overcome (Section~\ref{sec:thatsawrap:challenges}),
and distill a few lessons for future systems builders
(Section~\ref{sec:thatsawrap:lessons}).


\section{Contributions}
\label{sec:thatsawrap:contributions}

The thesis statement makes specific references to key contributions throughout this
thesis.  We collect these references here, along with pointers back to the relevant
chapters and sections.

\paragraph{Novel programming abstractions for isolation of both time and memory}
These abstractions are lightweight preemptible functions and selective relinking.
They are introduced in Chapter~\ref{chap:functions} and Chapter~\ref{chap:libgotcha},
respectively.

\paragraph{Preemption at sub-millisecond timescales}
We found in Section~\ref{sec:libinger:quantum} that the modern systems stack is
capable of supporting timer signals with periods on the order of microseconds.  We
argued that the design of lightweight preemptible functions is compatible with
preemption quanta down to at least the tens of microseconds, with scaling limited by
increasing CPU time overheads.  We also demonstrated that the latency of invoking a
preemptible function is in the same order of magnitude
(Section~\ref{sec:libinger:ueval}).  This is one order of magnitude faster than
forking a new process and two orders of magnitude than the typical operating system
preemption quantum.

\paragraph{Tasks defined at the level of a function call}
Both lightweight preemptible functions and selective relinking explicitly treat
function calls as an isolation boundary.  The former expresses this boundary by
asking the programmer to annotate preemptible functions by invoking them with a
wrapper function (Section~\ref{sec:libinger}); the latter does so by intercepting
calls to dynamically-linked functions based on the context of the call
(Section~\ref{sec:libsets}) and knowledge of specific functions that cannot be
protected solely through memory isolation (Section~\ref{sec:libgotcha:unint}).  That
our system understands function calls is significant because traditionally both
preemption and memory isolation have operated exclusively at the granularity of a
kernel thread.

\paragraph{New functionality for application programmers}
It is worth emphasizing that our abstractions are available in userland and
accessible to any programmer experienced with concurrency.  They expose powerful APIs
that we summarize in Listings~\ref{lst:ingerfullapi} and \ref{lst:ingerrustapi}
(lightweight preemptible functions) and Listings~\ref{lst:gotchaapi} and
\ref{lst:gotchacbapi} (selective relinking).  The preemptible functions Rust API is
even type safe and usable in contexts where the standard library does not allow
thread spawns (Chapter~\ref{chap:libinger}).  Preemptible functions themselves serve
as an example application for selective relinking, and Chapters~TODO and
\ref{chap:microservices} present case studies in building systems atop preemptible
functions.  Simpler applications include detection of pathological cases such as
adversarially-constructed compressed images (Section~\ref{sec:libinger:bombs}) and
graceful degradation by dropping video frames.

\paragraph{Unmanaged systems programming languages}
Unlike prior art, our abstractions are restricted neither to purely functional code
nor to managed languages with heavyweight, garbage-collected runtimes
(Section~\ref{sec:related}).  In principle, their only operating system and runtime
requirements are timer signals (Section~\ref{sec:libinger:signals}) and dynamic
linking (Section~\ref{sec:libgotcha:portability}).\footnote{It helps to also have
exception handling, as per Section~\ref{sec:ingerc:raii}.}  We officially support the
low-level C and Rust systems programming languages.  We have tried to keep the API
language agnostic, and the fact that many languages include C foreign-function
interfaces means that some of them may already be able to use preemptible functions
out of the box.

\paragraph{Without requiring changes to the existing systems stack}
We implement everything entirely in userland by building on existing abstractions
such as dynamic linking, memory protection, POSIX signals and timers, and exception
handling.  Where we alter the behavior of the dynamic linker and C runtime, we make
those changes at load time (Section~\ref{sec:gotchainit}).  (While we do not in
principle require a custom glibc, one must rebuild from source with a different
configuration macro for full functionality, as explained in
Section~\ref{sec:libgotcha:scalability}.  The only component of the system that
absolutely requires the developer of an application to rebuild its dependencies is
cancellation resource cleanup, per Sections~\ref{sec:ingerc:start},
\ref{sec:ingerc:boundary}, and \ref{sec:ingerc:cancellation}.)

\paragraph{Synchronous invocation}
Unlike threads and callback-based futures, preemptible functions are invoked
synchronously.  This eliminates the need for an external scheduler and the associated
overhead in cases where the programmer is willing to manually manage which
preemptible function to launch or resume next (Chapter~\ref{chap:functions}).  It
also allows a preemptible closure to safely capture local variables in Rust
(Chapter~\ref{chap:libinger}).

\paragraph{Compose naturally with existing concurrency abstractions}
Both abstractions are usable in multithreaded contexts.  In fact, one can even take a
paused preemptible function that was executing one one kernel thread and resume it
on a different one (Section~\ref{sec:libinger:tcbs}), a property that allows
schedulers to treat preemptible functions like any other task.  Preemptible functions
can be used to construct preemptible futures (Section~\ref{sec:libturquoise:prefuts})
and even mutexes with \texttt{await}-style call with current continuation semantics
(Section~\ref{sec:libinger:locks}).

\paragraph{Asynchronous cancellation of threads}
It has long proven difficult to cancel running threads, both at the operating system
level (Chapter~\ref{chap:functions}) and at the language level
(Chapter~\ref{chap:strobelight}).  We
discover that we can leverage the memory isolation provided by selective relinking to
enable asynchronous cancellation of POSIX threads, a feature that is almost unusable
as shipped in the Unix operating system and its clones
(Chapter~\ref{sec:safety:acsafe}).  Although resource leaks remain a problem
(Section~\ref{sec:safety:thread}), it may be possible to address them for languages
conforming to RAII (Chapter~\ref{chap:ingerc}).

\paragraph{Preemptive thread libraries in userland}
By modifying the thread pool from a Rust futures executor to use transparently wrap
tasks in preemptible futures, we have created arguably the first general-purpose
preemptive thread library implemented entirely in userland.  Details are in
Chapter~\ref{chap:libturquoise}.


\section{Applications and future work}
\label{sec:thatsawrap:applications}

\solb{Mention case studies built on top (incl. the safety ones) and other possibilities (incl. finishing them)}

\solb{Other libgotcha uses:\@ aspect-oriented programming, multiple library versions}

\solb{Other libinger use:\@ resource limits besides wall-clock time}

\solb{Redesign global variable interception to leverage symbol sizes instead of disassembler and heuristics}

\solb{Port \textit{libgotcha} to drow}

\solb{Make \textit{libtlsblock} robust and incorporate it into the system}

\solb{Logic to avoid signal conflicts}

\solb{Remove signal scaling limit}

\solb{Smarter time quanta and measurement study/profiler component}

\solb{Add option to insulate against preemptible function exceptions}

\solb{Systematic replacements to prevent circumventing isolation}

\solb{Systematic replacements to hide library function semantics changes}

\solb{Make \textit{\_dl\_signal\_exception()} workaround robust and incorporate it into the system}

\solb{Complete implementation of \textit{ingerc} and integrate the runtime components into \textit{libinger}}

\solb{Port \textit{libturquoise} to modern Tokio, eliminating the compatibility glue code and properly supporting TLSes, as I've ported the main system to modern Rust and glibc}

\solb{Build a microservices platform on top of \textit{libinger}}

\solb{
\paragraph{Automatic selection and variation of timer frequency}
For simplicity, the current \textit{libinger} implementation subscribes to timer
signals spaced a globally constant interval apart throughout the entire duration of
each preemptible function.  To improve efficiency while preserving preemption
granularity, I plan to dynamically determine this interval based on the requested
timeout.  For long-running functions, this will include delaying the first of these
signals until shortly before the timeout would expire.  Maintaining accuracy across
multiple CPUs will probably require building in a calibration routine to infer
configuration parameters.
}

\solb{
\paragraph{Achieve even finer--grained preemption}
The \textit{Shinjuku} authors included IPI microbenchmarks that suggest it should be
possible for us to achieve interrupt latencies and spacing within a small constant
factor of theirs.  I could attempt to achieve this by reusing some of their
optimizations to POSIX contexts and adding a specialized timer signal delivery
mechanism to the kernel to reduce the number of ISR instructions at the expense of
generality.
}

\solb{
\paragraph{Implement ``\textit{libingerOS}'' container framework}
Generalizing the serverless platform case study, it should be possible to generate a
utility that takes two or more position-independent executables and combines them
into a single process whose thread(s) are timeshared between the ``programs'' using
preemptible functions.  Obviously, this would only provide memory isolation for
programs implemented in memory-safe languages.  This would be implemented on top of
\textit{libinger} as a sample application.
}

\solb{Issues to report and/or patch upstream... \texttt{\_Unwind\_Resume()}, \texttt{\_\_libc\_dlopen()}, libunwind, GDB namespace debug symbols}


\section{Technical challenges}
\label{sec:thatsawrap:challenges}

\solb{Second reason \textit{libgotcha} is called that}

\solb{Cross-module symbol references Section~\ref{sec:libgotcha:crossref} 3.3.1}

\solb{\texttt{NODELETE} shared libraries Section~\ref{sec:gotchainit} 3.4}

\solb{Need to write \texttt{procedure\_linkage\_override()} in assembly and design data structures and thread locals to be friendly to use Sections~\ref{sec:libgotcha:functions} and \ref{sec:libgotcha:tls} 3.5.1 3.7.2}

\solb{Clobbering Rust fat pointers in \texttt{procedure\_linkage\_override()}}

\solb{Generating executable PLOT stubs Section~\ref{sec:libgotcha:functions} 3.5.1}

\solb{Pointer equality rewrite and subtly that pointers can be the same within a certain context without actually being resolved Section~\ref{sec:libgotcha:functions} 3.5.1}

\solb{Rewriting relocations for lazily-resolved function calls Section~\ref{sec:libgotcha:functions} 3.5.1}

\solb{GNU indirect symbols caused mysterious crashes Section~\ref{sec:libgotcha:functions} 3.5.1}

\solb{Intercepting global variable accesses (segfault handler tricky to debug, assembler, heuristics) Section~\ref{sec:libgotcha:globals} 3.5.2}

\solb{Dealing with \texttt{\_\_rtld\_global} monkey patching and \texttt{\_dl\_open()} use of return address Section~\ref{sec:libgotcha:unintfuns} 3.6.1}

\solb{Compiler optimizations and alias symbols to get interposition ``recursive'' calls to resolve correctly Section~\ref{sec:libgotcha:interpose} 3.7.1}

\solb{\texttt{\_Unwind\_RaiseException()} for namespaces Section~\ref{sec:libgotcha:interpose} 3.7.1}

\solb{Need paused preemptible functions to be able to travel between threads Section~\ref{sec:libgotcha:tls} 3.7.2}

\solb{Failing to raise our preemption signal in the \textit{libinger} callback Section~\ref{sec:libgotcha:tls} 3.7.2}

\solb{TLS deferred reinitialization laziness scheme Section~\ref{sec:libgotcha:tls} 3.7.2}

\solb{Working around glibc 2.30's ban on \texttt{dlopen()}'ing executables Section~\ref{sec:libgotcha:portability} 3.8.1}

\solb{Growing \texttt{\_rtld\_global\_ro} region Section~\ref{sec:libgotcha:portability} 3.8.1}

\solb{Exhausting the static TLS space Section~\ref{sec:libgotcha:scalability} 3.8.2}

\solb{\texttt{COPY} relocations Section~\ref{sec:limits} 3.8.3}

\solb{Getting \textit{libas-safe} and the POSIX test preload library to initialize as late as possible before \texttt{main()} Sections~\ref{sec:safety:assafe} and \ref{sec:libinger:compatibility}}

\solb{Critical TCB fields including self-referential ones Section~\ref{sec:libinger:tcbs} 5.3}

\solb{Self-referential field in POSIX contexts}

\solb{Bookkeeping and double frees with POSIX contexts Section~\ref{sec:libinger:boilerplate} 5.4.1}

\solb{Portable thread-directed signals using a pool and convergence Section~\ref{sec:libinger:signals} 5.6}

\solb{Restoring POSIX contexts obtained from signal handlers Section~\ref{sec:libinger:resuming} 5.7.1}

\solb{Asynchronous exception handling Section~\ref{sec:ingerc:async} 6.4}


\section{Lessons for systems builders}
\label{sec:thatsawrap:lessons}

\solb{
Resuming is a useful feature that is cheap, but introduces concurrency.
Cannot get CPU time isolation without memory isolation.
Design abstractions modularly and with an eye to simple use cases (e.g., \textit{libgotcha} as a separate
runtime with a very small control API, things listed in the note on design).
Treat debuggability as a first-order concern (e.g., permit disabling features that interfere at
runtime, test and maintain support for running under debugging and diagnostic tools).
}

\solb{Debugging tools in 3.8 libgotcha limitations and 4.1.1 handler example program and 3.6.1 monkey patching warning and 5.4.1 plus debug build runtime checks}
