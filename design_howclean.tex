\paragraph{How do we clean up a terminated microservice?}
We now discuss our mechanism for aborting and cleaning up after a microservice
exceeds its runtime budget.  POSIX signal handlers receive as an argument a pointer to their
\textit{context}, a snapshot of the process's PCB (process control block) at the
moment before it received the signal.  When the handler returns, the system will
transfer control back to the point described by the context, so a na√Øve way for our
worker processes to regain control would be to reset its GPRs (general-purpose
registers) to values recorded just before the worker's tight scheduling loop.
This approach, however, would not release the microservice's state or memory
allocations back to the worker.

One of the few heavyweight components of the Rust runtime is panic handling,
reminiscent of C++'s exception handling.  The compiler inserts landing pads into each
function that call the destructors for the variables in its stack frame:\@ if the
program ever panics, the standard library uses these to unwind the stack.  We co-opt
this functionality by having the \texttt{SIGALRM} handler set its context to raise an
explicit panic in a fake stack frame just above the real top of the stack.

Section~\ref{sec:future} discusses the limitations and security ramifications of
this approach.

