\section{Thread library: \textit{libturquoise}}
\label{sec:libturquoise}

\textit{Shinjuku} observes that ``there have been several efforts to implement
efficient, user-space thread libraries.  They all focus on cooperative
scheduling''~\cite{Kaffes:nsdi2019}.  We agree that such libraries are rare, and
attribute this to a lack of natural abstractions to support them.  (Though
\textit{RT} from Section~\ref{sec:related} could be a counterexample, its lack of
nonreentrancy support makes it far from general purpose.)

Although the preemptible function is a fundamentally synchronous abstraction, its
simplicity makes it readily composable, and indeed, well-suited to implementing
preemptive threading.  As a proof of concept, we have created a
preemptively-scheduled userland thread library, \textit{libturquoise}\footnote{so
called because it implements ``green threading with a twist''}, by modifying the
\textit{tokio-threadpool}~\cite{www-tokio-threadpool} work-stealing scheduler from
the Rust futures ecosystem.

To migrate the thread pool workers to preemptive scheduling, we made them poll each
task future from within a preemptible function.  We did this in
just 120 new lines of Rust, 50 of them added to version 0.1.16 of the thread library
and
70 spent augmenting \textit{libinger}'s Rust API with a reusable \textbf{preemptible
futures} adapter.

Currently, \textit{libturquoise} assigns each future it launches or resumes the same
fixed time budget, although this design could be extended to support
multiple job priorities.  When a task times out, the scheduler pops it from its
worker thread's job queue and pushes it to the incoming queue,
offering it to any available worker for rescheduling after all other waiting jobs
have had a turn.


\subsection{Preemptible futures}

For seamless interoperation between preemptible functions and the futures ecosystem,
we built a preemptible future adapter that wraps the \textit{libinger} API.  This
can be used to pass preemptible functions into a platform designed to process
futures.

Because
of languages' differing futures, this integration is not portable like the core API.
Fortunately, its implementation is a straightforward application of
\texttt{pause()} to propagate cooperative yields across the preemptive function
boundary:\@ we present the general construction of the preemptible future
type and an algorithm for polling one in Listing~\ref{lst:future}.

\begin{figure}
\begin{lstlisting}[label=lst:future,caption=Futures adapter type (pseudocode)]
function PreemptibleFuture(Future fut,
                              Num timeout):
  function adapt():
    while poll(fut) == NotReady:
      pause()
  fut.linger = launch(adapt, 0)
  fut.timeout = timeout
  return fut

function poll(PreemptibleFuture fut):
  resume(fut.linger, fut.timeout);
  if has_finished(fut.linger):
    return Ready
  else
    if called_pause(fut.linger):
      notify_unblocked(fut.subscribers)
    return NotReady
\end{lstlisting}
\end{figure}
