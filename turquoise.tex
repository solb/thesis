\section{Thread library: \textit{libturquoise}}
\label{sec:libturquoise}

\textit{Shinjuku} observes that ``there have been several efforts to implement
efficient, user-space thread libraries.  They all focus on cooperative
scheduling''~\cite{Kaffes:nsdi2019}.  We agree that such libraries are rare, and
attribute this to a lack of natural abstractions to support them.  (Though
\textit{RT} from Section~\ref{sec:related} is could be a counterpoint, its lack of
nonreentrancy support makes it far from general purpose.)

While the preemptible function is a fundamentally synchronous abstraction, its
simplicity makes it readily composable, and indeed, well-suited to implementing
preemptive threading.  To demonstrate this, we have created a
proof-of-concept library, \textit{libturquoise}\footnote{so called because it
implements ``green threading with a twist''}, by modifying the
\textit{tokio-threadpool}~\cite{www-tokio-threadpool} work-stealing scheduler from
the Rust ecosystem to wrap each future in a preemptible function.  We did this by
adding just 120 lines of code, 50 of them to version 0.1.16 of the thread library and
70 extending \textit{libinger}'s Rust API with a reusable \textbf{preemptible
futures} adapter.

Currently, \textit{libturquoise} assigns each future it launches or resumes the same
fixed time budget, although this design could be extended to support
multiple job priorities.  Whenever a task times out, the scheduler pops it from its
worker thread's job queue and pushes it onto the incoming work queue, thereby
offering it to any available worker for rescheduling after all other waiting jobs
have had a turn.


\subsection{Preemptible futures}

For seamless interoperation between preemptible functions and the futures ecosystem,
we built a preemptible future adapter that wraps the \textit{libinger} API.  Because
of languages' differing futures, this integration is not portable like the core API.
Fortunately, its implementation is a straightforward application of
\texttt{pause()}:\@ we present the general construction of the preemptible future
type and an algorithm for polling one in Listing~\ref{lst:future}.

\begin{figure}
\begin{lstlisting}[label=lst:future,caption=Futures adapter type (pseudocode)]
function wrap(Future fut, Num timeout):
  function adapt():
    while poll(fut) == NotReady:
      pause()
  fut.linger = launch(adapt, 0)
  fut.timeout = timeout
  return fut

function poll(PreemptibleFuture fut):
  resume(fut.linger, fut.timeout);
  if has_finished(fut.linger):
    return Ready
  else
    if called_pause(fut.linger):
      notify_unblocked(fut.subscribers)
    return NotReady
\end{lstlisting}
\end{figure}
