\chapter{Function calls with timeouts}
\label{chap:functions}

\ifdefined\chapquotes
\begin{chapquote}{Isaac Asimov, \textit{The Gods Themselves}}
`Does everyone just believe what he wants to?' \\
`As long as possible.  Sometimes longer.'
\end{chapquote}
\fi

\begin{figure}
\begin{center}
\includegraphics[width=0.65\columnwidth]{functions/figs/progsupport}
\end{center}
\caption{Taxonomy of support for library code.  It is difficult to determine whether
a library is fully reentrant, so in practice we always
apply one of the two mitigations.  Library copying is used by default, but deferred
preemption is needed to preserve the semantics of \texttt{malloc()} and users of
uncopyable resources such as file descriptors or network adapters.}
\label{fig:progsupport}
\end{figure}

\begin{swallowsections}
\begin{swallowfigures}
\input[functions]{intro}
\end{swallowfigures}
\end{swallowsections}


\input[functions]{related}


\section{Preemptible functions: \textit{libinger}}

We observe that today's concurrency abstractions offer either synchronous invocation
or preemptive scheduling, but not both.  On one hand we have futures, which are now
synchronous\footnote{Code interfacing with futures via the ``async/await''
continuation passing style is now prolific.} but purely cooperative.  On the other
are kernel threads, which are preemptive but asynchronous.  We bridge this gap by
introducing a novel abstraction that provides synchrony \textit{and} preemption for
unmanaged languages.

Doing so requires confronting the very nonreentrancy problems that have long doomed
attempts to support asynchronous cancellation outside of purely functional contexts.
This turns out to be a slightly harder problem than safely supporting concurrency, so
in addition to cancellation, we get the ability to externally pause for free.

\begin{swallowsections}
\input[functions]{inger_inger}
\end{swallowsections}


\subsection{Design principles}

Although we are introducing a new concurrency abstraction, we have striven to keep
the interface simple and understandable.  The following design principles have guided
this effort:
\begin{itemize}
\item \textbf{We do not assume that users need asynchrony.}  Hence, preemptible
	functions \textit{run on the same kernel thread as their caller}.  This is
	good for performance (especially invocation latency), but it is also
	important to be aware of; for instance, it means that a preemptible function
	will deadlock if it attempts to acquire a lock held by its caller, or vice
	versa.  Of course, some users may need asynchrony.  The preemptible function
	abstraction composes naturally with both threads and futures
	(Chapter~\ref{chap:libturquoise}), so there is no need to reinvent the wheel.
\item \textbf{We assume that simply calling a preemptible function is the common use
	case.}  As such, the \texttt{launch()} wrapper both constructs and invokes
	the preemptible function rather than asking the user to first employ a
	separate constructor.  Of course, some users may want to separate these two
	operations.  This is as easy as passing the sentinel \texttt{0} as the
	timeout, then using \texttt{resume()} to start executing it.
\item \textbf{We favor a simple, language-agnostic interface.}  The fact that our
	interface centers on a higher-order function in the style of the
	\texttt{pthread\_create()} and \texttt{spawn()} wrapper functions means that
	using preemptible functions looks similar regardless of the programming
	language.  Currently, \textit{libinger} provides bindings for both C and
	Rust.  If and when we add bindings for other languages, we expect them to
	have the same feel; in the meantime, other languages can use preemptible
	functions (unsafely) through their C
	foreign-function interfaces.  We considered adhering to the futures interface
	instead, but decided against it because each language has its own
	incompatible variant thereof.  The relative ease of building a futures
	adapter type (Chapter~\ref{chap:libturquoise}) affirms our decision.
\item \textbf{We keep argument and return value passing simple yet extensible.}
	Because Rust supports closures, the Rust version of \texttt{launch()} accepts
	only nullary functions:\@ those seeking to pass arguments should just capture
	them from the environment.  C supports neither closures nor generics, so the
	C version of \texttt{launch()} accepts a single \texttt{void *} argument that
	can serve as an in/out parameter.  It occupies the last position in the
	parameter list to permit (possible) eventual support for variable argument
	lists.
\item \textbf{We choose defaults to favor flexibility and performance.}  When a
	preemptible function times out, \textit{libinger} assumes the caller might
	later want to resume it from where it left off.  As such, both
	\texttt{launch()} and \texttt{resume()} pause in this situation; this incurs
	some memory and time overhead to provide a separate execution stack and
	package the continuation object, but exhibits much lower latency than
	asynchronous cancellation.  If the program does require cancellation, we
	provide ways to explicitly request it (Chapter~\ref{chap:libinger}).
\item \textbf{In addition to preemption, we offer the option to yield.} This feature
	enables the construction of higher-level synchronization constructs tailored
	to preemptible functions (Chapter~\ref{chap:libinger}).  It also allows
	preemptible functions to coexist with cooperatively-scheduled tasks
	such as futures (Chapter~\ref{chap:libturquoise}).
\end{itemize}


\section{The preemptible functions ecosystem}

In divorcing preemption from asynchronous invocation, preemptible functions also
disentangle it from the idea of parallelism.  Indeed, \textit{libinger} does not
provide a task scheduler because the only decision it makes is whether to pause the
currently executing code.  Whenever it opts to do so, it returns control to the
preemptible function's caller, so there is no scheduling decision to make.

This design allows client code to pick and choose the level of runtime support it
needs.  If it only invokes preemptible functions synchronously and makes all
scheduling decisions itself, it can link directly against \textit{libinger} and use
the interface presented in Section~\ref{sec:libinger}.  If it prefers to delegate
scheduling to a runtime, we also provide \textit{libturquoise}, a preemptive futures
executor providing an event loop and optional thread pool
(Chapter~\ref{chap:libturquoise}).

Figure~\ref{fig:architecture} shows the dependency relationship between
\textit{libinger} and \textit{libturquoise}, in the context of the other software
components developed for this thesis.  Notably, both libraries support nonreentrancy
by depending on another library called \textit{libgotcha}, which provides a novel
abstraction of its own for enforcing isolation boundaries.  The \textit{libinger}
library is implemented in approximately 2,500 lines of Rust; \textit{libgotcha}
comprises another 3,000 lines of C, Rust, and x86-64 assembly.

\begin{figure}
\begin{center}
\includegraphics[width=\columnwidth]{functions/figs/architecture}
\end{center}
\caption{Preemptible functions software stack.  \textnormal{Hexagonal boxes show
the required runtime environment.  Rectangular boxes represent components
implementing the preemptible functions abstraction.  Ovals represent components built
on top of these.  A preemptible function's body (i.e., \texttt{func}) may be defined
directly in
your program, or in some other loaded library.}}
\label{fig:architecture}
\end{figure}


\subsection{Automatic handling of shared state: \textit{libgotcha}}
\label{sec:libinger:concurrency}

\begin{swallowsubsections}
\input[functions]{inger_gotcha}
\end{swallowsubsections}

Note that preemptible functions are still a concurrency abstraction, and our
automatic handling of shared state internal to dependencies does not exempt the
author of a preemptible function from writing safe concurrent code.
