#!/usr/bin/python3

from argparse import ArgumentParser, RawDescriptionHelpFormatter
from itertools import cycle
from matplotlib import pyplot
from os.path import basename
from sys import argv, stdin


def autolabel(rects, ax, labels):
	""" Originally from: http://composition.al/blog/2015/11/29/a-better-way-to-add-labels-to-bar-charts-with-matplotlib/ """
	for i, rect in enumerate(rects):
		ax.text(rect.get_x() + rect.get_width()/2., 0,
				'	 ' + labels[i], ha='center', va='bottom', rotation=90)


def main():
	linegraph = basename(argv[0]) == 'linegraph'

	url_of_sandwich = 'file:///usr/share/doc/python-matplotlib-doc/html/api/patches_api.html#matplotlib.patches.Patch.set_aa'
	if linegraph:
		url_of_sandwich = 'file:///usr/share/doc/python-matplotlib-doc/html/api/lines_api.html#matplotlib.lines.Line2D.set_aa'

	parser = ArgumentParser(epilog = 'Each line beginning with \'--\' invokes a function listed at:\n\t' + url_of_sandwich + '\non each series, cycling through the rest of the comma-separated line for the arguments.', formatter_class = RawDescriptionHelpFormatter)
	parser.add_argument('-e', action = 'store_true', help = 'Draw error bars using alternate columns')
	parser.add_argument('-l', action = 'store_true', help = 'Use log scale')
	if linegraph:
		parser.add_argument('-x', type = float, default = 0.0, help = 'Custom x max')
	parser.add_argument('-y', type = float, default = 0.0, help = 'Custom y max')
	parser.add_argument('-v', action = 'store_true', help = 'Position legend to the right of the graph area')
	parser.add_argument('-u', type = float, default = 1.0, help = 'x position for further customizing -v')
	parser.add_argument('-w', type = float, default = 0.5, help = 'y position for further customizing -v')
	if linegraph:
		parser.add_argument('-o', action = 'store_true', help = 'Use *horizontal* log scale')
		parser.add_argument('-s', action = 'store_true', help = 'Draw a scatterplot instead of a linegraph')
	else:
		parser.add_argument('-i', type = int, default = 1, help = 'Visible label increment (for skipping some)')
		parser.add_argument('-r', type = float, default = 0.0, help = 'Label rotation')
		parser.add_argument('-p', type = float, default = 0.05, help = 'Padding before the first bar and after the last bar')
		parser.add_argument('-s', action = 'store_true', help = 'Whether to split the y-axis to support very tall bars. Splits at the value of \'-y\'.')
	parser.add_argument('dest', help = 'Destination filename')
	args = parser.parse_args()
	errorbars = args.e
	logscale = args.l
	ymax = args.y
	vertlegend = args.v
	vertlx = args.u
	vertly = args.w
	xmax = 0
	if linegraph:
		xmax = args.x
		hlogscale = args.o
		scatter = args.s
	else:
		increment = args.i
		rotation = args.r
		padding = args.p
		split = args.s
		assert not split or (split and ymax), '\'-s\' requires \'-y\''

	title = input().strip().split(',')
	labels = input().strip().split(',')
	xlabel = labels[0]
	ylabel = title[1] if len(title) > 1 else ''
	slabels = [labels[col] for col in range(1, len(labels), 2)] if errorbars else labels[1:]
	props = {}
	data = []
	for line in stdin:
		line = line.strip().split(',')
		if line[0][:2] == '--':
			props[line[0][2:]] = cycle(line[1:])
			pass
		else:
			data.append(line)
	if linegraph:
		indeps = [float(each[0]) for each in data]
	else:
		indeps = [data[each][0] if not each % increment else '' for each in range(len(data))]
	series = [[float(col) for col in each[1:]] for each in data]
	errors = [[float(each[index]) for index in range(1, len(each), 2)] for each in series]
	if errorbars:
		series = [[float(each[col]) for col in range(0, len(each), 2)] for each in series]

	rendered_series = []
	if linegraph:
		pyplot.title(title[0])
		pyplot.xlabel(xlabel)
		pyplot.ylabel(ylabel)

		for index in range(len(series[0])):
			rendered_series.append(pyplot.errorbar(indeps, [row[index] for row in series], yerr = [row[index] for row in errors] if errorbars else None, marker = '.', linestyle = '' if scatter else '-', capsize = 2)[0])
			if logscale:
				pyplot.yscale('log')
			if hlogscale:
				pyplot.xscale('log')
	else:
		fig, subfigs = pyplot.subplots(2 if split else 1, 1, sharex=True, figsize=(4, 6))

		if split:
			# Extract two subfigures.
			ax1, ax2 = subfigs
			# The axes on which to put the x-axis and DEADLOCK labels.
			label_ax = ax2

			# Configure custom coordinates for the y-axis label.
			ax1.yaxis.set_label_coords(-0.13, -0.1)
			# Set axis visibility.
			ax1.spines['bottom'].set_visible(False)
			ax1.tick_params(axis='x', which='both', bottom=False)
			ax2.spines['top'].set_visible(False)
			# Set lower axes y limits.
			ax2.set_ylim(0, ymax)
			# Calculate and set upper axes y limits. Figure out the maximum and
			# minimum values that will fall in the upper axes.
			upper_pts = []
			for yerrs, ys in zip(errors, series):
				for yerr, y in zip(yerrs, ys):
					if y > ymax:
						yerr = yerr if errorbars else 0
						upper_pts.extend([y - yerr, y + yerr])
			upper_max = max(upper_pts)
			upper_min = min(upper_pts)
			upper_padding = (upper_max - upper_min) * 0.05
			ax1.set_ylim(upper_min - upper_padding, upper_max + upper_padding)

			# Draw slash markers on y axis.
			d = 0.015
			kwargs = dict(transform=ax1.transAxes, color='k', clip_on=False)
			ax1.plot((-d, +d), (-d, +d), **kwargs)
			ax1.plot((1 - d, 1 + d), (-d, +d), **kwargs)
			kwargs.update(transform=ax2.transAxes)
			ax2.plot((-d, +d), (1 - d, 1 + d), **kwargs)
			ax2.plot((1 - d, 1 + d), (1 - d, 1 + d), **kwargs)
		else:
			# Extract only a single subfigure.
			ax1 = subfigs
			# The axes on which to put the x-axis and DEADLOCK labels.
			label_ax = ax1

		# Set figure title and axes labels.
		fig.suptitle(title[0])
		ax1.set_ylabel(ylabel)
		label_ax.set_xlabel(xlabel)

		# This code assumes that there may be multiple bar clusters. Define a
		# bar series to be the same bar across all of the bar
		# clusters. Therefore, a cluster is a set of one bar from each bar
		# series. We plot each bar series separately.

		idx = slabels.index('pthread_create()') + 1
		slabels.insert(idx, 'pthread_create()+async')
		bar_labels = []
		for i in range(len(series)):
			series[i].insert(idx, 0)
			errors[i].insert(idx, 0)
			bar_labels_new = [''] * len(series[0])
			bar_labels_new[idx] = 'DEADLOCK'
			bar_labels.extend(bar_labels_new)

		# The width of a bar.
		width = 0.9 / len(series[0])
		# Baseline xs. Each element anchors a cluster.
		xs = [x + width / 2. + padding for x in range(len(series))]
		# A list of all xticks, where each element is a tuple of (x loc, label).
		xticks = []
		lower_rects = []
		# Loop over each bar series.
		for br in range(len(series[0])):
			# For this bar series, the x locs are the width of a bar over from
			# the x locs of the previous bar series. For the first bar series,
			# use the baseline xs.
			if br > 0:
				xs = [x + width for x in xs]
			# Extract from each cluster the appropriate bar y value and error.
			ys = [cluster[br] for cluster in series]
			yerrs = [e[br] for e in errors]
			# Add the xticks at the same x locs as the bars.
			xticks.extend([(x, slabels[br]) for x in xs])
			# Plot this bar series.
			lower_rects_new = ax1.bar(xs, ys, width=width, log=logscale,
									  yerr=yerrs if errorbars else None)
			if split:
				lower_rects_new = ax2.bar(xs, ys, width=width, log=logscale,
										  yerr=yerrs if errorbars else None)
			lower_rects.extend(lower_rects_new)

		# The xticks are out of order, so sort them based on their x locs.
		xticks = sorted(xticks, key=lambda x: x[0])
		# Split the x locs and labels into separate arrays.
		xticks_xs, xticks_labels = zip(*xticks)
		# Plot the xticks all at once, possible with rotation.
		pyplot.xticks(xticks_xs, xticks_labels, rotation=rotation,
					  horizontalalignment='left' if rotation else 'center')
		# Compute the right boundary of the plot. To understand the calculation,
		# see where xs is originally defined.
		xmax = xticks_xs[-1] + width / 2. + padding

		# Apply DEADLOCK labels.
		assert len(lower_rects) == len(bar_labels), \
			'Mismatch between number of bars and number of bar labels.'
		autolabel(lower_rects, label_ax, bar_labels)

	if props and not linegraph:
		# I do not understand what the props are used for, so I did not
		# implement support for them.
		raise Exception('props not supported for bar graphs')
	for rs in rendered_series:
		for prop in props:
			getattr(rs, prop)(next(props[prop]))

	if xmax:
		pyplot.xlim(0, xmax)
	else:
		pyplot.xlim(0)

	if not linegraph and logscale:
		pyplot.ylim(10 ** 0, ymax)
	else:
		pyplot.ylim(0)

	if linegraph:
		if len(slabels) == 1:
			pyplot.ylabel(*slabels)
		elif vertlegend:
			pyplot.legend(slabels, loc = 'center left', bbox_to_anchor = (vertlx, vertly))
		else:
			pyplot.legend(slabels)

	pyplot.savefig(args.dest, bbox_inches = 'tight')


if __name__ == '__main__':
	main()
