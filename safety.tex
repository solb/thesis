\chapter{Rethinking POSIX safety: \\ \textit{libas-safe} and \textit{libac-safe}}
\label{chap:safety}

\ifdefined\chapquotes
\vspace{-1in}
\begin{chapquote}[1.75in]{Douglas Adams, \textit{The Hitchhiker's Guide to the Galaxy}}
`Ah!  This is obviously some strange use of the word \textit{safe} \\
that I wasn't previously aware of.'
\end{chapquote}
\fi

\solb{Explain what POSIX means by the term asynchronous (and audit how we've used it before now)}

The reader will probably not be surprised to learn that the POSIX specification
guarantees that most C library functions are thread safe; that is, assuming they are
not explicitly instructed to use the same resources, it is safe to call them from
concurrent kernel threads within the same process.  However, POSIX also defines two
less familiar types of safety that become relevant when an individual thread does
something other than execute a single task to synchronous completion or failure:

\paragraph{Async-signal safety.}
Async-signal-safe functions are those that can be safely called from a signal handler
that has interrupted a non-async-signal-safe function (or conversely, can be safely
interrupted by a signal handler that calls non-async-signal-safe functions).

\begin{sloppypar}
\paragraph{Async-cancel safety.}
Async-cancel-safe functions are those that can be called by
asynchronously-cancellable threads, which we first saw in
Chapter~\ref{chap:functions}.  One can ostensibly cancel such threads at any point in
their execution; however, POSIX marks almost no functions as async-cancel safe, so in
practice the feature is only useful for threads executing a compute-bound loop with
no I/O or other reliance on the OS.
\\
\end{sloppypar}

Along with thread safety, these two classes of safety exist because of nonreentrant
interfaces; that is, functions whose signatures do not expose all the shared state
they use.  To understand the need for these two classes of safety, it is helpful to
consider how one might implement a thread-safe function.  For the sake of this
discussion, consider the nonreentrant pseudorandom-number generator \texttt{rand()},
which takes no arguments but returns a random number.  Clearly, the function needs
some kind of entropy pool to produce such a number, and since the caller doesn't
provide it with any information, the \texttt{rand()} function must manage the entropy
pool itself.  This implies the function has internal state that is implicitly shared
among all its callers.  The simplest way to implement an entropy pool is to feed some
seed value to a one-way function, and use the resulting pseudorandom number as the
new seed value.  Thus, the entropy pool needs only to store the current seed value.

It's easy to see that a trivial implementation of \texttt{rand()} using the
aforementioned approach is subject to data races when used by multiple threads:\@
the function must update the entropy pool on each invocation, and concurrent accesses
may interleave.  Establishing thread safety is as easy as using a thread-local
variable to maintain a separate entropy pool for each thread of execution, thereby
eliminating the shared state.  Unfortunately, this mitigation is neither applicable
to async-signal safety nor to async-cancellation safety:  In the former case, there
is no analogue of thread-local variables capable of retargeting data accesses
depending on whether a signal handler is running.  In the latter case, a function
that mutates state that must be shared \textit{between} threads is likely to corrupt
such state if cancelled in the middle of writing to it, even if the function employs
concurrency control to prevent data races.  (One such example is the
\texttt{malloc()} family of dynamic memory allocation functions, which carve their
allocations out of a fixed heap.  Although they take a lock on a portion of the heap
while reserving each allocation, cancelling them during this critical section will
result in the lock never being released and the affected portion of the heap becoming
unusable.)

In this chapter, we explore how \textit{libgotcha} fills a usability gap in Unix's
userland and allows one to establish either kind of async safety in places where it
would not otherwise exist.  In doing so, we present ordinarily unsound sample
programs that can be automatically fixed through the use of \textit{libgotcha} and
discuss practical applications to real-world systems.  And through its presentation
of two simple control libraries, this chapter also serves as a straightforward
example of how to use \textit{libgotcha}.  The insight from this chapter, both on our
runtime and on POSIX safety itself, will be useful when we later explain the workings
of \textit{libinger}, a more complicated control library.


\section{Establishing async-signal safety:\@ \textit{libas-safe}}

Our approach to artificially establishing async-signal safety is to repurpose
selective relinking to isolate signal handlers from the rest of the program.  We do
so by running the entire program, with the exception of uninterruptible library
functions (Section~\ref{sec:libgotcha:unint}) and custom signal handlers, in a
newly-allocated libset.  Whenever a signal with a handler arrives, we switch to the
starting libset before executing it, then switch back before returning to the rest of
the program.

As a demonstration of our technique, we have implemented \textit{libas-safe}, a tiny
runtime comprising 127 lines of C code that automatically fixes programs whose signal
handlers call functions that are not async-signal safe.  To use it you, either
preload it at load time or link your buggy application directly against it at build
time.  Note that it only fixes bugs truly arising from async-signal safety:\@ it will
neutralize most resulting undefined behavior, but it will not address logic errors in
the program itself (e.g., a handler's attempt to traverse a corrupt or otherwise
inconsistent data structure).  Furthermore, it is a proof of concept and there are
cases it does not bother to handle.  Most notably, it does not isolate handlers for
different signals from one another, so programs that handle multiple signals must
ensure the other(s) are masked while any handler that calls unsafe functions is
running.\footnote{Technically, this stipulation is slightly stronger than necessary,
both in terms of scope (all other handlers) and enforcement mechanism (signal masks).
The exact requirement is that no two handlers that both use unsafe functions can be
allowed to interleave their execution.}

To avoid affecting the initialization of the C runtime, we perform our own setup as
late as possible by replacing libc's \texttt{\_\_libc\_start\_main()} function,
responsible for calling the program's \texttt{main()} function.  Because
\textit{libas-safe} is an internal control library
(Section~\ref{sec:libgotcha:control}), doing so is as simple as defining a
non-static function with that name and \textit{libgotcha} automatically considers it
a forced interposition (Section~\ref{sec:libgotcha:interpose}).  Our replacement
wraps the libc implementation, but allocates and switches to a new libset just before
jumping to \texttt{main()}.  It also registers an uninterruptible return callback
(Section~\ref{sec:libgotcha:callbacks}) and checks an environment variable to
determine wither to run in verbose mode and log its actions.

The bulk of \textit{libas-safe}'s code merely wraps the \texttt{sigaction()} function
for installing signal handlers.  We show the replacement for this function in
Listing~\ref{lst:assafe_sigaction}, slightly simplified for
brevity.\footnote{Compared to our actual prototype, the version in these source
listings runs internal \textit{libas-safe} wrapper code with the same signal mask that
the caller requested for \textit{its} signal handler.  This can lead to conflicts
between \textit{libas-safe}'s own handlers for different signals, or even between its
handler for one signal and that handler itself if the caller installs the handler
with the \texttt{SA\_NODEFER} flag.  Unrelatedly, the depicted version of the
\texttt{sigaction()} wrapper does not roll back its changes if the underlying
implementation reports an error.}  If used to set a signal's disposition to default
(\texttt{SIG\_DFL}) or ignored (\texttt{SIG\_IGN}) or query the configuration of a
signal without a custom handler, neither of the conditionals is taken and it defers
to the underlying \texttt{sigaction()} (in this case, \textit{libgotcha}'s own
wrapper).  Otherwise, if the caller is installing a custom handler, it saves a
pointer to the provided handler into the persistent \texttt{handlers} array and
installs its own \texttt{stub()} function as the handler instead; this function
expects three arguments rather than System V's traditional one, so it sets the
\texttt{SA\_SIGINFO} flag~\cite{sigaction-manpage}.  If the caller is querying the
configuration of a custom handler, it looks up the handler the program had requested
and furnishes that instead of a pointer to \texttt{stub()}.

\begin{figure}
\begin{lstlisting}[label=lst:assafe_sigaction,caption=\textit{libas-safe}'s \texttt{sigaction()} replacement]
typedef void (*handler_t)(int, siginfo_t *, void *);

static struct handler_t *handlers;
static bool verbose;

int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact) {
	handler_t oldact = handlers[signum];
	struct sigaction sa;
	if(act && act->sa_sigaction != SIG_DFL && act->sa_sigaction != SIG_IGN) {
		// We have been asked to install a custom signal handler.
		if(verbose) fprintf(
			stderr,
			"LIBAS-SAFE: sigaction() installing signal %d handler\n",
			signum);

		memcpy(&sa, act, sizeof sa);
		handlers[signum] = sa.sa_sigaction;
		sa.sa_sigaction = stub;
		sa.sa_flags |= SA_SIGINFO;
		act = &sa;
	}

	// Call the real sigaction().
	int status = libgotcha_sigaction(signum, act, oldact);
	if(oldact && oldact->sa_sigaction == stub)
		// We have been asked to provide the previous configuration.
		// Fib that we installed the provided handler, not our wrapper.
		oldact->sa_sigaction = oldact;
	return status;
}
\end{lstlisting}
\end{figure}

The \texttt{stub()} function serves as a wrapper for each installed signal handler,
and is shown in Listing~\ref{lst:assafe_helpers}.  If the program is interruptible
(that is, the next libset is not equal to the starting one), neither of the
conditionals is taken.  In this case, the wrapper simply switches to the starting
libset, calls the real handler for the arriving signal, then resets the libset.

Things are more complicated if the signal arrives while uninterruptible code is
running, in which case \textit{libas-safe} defers invoking its handler until the end
of the uninterruptible section.  In this case, \texttt{stub()} takes its
\texttt{else if} branch and stores the \texttt{siginfo\_t} structure describing the
cause of the signal into the thread-local \texttt{pending} variable.\footnote{Our
prototype does not support deferring more than one distinct signal at a time, and
always forwards the \texttt{siginfo\_t} corresponding to the first instance thereof
to arrive.  It follows the semantics of non-realtime Unix signals and only delivers
a deferred signal once, regardless of how many times it occurred while blocked.}  It
then changes the signal mask of the \textit{calling} code to block the signal from
arriving and returns without invoking the handler.  Whenever the program becomes
interruptible again, \textit{libgotcha} will invoke the \texttt{restorer()} callback,
also show in in Listing~\ref{lst:assafe_helpers}.

If it finds a deferred signal to deliver, the callback sends the current thread that
signal if it is not already pending (i.e., if it has not arrived again since the
instance that prompted us to defer it).  It then uses \texttt{sigsuspend()} to
temporarily unblock the signal and atomically wait for its handler to run.  This
jumps back to \texttt{stub()}, which now enters its \texttt{if} branch, sets the
signal as no longer deferred, configures it to be unblocked upon return from the
handler, and substitutes the saved \texttt{siginfo\_t} for the real one (in case
\texttt{restorer()} had to signal the thread).  Finally, it calls the real
handler and leaves the starting libset.\footnote{If curious why restoring the libset
in this way works, see the sister footnote in Section~\ref{sec:libgotcha:callbacks}.}

\begin{figure}
\begin{lstlisting}[label=lst:assafe_helpers,caption=\textit{libas-safe}'s signal handler wrapper and control library callback]
static thread_local siginfo_t pending;

static void stub(int no, siginfo_t *si, ucontext_t *uc) {
	libset_t libset = libset_thread_get_next();
	if(pending.si_signo) {
		// It is time to deliver a signal we had previously deferred.
		assert(pending.si_signo == no);
		pending.si_signo = 0;
		sigdelset(&uc->uc_sigmask, no);
		si = &pending;
	} else if(libset == LIBGOTCHA_LIBSET_STARTING) {
		// The program is uninterruptible; we need to defer delivery.
		if(verbose) fprintf(
			stderr,
			"LIBAS-SAFE: stub() deferring handling of signal %d\n",
			no);

		memcpy(&pending, si, sizeof pending);
		libgotcha_sigaddset(&uc->uc_sigmask, no);

		// Do not call the handler at this time.
		return;
	}

	libset_thread_set_next(LIBGOTCHA_LIBSET_STARTING);
	handlers[no](no, si, co);
	libset_thread_set_next(libset);
}

static void restorer(void) {
	if(pending.si_signo) {
		// There is a deferred signal to deliver.
		sigset_t ready;
		sigpending(&ready);
		if(!sigismember(&ready, pending.si_signo))
			libgotcha_pthread_kill(pthread_self(), pending.si_signo);

		sigset_t full;
		libgotcha_sigfillset(&full);
		sigdelset(&full, pending.si_signo);
		sigsuspend(&full);
	}
}
\end{lstlisting}
\end{figure}

While the technique employed by \textit{libas-safe} makes it easier to write signal
handlers in C, this is not its most exciting application.  Async-signal safety is a
very specific case that otherwise sound systems programming type systems have long
struggled to handle.  Rust is no exception, and writing signal handlers requires
\texttt{unsafe} code.  Yet this style of runtime assistance may offer a route to
lifting this requirement in situations where the load time and runtime costs are
acceptable.


\subsection{Automatically repaired example program}

\solb{Find a nice example, ideally one that works for both copying and deferral}

\solb{Mention that there's actually no need to save and restore errno now!}
