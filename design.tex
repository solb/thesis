\section{Design}

We propose an interface (shown in Listing~\ref{lst:interface}) for working with
preemptible functions that consists of two primary functions, \texttt{launch()} and
\texttt{resume()}, and a structured \texttt{linger} type for storing return values
and execution state.  Client code creates a preemptible function by passing an
ordinary function (or closure) to the \texttt{launch()} function along with an
execution time cap (in microseconds).  If the function completes on time,
\texttt{launch()} returns its result to the caller; otherwise, it returns an opaque
continuation object that the caller may later pass to \texttt{resume()} to continue
executing the function from wherever it was preempted.

\begin{lstlisting}[label=lst:interface,caption=Preemptible functions C-language interface]
struct linger {
	bool is_completion;
	union {
		void *completion;
		opaque_t continuation;
	};
};

typedef void *(*function_t)(void *);

struct linger launch(function_t func, uint64_t time, void *args);
void resume(struct linger *timed_func, uint64_t time);
\end{lstlisting}

Listing~\ref{lst:usage} shows a basic usage example where the caller is obligated to
perform some work (say, call a watchdog) after a certain amount of time, but first
calls into some helper code with weak time bounds.  With preemptible functions,
the caller does not have to trust the helper to know that the watchdog will be called
in time.

\begin{lstlisting}[label=lst:usage,caption=Preemptible function usage example]
res = launch(helper, TIMEOUT, NULL);
call_watchdog(); // Won't be delayed
if(res.is_completion)
	// We're already done
	return res.completion;
else
	// Give helper() some more time
	resume(&res, TIMEOUT);
\end{lstlisting}

The intentional simplicity of our API belies the complexity of its design and the
difficulty of its implementation.  These challenges can be grouped into three
categories:

\paragraph{Language independence}
Although the interface we propose bears some similarities to that of Scheme
engines~\cite{haynes:iucs1984}, our design treats language independence as a
first-level concern, and therefore deliberately differs in a few ways:  First, we
return a structured type instead of a function; languages with operator overloading
may achieve the other syntax by defining the \texttt{linger} type's function-call
operator to call the \texttt{resume()} function.  Second, because the preemptible
function itself may contain state, we make the \texttt{linger} type stateful as well,
allowing \texttt{resume()} to mutate it in place.  Finally, instead of passing the
preemptible function's return value to a separate callback function, we return it
directly from \texttt{launch()} because many modern languages have first-class tagged
union (sum) types allowing the compiler to enforce that the caller explicitly checks
which variant the union contains.  In addition to the barebones C interface, our
current implementation provides a Rust interface demonstrating these extensions.

\paragraph{Reasonable performance on modern hardware}
Recent prior work models concurrency in terms of threads which must be scheduled onto
a CPU by some combination of the language runtime and kernel scheduler.  While this
has the obvious advantage of allowing the launched function to run on a different
core than its caller, this comes at the cost of involving the schedulers even when
parallelism is not desired.  Furthermore, we showed in Section~\ref{sec:intro} that
the threading abstraction is ill-suited to support preemptible functions.  Because of
these factors, our interface is synchronous and lends itself to executing preemptible
functions on the same thread as the caller.  As we'll soon see, this does not render
preemptible functions incompatible with threading; indeed, we'll demonstrate the
straightforward application of our abstraction to implement preemptive scheduling in
a userland thread library.

\paragraph{Automatic handling of shared state}
Because our interface executes the preemptible function on the same thread, and said
function might be interrupted before it completes, the code following a call to
\texttt{launch()} or \texttt{resume()} can be thought of as a signal handler.  As
such, we would expect it to be limited to calling async-signal-safe functions, as
discussed in Section~\ref{sec:related}.  We find such a requirement unacceptable, as
it would make preemptible functions almost impossible to use correctly.  Our work
keeps the interface intuitive by automatically lifting this requirement in the common
case.  Unlike prior work, we do this without relying solely on nonpreemptible regions
(which would severely weaken our ability to enforce timeouts):\@ in many cases, we
are able to instead leverage the runtime dynamic linker to maintain compatibility
with third-party code.

Those familiar with futures may notice their applicability to preemptible functions
and similarity to our interface.  Although each language's futures differ slightly,
bindings can be constructed in the following trivial manner:
To create a new preemptible future, the bindings should call \texttt{launch()} with a
budget of 0 $\mu$s.  Each attempt to poll the future for a value should resolve to a
call to \texttt{resume()} with the timeout passed to poll (if allowed by the
language's API), or else previously associated with the future by other means.
