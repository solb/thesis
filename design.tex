\section{Libinger interface and design}

\begin{figure}
\begin{lstlisting}[label=lst:ingerapi,caption=Preemptible functions interface]
struct linger_t {
  bool is_complete;
  cont_t continuation;
};

linger_t launch(Function func,
                u64 time_us,
                void *args);
void resume(linger_t *cont, u64 time_us);
\end{lstlisting}
\end{figure}

\textit{libinger} provides two API calls (Listing~\ref{lst:ingerapi}): \texttt{launch()}
invokes an ordinary function $\mathcal{F}$ with an execution time cap of T
microseconds. \texttt{launch()} returns control to the caller when $\mathcal{F}$
completes,
or after approximately T microseconds if $\mathcal{F}$ does not complete in the
allotted time. In the latter case, \textit{libinger} returns an opaque
continuation object that may be used to \texttt{resume()} $\mathcal{F}$ at a
later time. Listing~\ref{lst:usage} shows an example usage of \textit{libinger}
in a task queue manager designed to prevent blocking tasks behind long-running
tasks. The caller invokes a task with a timeout. If the task does not complete
within the allotted time, the caller saves its continuation in task queue,
proceeds to handling other tasks, and later resumes the first task. 

\begin{figure}
\begin{lstlisting}[label=lst:usage, caption=Preemptible function usage example]

linger = launch(task, TIMEOUT, null);
if (!linger.is_complete) {
  // Save @linger to a task queue to
  // resume later
  task_queue.push(linger);
}

// Handle other tasks
...
// Resume @task at some later point
linger = task_queue.pop();
resume(&linger, TIMEOUT);
\end{lstlisting}
\end{figure}

We next discuss three design decisions we made for \textit{libinger}, and the
rationale for these decisions.

\subsection{Automatic handling of shared state}

As discussed in Section~\ref{sec:intro}, we wish to design a preemptible
functions library that supports calling third-party libraries without
modification or recompilation. Requiring users to modify such libraries to make
them amenable for \textit{libinger} would greatly limit the usability and convenience
of \textit{libinger}. The central challenge for \textit{libinger} is the \emph{shared
state} problem: Suppose a timed function $\mathcal{F_1}$ calls a stateful
routine in a third-party library $\mathcal{L}$. $\mathcal{F_1}$ times out, and
is preempted by \textit{libinger}. Later the user invokes another timed function
$\mathcal{F_2}$, which also calls a stateful routine in $\mathcal{L}$. The
challenge for us then is to hide state modifications in $\mathcal{L}$ by
$\mathcal{F_1}$ from the execution of $\mathcal{F_2}$.

One non-solution to this problem is to limit functions invocable from
\textit{libinger} to async-signal-safe functions (Section~\ref{sec:related}), because
doing so severely limits the usability of \textit{libinger}. Our solution to this
problem is to automatically and dynamically create copies of $\mathcal{L}$ to
isolate state from different timed functions. Doing so while running on
existing systems software (a requirement discussed next) requires solving many
design and implementation challenges, which we discuss in
Section~\ref{sec:libinger}.


\subsection{Performance on unmodified system stacks}

Unlike prior work on low-latency preemptive scheduling such as
Shinjuku~\cite{Kaffes:nsdi2019}, \textit{libinger} runs on top of the existing
OS. An obvious design to achieve this goal would be to use a thread or process,
the existing concurrency mechanisms provided by the OS, but these mechanisms
are too slow. We choose a middle ground between the very fast but specialized
approaches like Shinjuku, and slow but fully-general OS approaches.

Our goal was to create a core \textit{libinger} API that can be integrated in many
systems languages. We currently provide the \textit{libinger} API to C and Rust code.


%It is traditional to conceptualize concurrency as threads that must be
%scheduled onto a CPU by some combination of the language runtime and kernel
%scheduler. While this has the obvious advantage of allowing the launched
%function to run on a different core than its caller, it comes at the cost of
%involving the schedulers even when parallelism is not desired.  Furthermore,
%recall from Section~\ref{sec:intro} that conventional thread-based software
%stacks only support cancellation at process granularity. To efficiently support
%the common case of running and cancelling preemptible functions on the same
%thread as the caller, our interface is synchronous (but still compatible with
%threaded execution).  We achieve preemption on top of the existing systems
%stack by subscribing to a periodic timer signal.

%\subsection{Language independence}
%
%Our interface is inspired by that of Scheme engines~\cite{haynes:iucs1984};
%however, since we seek language independence, there are some fundamental
%differences.  Most notably, our preemptible functions may contain
%state\footnote{In addition to lifting a restriction on timed code, this
%difference led us to make the \texttt{linger} type stateful as well, and allow
%the \texttt{resume()} function to mutate it in place rather than constructing a
%copy.  In another move to improve portability, we chose to make \texttt{linger}
%a structured type instead of a function, thereby avoiding dependence on
%languages supporting closures.  In languages with operator overloading, the
%preemptible function bindings may define a function-call operator that calls
%\texttt{resume()} to achieve Scheme-style surface syntax.}, something not
%handled by Scheme due to the functional nature of the language.  We simplify
%their API by returning the preemptible function's return value in the
%\texttt{linger} union rather than passing it to a success callback.  Our goal
%was to create a core API amenable to language-specific integration integration;
%for instance, in addition to the barebones C interface, our current
%implementation exposes a Rust interface that uses a first-class tagged union
%(sum type) to ensure at compile time that the caller has checked which variant
%a \texttt{linger} contains before using it.
