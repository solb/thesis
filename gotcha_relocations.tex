While selective relinking supports the ordinary \texttt{GLOB\_DAT} (eager) and
\texttt{JUMP\_SLOT} (lazy) ELF dynamic relocation types, it is incompatible with the
optimized \texttt{COPY} class of dynamic variable relocations.  The \texttt{COPY}
model works by allocating space for all libraries' globals in the executable,
enabling static linking from the program's code (but not its dynamic libraries').
This transformation defeats selective relinking for two reasons:\@ the use of static
linking prevents identifying symbol uses in the executable, and the cross-module
migration causes breakages such as failing assertion (3) from
Listing~\ref{lst:exmplstate}.  When building a program that depends on
\textit{libgotcha}, programmers must instruct their compiler to disable \texttt{COPY}
relocations, as with the \texttt{-fpic} switch to GCC and Clang.  If
\textit{libgotcha} encounters any \texttt{COPY} relocations in the executable, it
prints a load-time warning.

Forsaking \texttt{COPY} relocations does incur a small performance penalty, but
exported global variables are rare now that thread safety is a pervasive concern in
system design.  Even the POSIX-specified \texttt{errno} global is gone:\@ the Linux
Standard Base specifies that its address is resolved via a call to the
\texttt{\_\_errno\_location()} helper function~\cite{www-lsb-errno}.

\thesis{Discuss \texttt{GNU\_IFUNC} relocations?}
