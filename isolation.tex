\section{Providing Isolation}
\label{sec:isolation}

Consolidating multiple users' jobs into a single process requires
addressing security and isolation. We aim to do this in a way that does not
compromise our ambitious performance goals.

Our guiding philosophy for doing so is ``Language-based isolation with defense in depth.''
We draw inspiration from two recently-published systems whose own demanding
performance requirements drove them to perform similar coalescing of traditionally
independent components:  NetBricks~\cite{Panda2016} is a network functions runtime
for providing programmable network capabilities; it is unique among this class of
systems for running third-party network functions in-process rather than in VMs.
Tock~\cite{Levy2017} is an embedded microkernel whose servers (``capsules'') form
a common compilation unit and communicate using type-safe function calls.
As their primary defense against untrusted code, both systems
leverage Rust~\cite{www-rustlang}, a new type-safe systems programming language.


Rust is a strongly-typed, compiled language that uses a lightweight runtime
similar to C.  Unlike many other modern systems languages, Rust is an
attractive choice when predictable performance is critical because it does not use
a garbage collector.  Still, it manages to provide strong memory safety
guarantees by focusing on ``zero-cost abstractions'' (i.e., those that can be
compiled down to code whose safety is assured without runtime checks).  In
particular, safe Rust code is guaranteed to be free of null or dangling pointer
dereferences, invalid variable values (e.g., casts are checked and unions are
tagged), reads from uninitialized memory, mutations of non-\texttt{mut} data (roughly
the equivalent of C's \texttt{const}), and data races, among other
misbehaviours~\cite{www-rustlang-ub}.

We require each microservice to be written in Rust (although, in the future, it
might be possible to support subsets of other languages by compiling them to safe
Rust), giving us many aspects of the isolation we need.  It is difficult for
microservices to crash the worker process, since most segmentation faults are
prevented, and runtime errors such as integer overflow generate Rust panics that we
can catch.  Microservices cannot get references to data that does not belong to them
thanks to the variable and pointer initialization rules.

Given our performance goals, there is a crucial isolation aspect that
Rust does not provide: there is nothing to stop users from monopolizing the CPU\@.
Our system, however, must be preemptive. We are unaware of existing preemption
techniques that work at microsecond scales. Note that coroutine-like
cooperative multitasking approaches (such as lightweight threads in
Go~\cite{www-golang} and Erlang~\cite{www-erlang}) are not preemptive, so they
do not work for us. We briefly discuss our solution to this in the following section;
it depends on installing a \texttt{SIGALRM} handler and ensuring that trusted
code within the process handles the signal.

Our defense-in-depth comes from using lightweight operating-system protections
to block access to certain system calls, as well as the proposed mechanisms
in Section~\ref{sec:future}.  Some system calls must be blocked to have any
defense at all; otherwise, the microservice could create kernel threads (e.g.,
\texttt{fork()}), create competition between threads (e.g., \texttt{nice()}), or even
terminate the entire worker (e.g., \texttt{exit()}). Finally, user functions should
not have unmonitored file system access.

We propose to block system calls using Linux's \texttt{seccomp()} system
call~\cite{seccomp-manpage}; each worker process should call this during
initialization to limit itself to a whitelisted set of system calls.
Prior to lockdown, the worker process should install a \texttt{SIGSYS} handler
for regaining control from any microservice that attempts to violate the policy.
