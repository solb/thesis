\section{Providing Isolation}
\label{sec:isolation}

Consolidating multiple users' jobs into a single process requires
addressing security and isolation. We aim to do this in a way that does not
compromise our ambitious performance goals.

Our guiding philosophy for doing so is ``Language-based isolation with defense in depth.''
We draw inspiration from two recently-published systems whose own demanding
performance requirements drove them to perform similar coalescing of traditionally
independent components:  NetBricks~\cite{Panda2016} is a network functions runtime
for providing programmable network capabilities; it is unique among this class of
systems for running network functions from different vendors in-process rather than in VMs.
Tock~\cite{Levy2017} is an embedded operating system that provides (in addition to a
more traditional process model) a type of lightweight application known as a capsule
that is embedded within the kernel and communicates with it using simple function
calls.  As their primary line of defense against untrusted code, both systems
leverage Rust~\cite{www-rustlang}, a new type-safe systems programming language.


Rust is a strongly-typed, compiled language that uses a lightweight runtime
similar to C.  Unlike many other modern systems languages, Rust is an
attractive choice when predictable performance is critical due to its
lack of a garbage collector.  Still, it manages to provide strong memory safety
guarantees by focusing on ``zero-cost abstractions'' (i.e., those that can be
compiled down to code whose safety is assured without runtime checks).  In
particular, safe Rust code is guaranteed to be free of null or dangling pointer
dereferences, invalid variable values (e.g., casts are checked and unions are
tagged), reads from uninitialized memory, mutations of non-\texttt{mut} data (roughly
the equivalent of C's \texttt{const}), and data races, among other
misbehaviours~\cite{www-rustlang-ub}.

We require each microservice to be written in Rust, which gives us many aspects of
the isolation we need:  It is difficult for microservices to crash the worker process,
since most segmentation faults are prevented, and runtime errors such as integer
overflow generate Rust panics that we can catch.  Microservices cannot get references
to data that does not belong to them thanks to the variable and pointer initialization
rules.

Given our performance goals, there is a crucial isolation aspect that
Rust does not provide: there is nothing to stop users from monopolizing the CPU\@.
Our system, however, must be preemptive. We are unaware of existing preemption
techniques that work at microsecond scales. Note that coroutine-like
cooperative multitasking approaches (such as lightweight threads in
Go~\cite{www-golang} and Erlang~\cite{www-erlang}) are not preemptive, so they
do not work for us. We discuss our solution to this in the following section;
it depends on installing a \texttt{SIGALRM} handler and ensuring that trusted
code within the process handles the signal.

Our defense-in-depth comes from using lightweight operating-system protections
to block access to certain system calls, as well as the proposed mechanisms
in Section~\ref{sec:future}.  Some system calls must be blocked to have any
defense at all; 
otherwise, the microservice could disable the \texttt{SIGALRM}-based preemption
(e.g., \texttt{signal()}), create kernel threads (e.g., \texttt{fork()}),
create competition between threads (e.g., \texttt{nice()}), or even terminate
the entire worker (e.g., \texttt{exit()}). Finally, user functions should not
have unmonitored file system access.

We block access to system calls using the \texttt{seccomp()} system call~\cite{seccomp-manpage}
to have each worker process lock itself down during initialization,
thereby limiting the process to a
whitelisted set of system calls.  Prior to lockdown, the worker
process installs its \texttt{SIGALRM} handler for preemption, and
a  \texttt{SIGSYS} handler and tear down the running microservice if it is
ever received.

