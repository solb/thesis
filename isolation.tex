\section{Providing isolation}
\label{sec:isolation}

Consolidating multiple users' jobs into a single process requires
addressing security and isolation. We aim to do it without
compromising our ambitious performance goals.

Our guiding philosophy for achieving this is ``language-based isolation with defense
in depth.'' We draw inspiration from two recently-published systems whose own
demanding performance requirements drove them to perform similar coalescing of
traditionally independent components:  NetBricks~\cite{Panda2016} is a network
functions runtime for providing programmable network capabilities; it is unique among
this class of systems for running third-party network functions in-process rather
than in VMs.  Tock~\cite{Levy2017} is an embedded microkernel whose servers
(``capsules'') form a common compilation unit and communicate using type-safe
function calls.  As their primary defense against untrusted code, both systems
leverage Rust~\cite{www-rustlang}, a new type-safe systems programming language.


Rust is a strongly-typed, compiled language that uses a lightweight runtime
similar to C.  Unlike many other modern systems languages, Rust is an
attractive choice for predictable performance because it does not use
a garbage collector.  It provides strong memory safety
guarantees by focusing on ``zero-cost abstractions'' (i.e., those that can be
compiled down to code whose safety is assured without runtime checks).  In
particular, safe Rust code is guaranteed to be free of null or dangling pointer
dereferences, invalid variable values (e.g., casts are checked and unions are
tagged), reads from uninitialized memory, mutations of non-\texttt{mut} data (roughly
the equivalent of C's \texttt{const}), and data races, among other
misbehaviors~\cite{www-rustlang-ub}.

We require each microservice to be written in Rust (although, in the future, it
might be possible to support subsets of other languages by compiling them to safe
Rust), giving us many aspects of the isolation we need.  It is difficult for
microservices to crash the worker process, since most segmentation faults are
prevented, and runtime errors such as integer overflow generate Rust panics that we
can catch.  Microservices cannot get references to data that does not belong to them
thanks to the variable and pointer initialization rules.
