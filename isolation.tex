\section{Providing Isolation}
\label{sec:isolation}

Of course, consolidating multiple users' jobs into a single process requires
addressing the accompanying security challenges (isolation---in the sense of
confidentiality/integrity as well as resource limits), and doing so in a way that
does not compromise our ambitious performance goals.

Our guiding philosophy for doing so is ``Language-based isolation with defense in depth.''
We draw inspiration from two recently-published systems whose own demanding
performance requirements drove them to perform similar coalescing of traditionally
independent components:  NetBricks~\cite{Panda2016} is a network functions runtime
for providing programmable network capabilities; it is unique among this class of
systems for running the submitted functions in-process rather than in VMs.
Tock~\cite{Levy2017} is an embedded operating system that provides (in addition to a
more traditional process model) a type of lightweight application known as a capsule
that is embedded within the kernel and communicates with it using simple function
calls.  As their primary line of defense against untrusted code, both systems
leverage Rust~\cite{www-rustlang}, a new type-safe systems programming language.
(The defense in depth should come from operating system--level protections discussed
in Section~\ref{sec:future}.)

Rust is a strongly-typed, compiled language that reprises C's abstention from a
heavyweight runtime.  Unlike many other modern systems languages, Rust is an
attractive choice when both performance and predictability are critical due to its
lack of a garbage collector.  Still, it manages to provide strong memory safety
guarantees by focusing on ``zero-cost abstractions'' (i.e., those that can be
compiled down to code whose safety is assured without runtime checks).  In
particular, safe Rust code is guaranteed to be free of null or dangling pointer
dereferences, invalid variable values (e.g., casts are checked and unions are
tagged), reads from uninitialized memory, mutations of non-\texttt{mut} data (roughly
the equivalent of C's \texttt{const}), and data races, among other
misbehaviors~\cite{www-rustlang-ub}.

We require each microservice to be written in Rust, which gives us many aspects of
the isolation we need:  It is difficult for microservices to crash the worker process,
since most segmentation faults are prevented, and runtime errors such as integer
overflow generate Rust panics that we can catch.  Microservices cannot get references
to data that does not belong to them thanks to the variable and pointer initialization
rules.  
Given our performance goals, there is a significant aspect of the
required isolation that Rust does not provide: there is nothing to stop users from
monopolizing the CPU\@.
Our system, however, must be preemptive.\footnote{It is surprisingly hard to find lightweight
  threads that can be killed easily.  For example, 
Go~\cite{www-golang} and Erlang~\cite{www-erlang}'s lightweight threads
share a kernel thread among multiple tasks, but use cooperatative multitasking
between tasks on a thread;  there is no way to involuntarily terminate a task
from outside the task.}  We discuss our solution to this in the following
section.
