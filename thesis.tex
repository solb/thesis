\documentclass[12pt,letterpaper]{book}

\usepackage{amssymb}
\usepackage{booktabs}
\usepackage[T1]{fontenc}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}
\usepackage[mono=false]{libertine}
\usepackage{listings}
\usepackage{multirow}
\usepackage[numbers]{natbib}
\usepackage[libertine]{newtxmath}
\usepackage{subcaption}
\usepackage[svgnames]{xcolor}
\usepackage{xspace}

\newcommand{\chapquotes}{}
\newcommand{\Chap}{Chapter}
\newcommand{\chap}{chapter\xspace}
\newcommand{\paper}{thesis\xspace}
\newcommand{\Unix}{Unix\xspace}

\newcommand{\blacklist}[1][\xspace]{blocklist#1}
\newcommand{\whitelist}[1][\xspace]{allowlist#1}

\newcommand{\solb}[1]{{\color{magenta} TODO #1}}
\newcommand{\thesis}[1]{\solb{THESIS #1}}

\renewcommand{\contentsname}{Table of Contents}
\renewcommand{\lstlistlistingname}{List of Listings}

\lstset{captionpos=b,
	basicstyle=\ttfamily,
	keywordstyle=\color{Blue},
	commentstyle=\color{Green},
	columns=flexible,
	language=C++
}

\bibliographystyle{abbrvnat}

\newcommand{\ms}[1]{#1 ms}
\newcommand{\us}[1]{#1 $\mu$s}

\newcommand{\attribchapquote}{}
\newcommand{\gapchapquote}{}
\newcommand{\widthchapquote}{3in}
\newenvironment{chapquote}[2][1in]{
	\renewcommand{\attribchapquote}{#2}
	\renewcommand{\gapchapquote}{#1}
	\vspace{-2in}
	\begin{flushright}
	{\Large ``}
}{
	{\Large ''} \\
	--- \attribchapquote \\
	\rule{\widthchapquote}{1pt}
	\end{flushright}
	\vspace{\gapchapquote}
}

\makeatletter
\let\includegraphics@\includegraphics
\renewcommand{\includegraphics}[2][]{\includegraphics@[#1]{\includegraphicsdir#2}}
\newcommand{\includegraphicsdir}{}

\let\input@\input
\renewcommand{\input}[2][.]{
	\renewcommand{\includegraphicsdir}{#1/}
	\input@{#1/#2}
	\renewcommand{\includegraphicsdir}{}
}

\let\section@\section
\newenvironment{swallowsections}{
	\renewcommand{\section}[1]{}
}{
	\let\section\section@
}

\let\subsection@\subsection
\newenvironment{swallowsubsections}{
	\renewcommand{\subsection}[1]{}
}{
	\let\subsection\subsection@
}

\newenvironment{promotesubsections}{
	\renewcommand{\subsection}[1]{\section@{##1}}
}{
	\let\subsection\subsection@
}
\makeatother

\newenvironment{abstract}{}{}

\newcommand{\mytableistoobig}{}

\begin{document}

\frontmatter

\begin{titlepage}
\begin{center}
	\vspace*{\fill}

	\textbf{\Large Lightweight Preemptible Functions} \\
	A thesis \\
	\hfill \\
	{\large Sol Boucher} \\
	\today \\

	\vspace{1in}

	\textbf{Thesis committee:} \\
	David G.\@ Andersen, \textit{chair} \\
	Adam Belay \\
	Michael Kaminsky \\
	Brandon Lucia \\

	\vspace{\fill}

	\textit{Submitted in partial fulfillment of the requirements \\
	for the degree of Doctor of Philosophy} \\
	\hfill \\
	Computer Science Department \\
	School of Computer Science \\
	Carnegie Mellon University \\
	Pittsburgh, PA 15213 \\
\end{center}
\end{titlepage}

\cleardoublepage
\addcontentsline{toc}{chapter}{\contentsname}
\tableofcontents
\listoffigures
\addcontentsline{toc}{chapter}{\listfigurename}
\listoftables
\addcontentsline{toc}{chapter}{\listtablename}
\lstlistoflistings
\addcontentsline{toc}{chapter}{\lstlistlistingname}

\chapter{TODOs THESIS}

\section{POSIX contexts self-signaling trick (897fe6b)}

The handler's logic is as follows:  It checks whether
the preemptible function has exceeded its timeout; if so, it swaps the contents
of the signal handler's continuation (accessible via the final argument to the
function~\cite{sigaction-manpage}) with a checkpoint continuation saved by
\texttt{launch()}.  This causes the subsequent return from the signal handler
to jump back to \texttt{launch()}, which then returns a \texttt{linger}
structure containing the signal handler's original context.  A subsequent
\texttt{resume()} call on this packaged continuation proceeds in much the same
way as \texttt{launch()}, but resumes the original computation by sending
itself a special signal with \texttt{pthread\_kill()}, then swapping the saved
context with the contents of that handler's context\footnote{This is necessary
because POSIX left the semantics of calling \texttt{setcontext()} on the
continuation saved by a signal handler invocation unspecified, leading
implementations such as GNU not to handle this
case~\cite{getcontext-manpage}.}.

Signal pool trick:\@ see 17b86d2.


\section{ELF \textit{NODELETE} dynamic flag workaround (8dcf62b)}

Some shared libraries are marked with a special configuration flag,
\texttt{DF\_1\_NODELETE}, which prevents the dynamic linker from ever removing them
once they have been loaded.  Because almost all libraries depend on libc, the
presence of even one such library prevents us from reinitializing a libset for reuse
after its preemptible function has been cancelled!  The flag is mostly used on
libraries that need
to monkey-patch some other loaded library, such that the two subsequently have a
circular dependency.  Fortunately, this is not usually a problem because when we
unload one library from a libset, we then unload the rest, so whenever we encounter a
\texttt{NODELETE} object file, we make a special copy with the flag cleared, for
loading into every namespace except the main one.  The one place this does not work
is when a library monkey-patches the dynamic linker itself.  This
requires the use of a private interface, and the only offending library to our
knowledge is GNU libpthread, which replaces function pointers in order to cause the
dynamic linker to take locks when performing potentially concurrent operations; we
handle this by preventing the monkey-patching constructor code from running in our
modified copy of that library.


\section{Preserving pointer equality (5d4b902)}

A subtle but important point in the semantics of dynamic linking is that pointers to
the same definition must compare equal, regardless of where they are obtained.  For
instance,
the reader might notice that invocation is not the only thing a program can do with a
function:\@ it might also pass around the function's address.  In fact, after taking
the address, it could pass it to code within a different object file, which might
compare it\footnote{In order for such comparisons to correctly indicate whether the
same code will be run, the compiler loads such addresses directly from the GOT via
instructions of the special position-independent relocation form
\texttt{mov~\textit{symbol}@gotpcrel(\%rip),~\%\textit{dest}}, and the dynamic linker
resolves the calls and populates their GOT entries eagerly at load time.}.  To avoid
breaking pointer comparison, \textit{libgotcha} makes sure to share the same PLOT
stub between all GOT entries to a given symbol that use this type of
relocation.  As long as the current libset remains the same between the time of a
function pointer comparison and the time of its invocation, such a comparison
guarantees that \texttt{procedure\_linkage\_override()} will dispatch to the same
copy when invoked using either pointer.


\section{Lazy PLT relocation memoization trick (154d76e)}

The setup procedure described so far has one significant problem:\@ recall that a PLT
call memoizes the real address of its symbol by replacing the GOT entry, which should
cause subsequent calls to skip \textit{libgotcha}'s \texttt{procedure\_linkage\_override()}
codepath.  In order to prevent this, the constructor updates the relocation entries
corresponding to cross-library calls to point at \textit{shadow} GOT entries.  This
fools the dynamic linker into updating the shadow entry instead, meaning that
memoization still works, as shown in Figure~\ref{fig:override}.

\begin{figure}
\includegraphics[width=\columnwidth]{functions/figs/tables}
\caption{\texttt{procedure\_linkage\_override()} tables}
\label{fig:override}
\end{figure}


\section{Global variable interception heuristics (gotcha ebef4e0)}

Woah!  The error was in executing this instruction, which probably means it's
unreadable.  Let's *not* try to disassemble it; instead, we'll see whether we
just followed a misguided indirect call instruction.  First search backward from
the return address for such an instruction...

It looks like the base of the displacement-mode address calculation isn't one we
instrumented.  Maybe the code computed a custom base address using a register
that we've since updated due to a separate (but nearby) dereference?

See whether we can apply one of our heuristics.  Note that they currently assume
that the code applied a *linear* offset to the last address we resolved.

Let's try adding the same offset we did last time we resolved an address,
because we're in one of the following common situations:
\begin{itemize}
\item The client code is using the same base address register as it was
	during our last trip through this function.  This might indicate that
	said code is using the register as an address accumulator, but doing
	so in concert with some other temporary register: because of this
	indirection, overwriting the register with the temporary after we
	had preformed the original address resolution would have left us
	unable to process any subsequent values accumulated into the register.
\item The base address register is different than the one updated during our
	last trip through this function, but the value of the latter has
	remained unchanged since we updated it.  Because it contains a memory
	address we had to resolve, this strongly suggests that the client code
	has only executed a few instructions since then, which we can infer
	even if that set included one or more branch instructions.
\item The current return address points to the instruction immediately
	following the one that faulted to result in the last invocation of
	this function, and the current base address register's value has
	remained the same since the faulting instruction was executed.  This
	implies that said instruction was an indirect procedure call, and that
	the register was probably just used to pass a pointer argument.
	Because we didn't resolve the address of the indirect call until the
	client code was already transferring control, there was no way for it
	to have passed a pointer without performing arithmetic directly on the
	dummy address present before the call.
\end{itemize}

We resolved the address without applying a heuristic.  Save a record of what we
changed and how to allow us to heuristically resolve addresses based on our
experience.  Because this is guarded, heuristics cannot chain, but multiple of
them can be triggered based on a common base resolution.


\section{Uncopyable function calls diagram (424387e)}

See Figure~\ref{fig:uncopyable}.

\begin{figure}
\includegraphics[width=\columnwidth]{functions/figs/calltree}
\caption{What happens when a program calls an uncopyable function}
\label{fig:uncopyable}
\end{figure}


\section{Program automatically repaired by \textit{libas-safe} (ee2602a)}

The main use of \textit{libgotcha} is to make library function calls async-signal safe when
they would not otherwise be.  To more clearly illustrate the library's usefulness, we
pause to give a minimal example of such usage; specifically, we will leverage
\textit{libgotcha} to automatically fix the buggy program in Listing~\ref{lst:handlerbug},
which calls the async-signal-unsafe function \texttt{printf()} from its signal
handler.  Unfortunately, this function takes a lock on the \texttt{stdout} stream's
associated file descriptor, and the signal handler eventually interrupts the program
within \texttt{fflush()} while it is holding this same lock, resulting in deadlock.

\begin{figure}
\begin{lstlisting}[label=lst:handlerbug,caption=C program with a buggy signal handler]
static void handler(int ignored) {
  printf("In signal handler\n");
}

int main(void) {
  struct sigaction sa = {
    .sa_handler = handler,
  };
  sigaction(SIGALRM, &sa, NULL);

  struct timeval tv = {
    .tv_sec = 1,
  };
  struct itimerval it = {
    .it_interval = tv,
    .it_value = tv,
  };
  setitimer(ITIMER_REAL, &it, NULL);

  while(true)
    fflush(stdout);
}
\end{lstlisting}
\end{figure}


\section{Footnote introducing the concept of \textit{libac-safe} (d3336e4)}

While \textit{libas-safe} reestablishes async-signal safety, it would also be
possible to write a \textit{libgotcha} control library that did the same for what POSIX calls
async-cancellation safety.  The obvious application of this would be supporting
asynchronous thread cancellation (in the common case where \whitelist{ed} code was not
currently executing):\@ as we saw in Section~\ref{sec:intro}, today's POSIX and
Windows interfaces for this are broken to the point of practical uselessness.


\section{Process image diagrams}

Per thread (Figure~\ref{fig:procimgthd})

\begin{figure}
\includegraphics[width=\columnwidth]{figs/procimg_perthd}
\caption{Per-thread portion of process image}
\label{fig:procimgthd}
\end{figure}


\section{Libset reinitialization diagram}

See Figure~\ref{fig:reinit}.

\begin{figure}
\includegraphics[width=\columnwidth]{figs/reinit}
\caption{Libset reinitialization to support asynchronous cancellation}
\label{fig:reinit}
\end{figure}


\section{Preemptible functions rebuttal}

\input{functions/rebuttal/atc20-reviews-198.txt}


\section{A note on terminology (inger 7d5b2e2)}

We use the term lightweight preemptible function (LPF) to refer to the timed \textit{version} of a
function, as invoked via the \texttt{launch()} wrapper function in this library.  It's not quite right to
say that \textit{libinger} "provides preemptible functions"; rather, it provides a transformation from
an ordinary function into a preemptible one.

To provide the memory isolation necessary to introduce preemption and asynchronous cancellation at
sub-thread granularity without breaking existing program dependencies, the \textit{libgotcha} runtime
allocates a separate copy of all the program's loaded dynamic libraries for each preemptible
function.  While the thesis refers to this isolation unit as a libset, that term was unfortunately
coined late in development; as such, the source code and configuration variables refer to it as a
"group" instead.


\section{A note on design (inger 7d5b2e2)}

The thesis describes the \textit{libinger} API, and the generated HTML documentation gives a few more usage
details.  Here are some of the guiding principles that inspired our interface choices:
\begin{itemize}
\item **We do not assume users need asynchrony.**  Hence, preemptible functions \textit{run on the same kernel
	thread as their caller}.  This is good for performance (and especially invocation latency), but
	it is also important to be aware of; for instance, it means that a preemptible function will
	deadlock if it attempts to acquire a lock held by its caller, or vice versa.  If asynchrony is
	something you require, you can build it atop \textit{libinger}, as we have demonstrated with our
	\textit{libturquoise} preemptive userland thread library.
\item **We assume that simply calling a function with a timeout is the common use case.**  As such, the
	\texttt{launch()} wrapper both constructs and begins executing the preemptible function rather than
	asking the user to first employ a separate constructor.  The latter behavior can be achieved by
	passing the sentinel \texttt{0} as the timeout, then later using \texttt{resume()} to invoke the preemptible
	function.
\item **We endeavor to keep argument and return value passing simple yet extensible.**  Because Rust
	supports closures, the Rust version of \texttt{launch()} accepts only nullary functions: those seeking
	to pass arguments should just capture them from the environment.  Because C supports neither
	closures nor generics, the C version of \texttt{launch()} accepts a single \texttt{void *} argument that can
	serve as an inout parameter; it occupies the last position in the parameter list to permit
	(possible) eventual support for variable argument lists.
\item **We choose defaults to favor flexibility and performance.**  When a preemptible function times
	out, \textit{libinger} assumes the caller might later want to resume it from where it left off.  As
	such, both \texttt{launch()} and \texttt{resume()} pause in this situation; this incurs some memory and time
	overhead to provide a separate execution stack and package the continuation object, but has much
	lower overall cost than asynchronous cancellation.  If the program does require cancellation, it
	can request it explicitly by calling \texttt{cancel()} (C) or dropping the continuation object (Rust).
\item **We provide preemption out of the box, but the flexibility to cooperatively yield.**  The
	\texttt{pause()} primitive allows a preemptible function to "yield" back to its caller by immediately
	"timing out."  One can imagine building higher-level synchronization constructs atop this; for
	example, a custom mutex that paused instead of blocking would allow two or more preemptible
	functions to share state, even when some of them executed from the same kernel thread.
\item **We favor a simple, language-agnostic interface.**  Because the interface is based on the
	foundational function call abstraction, it looks very similar in both C and Rust.  Someday, it
	may look \textit{equally} similar in other languages as well, and in the meantime, it ought to enjoy
	compatibility with languages' C foreign-function interfaces.  It's relatively simple to integrate
	higher-level abstractions on top, such as the Rust futures wrapper available in \textit{libinger}'s
	\texttt{future} module.
\end{itemize}


\section{A note on implementation (inger 7d5b2e2)}

The timer signal handler in \textit{libinger} refuses to pause while the next libset is set to 0 (the
starting libset).  Because \textit{libinger} is statically linked with \textit{libgotcha}, the latter enforces a
transparent switch to this libset whenever a dynamic function call transfers control into the module
in the process image that corresponds to \texttt{libinger.so}.  This means that preemption is deferred on a
given kernel thread while \textit{libinger}'s own code is executing on that thread.

Of course, things are not quite that simple.  There are noteworthy exceptions to the rule:
\begin{itemize}
\item The public \textit{libinger} Rust interface includes a number of generic functions.  Because the Rust
	compiler monomorphizes such functions for the client code that uses them, \textit{their implementations
	are \textrm{not} in \texttt{libinger.so}!}  Rather, there is, roughly speaking, one or more copies of them
	(specialized for various type arguments) in each program module that calls them.  The generic
	functions are therefore implemented such that they package everything that differs by type, then
	call into non-specialized functions such as \texttt{setup\_stack()} and \texttt{switch\_stack()} to do the scary
	stuff.
\item The \texttt{resume\_preemption()} function is installed as a \textit{libgotcha} callback hook, and is implicitly
	invoked at the end of each deferred-preemption library call made by a preemptible function.
	\textit{This happens in the preemptible function's libset rather than the starting one}; this is
	essential because the callback's main task is to force the timer signal handler to run
	\textit{immediately} and check for a timeout, and we don't want the libset to inhibit preemption!
\end{itemize}


\section{Building glibc from source (inger 7d5b2e2)}

Although \textit{libinger} is compatible with an unmodified glibc in principle, in practice the build
configuration used by most distributions is insufficient for two reasons:
 * By loading numerous copies of the application's libraries, we tend to exhaust the static storage
   pool provided by the dynamic linker.  If your program hits this limit, it will crash at load time
   with an error like: \texttt{yourprogram: libgotcha error: Unable to load ancillary copies of library:
   somelibrary.so: cannot allocate memory in static TLS block}.
 * Stock glibc builds are limited to 16 linker namespaces, enough to support only 15 preemptible
   functions at any given time.  If your program hits this limit, it will crash at runtime with an
   error like: \texttt{launch(): too many active timed functions}.

Unfortunately, these configuration parameters are baked into the dynamic linker at build time.
What's more, changing (at least) the latter alters the size of internal structures that are shared
between \texttt{ld-linux.so}, \texttt{libc.so}, \texttt{libpthread.so}, and others, so making changes requires rebuilding
all of glibc.  Fortunately, provided you set the prefix properly when building glibc, the dynamic
linker will know where to search (by absolute path) for the other libraries; as such, most
applications that depend on \texttt{libinger.so} need only define a custom interpreter path pointing to the
\texttt{ld-linux-x86-64.so.2} file in your build directory.


\section{Control libraries (gotcha 8224235)}

There are two possible types of control library:
\begin{itemize}
\item An \textit{internal control library} is statically linked with \textit{libgotcha} to form a single shared
   object file that is loaded (or preloaded) as one unit.  In addition to having access to the
   \textit{libgotcha} control API (declared in \texttt{libgotcha\_api.h}), internal libraries enjoy the guarantee
   that their code always executes in the base libset, and have direct access to the C library
   functions deemed by \textit{libgotcha} to be too dangerous for the rest of the program to call
   (enumerated in \texttt{libgotcha\_repl.h}).
\item An \textit{external control library} is dynamically linked with \textit{libgotcha}, and therefore constitutes
   a separate shared object file that depends on \texttt{libgotcha.so} (or, perhaps, a compatible internal
   control library).  Calls into such a library do not cause an automatic libset switch unless
   explicitly \whitelist{ed} (which is currently not pluggable and done via \texttt{whitelist.c}), and the
   library does not have special access to dangerous C library functions.  External control
   libraries haven't been tested as extensively as internal ones, but are necessary when you want to
   have more than one control library in a single application, if you want to be able to update
   \textit{libgotcha} without rebuilding the control library, and maybe for other reasons yet to be
   discovered.
\end{itemize}

If an internal control library needs to alter the behavior of any additional third-party library
functions, it may designate them as dangerous by defining its own implementation of the same name.
Calls to the function from the rest of the process image will be rerouted to this implementation,
but calls from the control library (and \textit{libgotcha} itself) will be routed to the original
third-party implementation.  For more details, see the documentation in \texttt{libgotcha\_api.h}, the
advice about compiler optimizations in \texttt{libgotcha\_repl.h}, and the example control libraries in the
projects under the \texttt{example} directory.

Note that internal control libraries' calls to \textit{existing} dangerous C library functions are also
routed directly to the real implementation, but the control library may instead choose to call
\textit{libgotcha}'s safer wrapper.  A control library might even use this feature to wrap \textit{libgotcha}'s
own wrapper of a third-party library function!  These use cases are considered advanced: see the
documentation in \texttt{libgotcha\_repl.h}, and be prepared for some additional build system complexity
(e.g., our Make integration supports replacing calls to \texttt{cp} via the \texttt{\$(CP)} variable, which could
be used to inject an intermediate \texttt{objcopy} step into the build process).


\section{Lessons for system builders (slides)}

Resuming is a useful feature that is cheap, but introduces concurrency.
Cannot get CPU time isolation without memory isolation.
Design abstractions modularly and with an eye to simple use cases (e.g., \textit{libgotcha} as a separate
runtime with a very small control API, things listed in the note on design).
Treat debuggability as a first-order concern (e.g., permit disabling features that interfere at
runtime, test and maintain support for running under debugging and diagnostic tools).


\input{foreword}


\mainmatter

\input{intro}
\input{functions}
\input{gotcha}
\input{safety}
\input{inger}
\input{ingerc}
\input{turquoise}

\renewcommand{\paper}{chapter\xspace}
\input{microservices}
\renewcommand{\paper}{thesis\xspace}


\backmatter

\chapter{Proposed work}

\begin{swallowsections}
\input[functions]{concl}
\end{swallowsections}


\section{Remaining work}

I propose extending the work already completed in all three of the following ways:

\paragraph{Cancellation resource cleanup for the Rust interface}
Although we currently support asynchronous cancellation of timed-out preemptible
functions via \textit{libinger}'s \texttt{cancel()} facility, we do not yet perform
any automatic cleanup of already-allocated resources.  This is impossible
in general for C programs because the language lacks a destructor mechanism; however,
I intend to add at least partial support for doing so for Rust programs.  The basic
principle will be to throw an artificial exception (Rust panic) on the preemptible
function's execution stack, thereby unwinding the stack and invoking local variables'
destructors.  This approach alone will not guarantee comprehensive cleanup, because
such variables may not have been fully initialized at the time of preemption; for the
same reason, it may have safety ramifications that will merit additional study.  I
have some ideas about how to augment the technique, such as by extending
\textit{libgotcha} to keep a running cache of the several most recent allocations and
deallocations of common resources (e.g., memory and file descriptors) from each
libset.  While exhaustive cleanup may prove difficult to achieve, I hope to at least
catalogue situations where we guarantee not to leak certain classes of resource, and
perhaps provide a tunable allowing users to request full resource tracking if needed.

\paragraph{Automatic selection and variation of timer frequency}
For simplicity, the current \textit{libinger} implementation subscribes to timer
signals spaced a globally constant interval apart throughout the entire duration of
each preemptible function.  To improve efficiency while preserving preemption
granularity, I plan to dynamically determine this interval based on the requested
timeout.  For long-running functions, this will include delaying the first of these
signals until shortly before the timeout would expire.  Maintaining accuracy across
multiple CPUs will probably require building in a calibration routine to infer
configuration parameters.

\paragraph{Support OpenSSL and benchmark hyper with HTTPS}
Earlier in \textit{libgotcha}'s development history, it was able to run nginx with
OpenSSL.  Recent attempts at getting hyper to run with OpenSSL have ended in crashes,
yet this configuration is desirable for measurement because it exhibits a far greater
number of dynamic function calls, of which \textit{libgotcha} alters the performance
characteristics.  I aim to support and benchmark the configuration, which will likely
involve regression testing using the old nginx setup.

\hfill \\
\noindent
Additionally, I will complete one of the following projects, as selected by the
committee:

\paragraph{Optimize libset reinitialization}
The high cost of cancellation is a consequence of our libset reinitialization
approach, which currently involves unloading all libraries from the libset, then
reloading them and running all their constructors in the process.  I believe cheaper
schemes are possible, such as checkpointing only the writeable portions of each
library's address space (e.g., by replacing their page mappings with copy-on-write
pages backed by their saved contents immediately after return from the library's
constructors).

\paragraph{Achieve even finer--grained preemption}
The \textit{Shinjuku} authors included IPI microbenchmarks that suggest it should be
possible for us to achieve interrupt latencies and spacing within a small constant
factor of theirs.  I could attempt to achieve this by reusing some of their
optimizations to POSIX contexts and adding a specialized timer signal delivery
mechanism to the kernel to reduce the number of ISR instructions at the expense of
generality.

\paragraph{Implement ``\textit{libingerOS}'' container framework}
Generalizing the serverless platform case study, it should be possible to generate a
utility that takes two or more position-independent executables and combines them
into a single process whose thread(s) are timeshared between the ``programs'' using
preemptible functions.  Obviously, this would only provide memory isolation for
programs implemented in memory-safe languages.  This would be implemented on top of
\textit{libinger} as a sample application.

\paragraph{Implement a caching RPC framework}
The preemptible functions API naturally lends itself to problems of caching partial
computations, and one interesting case study would be a caching RPC framework.  I
imagine this working as follows:  Clients would enclose alongside each request the
timeout they were using when listening.  The server would process each request inside
its own preemptible function.  When the client timed out waiting for a response, the
server would simultaneously time out and cache the continuation.  Subsequent requests
for the same procedure with identical inputs would resume the interrupted computation
from where it left off.


\section{Timeline}

\begin{itemize}
\item 24 April 2020: ATC '20 author notification
\item 4 June 2020: ATC '20 camera-ready deadline (if applicable)
\item June 2020: Start cancellation resource cleanup, fix OpenSSL support
\item July 2020: Continue cancellation resource cleanup, fix OpenSSL support
\item August 2020: Finish cancellation resource cleanup
\item September 2020: Speaking skills talk, start automatic preemption intervals
\item October 2020: Finish and evaluate automatic preemption intervals
\item November 2020: Start committee-selected project
\item December 2020: Finish and evaluate committee-selected project
\item January--March 2021: Thesis writing, run any final experiments
\item April 2021: Finish thesis
\item May 2021: Defense
\end{itemize}


\cleardoublepage
\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{ref}

\end{document}
