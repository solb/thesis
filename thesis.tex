\documentclass[12pt,letterpaper]{book}

\usepackage{amssymb}
\usepackage{booktabs}
\usepackage[T1]{fontenc}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}
\usepackage[mono=false]{libertine}
\usepackage{listings}
\usepackage{multirow}
\usepackage[numbers]{natbib}
\usepackage[libertine]{newtxmath}
\usepackage{subcaption}
\usepackage[svgnames]{xcolor}
\usepackage{xspace}

\newcommand{\chapquotes}{}
\newcommand{\Chap}{Chapter}
\newcommand{\chap}{chapter\xspace}
\newcommand{\paper}{thesis\xspace}
\newcommand{\Unix}{Unix\xspace}

\newcommand{\blacklist}[1][\xspace]{blocklist#1}
\newcommand{\whitelist}[1][\xspace]{allowlist#1}

\newcommand{\solb}[1]{{\color{magenta} TODO #1}}
\newcommand{\thesis}[1]{\solb{THESIS #1}}

\renewcommand{\contentsname}{Table of Contents}
\renewcommand{\lstlistlistingname}{List of Listings}

\lstset{captionpos=b,
	basicstyle=\ttfamily,
	keywordstyle=\color{Blue},
	commentstyle=\color{Green},
	columns=flexible,
	language=C++
}

\bibliographystyle{abbrvnat}

\newcommand{\ms}[1]{#1 ms}
\newcommand{\us}[1]{#1 $\mu$s}

\newcommand{\attribchapquote}{}
\newcommand{\gapchapquote}{}
\newcommand{\widthchapquote}{3in}
\newenvironment{chapquote}[2][1in]{
	\renewcommand{\attribchapquote}{#2}
	\renewcommand{\gapchapquote}{#1}
	\vspace{-2in}
	\begin{flushright}
	{\Large ``}
}{
	{\Large ''} \\
	--- \attribchapquote \\
	\rule{\widthchapquote}{1pt}
	\end{flushright}
	\vspace{\gapchapquote}
}

\makeatletter
\let\includegraphics@\includegraphics
\renewcommand{\includegraphics}[2][]{\includegraphics@[#1]{\includegraphicsdir#2}}
\newcommand{\includegraphicsdir}{}

\let\input@\input
\renewcommand{\input}[2][.]{
	\renewcommand{\includegraphicsdir}{#1/}
	\input@{#1/#2}
	\renewcommand{\includegraphicsdir}{}
}

\let\figure@\figure
\let\endfigure@\endfigure
\let\includegraphixs@\includegraphics
\let\caption@\caption
\let\label@\label
\newenvironment{swallowfigures}{
	\renewenvironment{figure}{
		\renewcommand{\includegraphics}[2][]{}
		\renewcommand{\caption}[1]{}
		\renewcommand{\label}[1]{}
	}{
		\let\includegraphics\includegraphixs@
		\let\caption\caption@
		\let\label\label@
	}
}{
	\let\figure\figure@
	\let\endfigure\endfigure@
}

\let\section@\section
\newenvironment{swallowsections}{
	\renewcommand{\section}[1]{}
}{
	\let\section\section@
}

\let\subsection@\subsection
\newenvironment{swallowsubsections}{
	\renewcommand{\subsection}[1]{}
}{
	\let\subsection\subsection@
}

\newenvironment{promotesubsections}{
	\renewcommand{\subsection}[1]{\section@{##1}}
}{
	\let\subsection\subsection@
}
\makeatother

\newenvironment{abstract}{}{}

\newcommand{\mytableistoobig}{}

\begin{document}

\makeatletter
\let\label@\label
\let\ref@\ref
\newenvironment{namespacereferences}[1]{
	\renewcommand{\label}[1]{\label@{#1##1}}
	\renewcommand{\ref}[1]{\ref@{#1##1}}
}{
	\let\label\label@
	\let\ref\ref@
}
\makeatother

\frontmatter

\begin{titlepage}
\begin{center}
	\vspace*{\fill}

	\textbf{\Large Lightweight Preemptible Functions} \\
	A thesis \\
	\hfill \\
	{\large Sol Boucher} \\
	\today \\

	\vspace{1in}

	\textbf{Thesis committee:} \\
	David G.\@ Andersen, \textit{chair} \\
	Adam Belay \\
	Michael Kaminsky \\
	Brandon Lucia \\

	\vspace{\fill}

	\textit{Submitted in partial fulfillment of the requirements \\
	for the degree of Doctor of Philosophy} \\
	\hfill \\
	Computer Science Department \\
	School of Computer Science \\
	Carnegie Mellon University \\
	Pittsburgh, PA 15213 \\
\end{center}
\end{titlepage}

\cleardoublepage
\addcontentsline{toc}{chapter}{\contentsname}
\tableofcontents
\listoffigures
\addcontentsline{toc}{chapter}{\listfigurename}
\listoftables
\addcontentsline{toc}{chapter}{\listtablename}
\lstlistoflistings
\addcontentsline{toc}{chapter}{\lstlistlistingname}

\chapter{TODOs THESIS}

\section{POSIX contexts self-signaling trick (897fe6b)}

The handler's logic is as follows:  It checks whether
the preemptible function has exceeded its timeout; if so, it swaps the contents
of the signal handler's continuation (accessible via the final argument to the
function~\cite{sigaction-manpage}) with a checkpoint continuation saved by
\texttt{launch()}.  This causes the subsequent return from the signal handler
to jump back to \texttt{launch()}, which then returns a \texttt{linger}
structure containing the signal handler's original context.  A subsequent
\texttt{resume()} call on this packaged continuation proceeds in much the same
way as \texttt{launch()}, but resumes the original computation by sending
itself a special signal with \texttt{pthread\_kill()}, then swapping the saved
context with the contents of that handler's context\footnote{This is necessary
because POSIX left the semantics of calling \texttt{setcontext()} on the
continuation saved by a signal handler invocation unspecified, leading
implementations such as GNU not to handle this
case~\cite{getcontext-manpage}.}.

Signal pool trick:\@ see 17b86d2.


\section{Program automatically repaired by \textit{libas-safe} (ee2602a)}

The main use of \textit{libgotcha} is to make library function calls async-signal safe when
they would not otherwise be.  To more clearly illustrate the library's usefulness, we
pause to give a minimal example of such usage; specifically, we will leverage
\textit{libgotcha} to automatically fix the buggy program in Listing~\ref{lst:handlerbug},
which calls the async-signal-unsafe function \texttt{printf()} from its signal
handler.  Unfortunately, this function takes a lock on the \texttt{stdout} stream's
associated file descriptor, and the signal handler eventually interrupts the program
within \texttt{fflush()} while it is holding this same lock, resulting in deadlock.

\begin{figure}
\begin{lstlisting}[label=lst:handlerbug,caption=C program with a buggy signal handler]
static void handler(int ignored) {
  printf("In signal handler\n");
}

int main(void) {
  struct sigaction sa = {
    .sa_handler = handler,
  };
  sigaction(SIGALRM, &sa, NULL);

  struct timeval tv = {
    .tv_sec = 1,
  };
  struct itimerval it = {
    .it_interval = tv,
    .it_value = tv,
  };
  setitimer(ITIMER_REAL, &it, NULL);

  while(true)
    fflush(stdout);
}
\end{lstlisting}
\end{figure}


\section{Footnote introducing the concept of \textit{libac-safe} (d3336e4)}

While \textit{libas-safe} reestablishes async-signal safety, it would also be
possible to write a \textit{libgotcha} control library that did the same for what POSIX calls
async-cancellation safety.  The obvious application of this would be supporting
asynchronous thread cancellation (in the common case where \whitelist{ed} code was not
currently executing):\@ as we saw in Section~\ref{sec:intro}, today's POSIX and
Windows interfaces for this are broken to the point of practical uselessness.


\section{Preemptible functions rebuttal}

\input{functions/rebuttal/atc20-reviews-198.txt}


\section{A note on terminology (inger 7d5b2e2)}

We use the term lightweight preemptible function (LPF) to refer to the timed \textit{version} of a
function, as invoked via the \texttt{launch()} wrapper function in this library.  It's not quite right to
say that \textit{libinger} "provides preemptible functions"; rather, it provides a transformation from
an ordinary function into a preemptible one.

To provide the memory isolation necessary to introduce preemption and asynchronous cancellation at
sub-thread granularity without breaking existing program dependencies, the \textit{libgotcha} runtime
allocates a separate copy of all the program's loaded dynamic libraries for each preemptible
function.  While the thesis refers to this isolation unit as a libset, that term was unfortunately
coined late in development; as such, the source code and configuration variables refer to it as a
"group" instead.


\section{A note on design (inger 7d5b2e2)}

The
\texttt{pause()} primitive allows a preemptible function to "yield" back to its caller by immediately
"timing out."  One can imagine building higher-level synchronization constructs atop this; for
example, a custom mutex that paused instead of blocking would allow two or more preemptible
functions to share state, even when some of them executed from the same kernel thread.

\textbf{We provide wrapper functions rather than a language extension.}  Many
	have argued that it is a mistake to extend a language's library with
	threading APIs without also endowing the language itself with an
	understanding of concurrency.  The number of preventable concurrency bugs
	that ISO C and POSIX threads have enabled seems to support this view.
	However, the decision has been made, concurrency is part of the C language,
	and the resulting bugs have been released upon the unsuspecting world.
	Fortunately, newer languages such as Rust have demonstrated that sound
	function-level concurrency is possible.  We provide wrapper functions
	reminiscent of \texttt{pthread\_create()} and leave it up to the language
	bindings to provide as much type safety as possible.


\section{A note on implementation (inger 7d5b2e2)}

The timer signal handler in \textit{libinger} refuses to pause while the next libset is set to 0 (the
starting libset).  Because \textit{libinger} is statically linked with \textit{libgotcha}, the latter enforces a
transparent switch to this libset whenever a dynamic function call transfers control into the module
in the process image that corresponds to \texttt{libinger.so}.  This means that preemption is deferred on a
given kernel thread while \textit{libinger}'s own code is executing on that thread.

Of course, things are not quite that simple.  There are noteworthy exceptions to the rule:
\begin{itemize}
\item The generic
	functions are therefore implemented such that they package everything that differs by type, then
	call into non-specialized functions such as \texttt{setup\_stack()} and \texttt{switch\_stack()} to do the scary
	stuff.
\item The \texttt{resume\_preemption()} function is installed as a \textit{libgotcha} callback hook, and is implicitly
	invoked at the end of each deferred-preemption library call made by a preemptible function.
	\textit{This happens in the preemptible function's libset rather than the starting one}; this is
	essential because the callback's main task is to force the timer signal handler to run
	\textit{immediately} and check for a timeout, and we don't want the libset to inhibit preemption!
\end{itemize}


\section{Lessons for system builders (slides)}

Resuming is a useful feature that is cheap, but introduces concurrency.
Cannot get CPU time isolation without memory isolation.
Design abstractions modularly and with an eye to simple use cases (e.g., \textit{libgotcha} as a separate
runtime with a very small control API, things listed in the note on design).
Treat debuggability as a first-order concern (e.g., permit disabling features that interfere at
runtime, test and maintain support for running under debugging and diagnostic tools).


\input{foreword}


\mainmatter

\input{intro}
\input{functions}
\input{gotcha}
\input{safety}
\input{inger}
\input{ingerc}
\input{turquoise}

\renewcommand{\paper}{chapter\xspace}
\input{microservices}
\renewcommand{\paper}{thesis\xspace}


\backmatter

\chapter{Proposed work}

\begin{swallowsections}
\input[functions]{concl}
\end{swallowsections}


\section{Remaining work}

I propose extending the work already completed in all three of the following ways:

\paragraph{Cancellation resource cleanup for the Rust interface}
Although we currently support asynchronous cancellation of timed-out preemptible
functions via \textit{libinger}'s \texttt{cancel()} facility, we do not yet perform
any automatic cleanup of already-allocated resources.  This is impossible
in general for C programs because the language lacks a destructor mechanism; however,
I intend to add at least partial support for doing so for Rust programs.  The basic
principle will be to throw an artificial exception (Rust panic) on the preemptible
function's execution stack, thereby unwinding the stack and invoking local variables'
destructors.  This approach alone will not guarantee comprehensive cleanup, because
such variables may not have been fully initialized at the time of preemption; for the
same reason, it may have safety ramifications that will merit additional study.  I
have some ideas about how to augment the technique, such as by extending
\textit{libgotcha} to keep a running cache of the several most recent allocations and
deallocations of common resources (e.g., memory and file descriptors) from each
libset.  While exhaustive cleanup may prove difficult to achieve, I hope to at least
catalogue situations where we guarantee not to leak certain classes of resource, and
perhaps provide a tunable allowing users to request full resource tracking if needed.

\paragraph{Automatic selection and variation of timer frequency}
For simplicity, the current \textit{libinger} implementation subscribes to timer
signals spaced a globally constant interval apart throughout the entire duration of
each preemptible function.  To improve efficiency while preserving preemption
granularity, I plan to dynamically determine this interval based on the requested
timeout.  For long-running functions, this will include delaying the first of these
signals until shortly before the timeout would expire.  Maintaining accuracy across
multiple CPUs will probably require building in a calibration routine to infer
configuration parameters.

\paragraph{Support OpenSSL and benchmark hyper with HTTPS}
Earlier in \textit{libgotcha}'s development history, it was able to run nginx with
OpenSSL.  Recent attempts at getting hyper to run with OpenSSL have ended in crashes,
yet this configuration is desirable for measurement because it exhibits a far greater
number of dynamic function calls, of which \textit{libgotcha} alters the performance
characteristics.  I aim to support and benchmark the configuration, which will likely
involve regression testing using the old nginx setup.

\hfill \\
\noindent
Additionally, I will complete one of the following projects, as selected by the
committee:

\paragraph{Achieve even finer--grained preemption}
The \textit{Shinjuku} authors included IPI microbenchmarks that suggest it should be
possible for us to achieve interrupt latencies and spacing within a small constant
factor of theirs.  I could attempt to achieve this by reusing some of their
optimizations to POSIX contexts and adding a specialized timer signal delivery
mechanism to the kernel to reduce the number of ISR instructions at the expense of
generality.

\paragraph{Implement ``\textit{libingerOS}'' container framework}
Generalizing the serverless platform case study, it should be possible to generate a
utility that takes two or more position-independent executables and combines them
into a single process whose thread(s) are timeshared between the ``programs'' using
preemptible functions.  Obviously, this would only provide memory isolation for
programs implemented in memory-safe languages.  This would be implemented on top of
\textit{libinger} as a sample application.

\paragraph{Implement a caching RPC framework}
The preemptible functions API naturally lends itself to problems of caching partial
computations, and one interesting case study would be a caching RPC framework.  I
imagine this working as follows:  Clients would enclose alongside each request the
timeout they were using when listening.  The server would process each request inside
its own preemptible function.  When the client timed out waiting for a response, the
server would simultaneously time out and cache the continuation.  Subsequent requests
for the same procedure with identical inputs would resume the interrupted computation
from where it left off.


\section{Timeline}

\begin{itemize}
\item 24 April 2020: ATC '20 author notification
\item 4 June 2020: ATC '20 camera-ready deadline (if applicable)
\item June 2020: Start cancellation resource cleanup, fix OpenSSL support
\item July 2020: Continue cancellation resource cleanup, fix OpenSSL support
\item August 2020: Finish cancellation resource cleanup
\item September 2020: Speaking skills talk, start automatic preemption intervals
\item October 2020: Finish and evaluate automatic preemption intervals
\item November 2020: Start committee-selected project
\item December 2020: Finish and evaluate committee-selected project
\item January--March 2021: Thesis writing, run any final experiments
\item April 2021: Finish thesis
\item May 2021: Defense
\end{itemize}


\cleardoublepage
\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{ref}

\end{document}
