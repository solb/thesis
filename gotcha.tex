\section{Shared state: \textit{libgotcha}}
\label{sec:libgotcha}

Having covered \textit{libinger} and \textit{libturquoise}, two libraries providing
tools intended for use by application programmers, we now turn our attention to the
reclusive \textit{libgotcha}.  Just as the shared state it protects is hidden behind
deceptive nonreentrant interfaces, \textit{libgotcha} lurks behind the scenes of
\textit{libinger}, which controls it using a private API.  Although the rest of the
program does not interact directly with \textit{libgotcha}, its presence has a
profound effect:\@ once loaded into the process image, it employs a technique we call
\textbf{selective relinking} to intercept and reroute many of the program's function
calls and global variable accesses at runtime.

The goal of \textit{libgotcha} is to establish around every preemptible function a
memory isolation boundary encompassing whatever third-party libraries that function
interacts with (Section~\ref{sec:libinger:reentrancy}).  The result is that the only
state shared across the boundary is that explicitly passed between via arguments,
return value, or closure---the same state the application programmer is responsible
for protecting from concurrency violations (Section~\ref{sec:libinger:concurrency}).

Note that \textit{libgotcha} operates at runtime, which constrains its visibility
into the program and therefore the granularity of its operation.  Because all static
relocations (e.g., between the object files and static libraries linked to form the
program executable) have already been resolved at build time via the static linker,
they are invisible to \textit{libgotcha}.  This means it cannot protect an
application's use of nonreentrant static libraries:\@ from \textit{libgotcha}'s
perspective, interactions with such a library are indistinguishable from those with
any other part of the executable.  However, whenever a dynamic relocation is involved
(e.g., a function call or global variable access between runtime-loaded objects such
as the executable and shared libraries), \textit{libgotcha} can tell the nature of
the symbol access and may choose to redirect it.

Before explaining selective relinking and introducing the \textit{libgotcha} API, we
will now briefly motivate the need for libgotcha by demonstrating how existing system
interfaces fail to provide the isolation we require.


\subsection{Library copying: namespaces}

Expanding a preemptible function's isolation boundary to include libraries requires
providing it with private copies of said libraries.  POSIX has long provided a
\texttt{dlopen()} interface to the dynamic linker for loading shared objects at
runtime; however, opening an already-loaded library does nothing more than increment
a reference count, and this function is therefore of no use for making copies.
Fortunately, the GNU dynamic linker (\texttt{ld-linux.so}) also supports
Solaris-style \textbf{namespaces}, or isolated sets of loaded libraries.  For each
namespace, \texttt{ld-linux.so} maintains a separate set of loaded libraries whose
dependency graph and reference counts are tracked independently from the rest of the
program~\cite{dlmopen-manpage}.

It may seem like namespaces provide the isolation we need:\@ whenever we
\texttt{launch(\textnormal{\textit{F}})}, we can initialize a namespace with a copy
of the whole application and transfer control into that namespace's copy of
\textit{F}, rather than the original.  The problem with this approach is that it
breaks lexical scoping.  For instance, the user would expect static variables in the
object file where \textit{F} is defined to be visible from both inside and outside of
the preemptible function, since they represent explicitly-shared state.

\solb{THESIS: Cover the algorithm for identifying GOT entries that correspond to
cross-library symbols.}


\subsection{Library copying: libsets}

We just saw that namespaces provide a form of isolation that is \textit{too strong}
for our needs:\@ because they have completely independent dependency graphs, they
never encounter any state from another namespace, even according to normal scoping
rules.  However, we can use namespaces to build the abstraction we need, which we
term a \textbf{libset}.  A libset is like a namespace, except that dynamic symbols
resolved from within one libset (e.g., due to a function call or global variable
access) may resolve to a definition of the same symbol in a different libset.  Such
\textbf{libset switches} are controlled via \textbf{libgotcha}'s control API, shown
in Listing~\ref{lst:gotchaapi}.

\begin{figure}
\begin{lstlisting}[label=lst:gotchaapi,caption=libgotcha C interface]
typedef long libset_t;

bool libset_thread_set_next(libset_t);
libset_t libset_thread_get_next(void);
bool libset_reinit(libset_t);
\end{lstlisting}
\end{figure}

Each thread has a \textbf{current libset}, which is the libset where the page of code
that is presently being executed is mapped.  It also has a \textbf{next libset}, as
exposed via the API, which is the libset to which dynamic symbols will resolved.  At
any given time, a thread's two libset settings may or may not agree.

This time we have the perfect abstraction:\@ when a
\texttt{launch(\textnormal{\textit{F}})} happens, \textit{libinger} assigns an
available \texttt{libset\_t} exclusively to that preemptible function.  Just before
calling \textit{F}, it informs \textit{libgotcha} by calling
\texttt{libset\_thread\_set\_next()}.  At this point, the current libset remains
unchanged, so the preemptible function enjoys the expected access to the same static
variables as the caller.

There is one scoping issue still to resolve, though.  Dynamic symbols can resolve back
to a definition in the same executable or shared object that used them, yet we want
global variables defined in \textit{F}'s object file to have the same scoping
semantics regardless of whether they are declared \texttt{static}.  For this reason,
only dynamic symbols that resolve to a definition in a different executable or shared
object than the use result in a libset switch.


\subsection{Managing libsets}

At program start, \textit{libgotcha} initializes a pool of libsets, each with a full
complement of the program's loaded object files.  Throughout the program's run
\textit{libinger} tracks the libset assigned to each preemptible function that has
started running but not yet reached successful completion.  Whenever a preemptible
function does complete, \textit{libinger} assumes it has not corrupted its libset and
returns it to the pool of available ones.  However, whenever a preemptible function
is canceled rather than being allowed to return, \textit{libinger} is forced to
assume that its libset's shared state has become corrupted.  It unloads and reloads
all objects in such a libset by calling \texttt{libset\_reinit()}.

\solb{THESIS: Can we (re)initialize libsets more efficiently than that (e.g., by
restoring only their writable sections)?}

While libinger in principle runs on top of an unmodified \texttt{ld-linux.so}, in
practice initializing more than one namespace tends to exhaust the
statically-allocated thread-local storage area.  We work around this by rebuilding
glibc with an increased \texttt{TLS\_STATIC\_SURPLUS}.  It is useful to also raise
the maximum number of namespaces by increasing \texttt{DL\_NNS}.

\solb{THESIS: Explain the trouble with COPY relocations and the need to use
\texttt{-fpic} as a workaround, ideally showing the performance ramifications
(e.g., via the nginx experiment).}

\solb{THESIS: Cover the \texttt{NODELETE} flag, ld.so monkey patching, and the
library header rewriting trick I use to circumvent the issue.}

\solb{THESIS: Describe (and hopefully even address) the monomorphization problem.}


\subsection{Selective relinking}

Most of the complexity of \textit{libgotcha} lies in the implementation of selective
relinking, the mechanism underlying libset switches.

Whenever a program uses a dynamic symbol, it looks up its address in a data structure
called the Global Offset Table (GOT).  As it loads the program, \texttt{ld-linux.so}
eagerly resolves the addresses of all global variables and some functions and stores
them in the GOT\footnote{Some other functions are instead resolved lazily at their
first invocation.}.

Selective relinking works by shadowing the GOT\footnote{Hence the name
\textit{libGOTcha}.}.  As soon as \texttt{ld-linux.so} finishes populating
the GOT, \textit{libgotcha} replaces every entry that should trigger a libset switch
with a fake address, storing the original one in its shadow GOT, which is organized
by the libset that houses the definition.  The fake address used depends upon the
type of symbol:

\solb{THESIS: Draw a diagram explaining our custom tables and the series of lookups
performed by \texttt{procedure\_linkage\_override()}.}

\solb{THESIS: Talk about PLOTs and pointer comparison.}

Functions' addresses are replaced by the address of a special function,
\texttt{procedure\_linkage\_override()}.  Whenever the program tries to call one of
the affected functions, this intermediary checks the thread's next libset, looks up
the address of the appropriate definition in the shadow GOT, and jumps to it.
Because \texttt{procedure\_linkage\_override()} runs between the caller's
\texttt{call} instruction and the real function, it is written in assembly to avoid
clobbering registers.

\solb{THESIS: Cover trick for defeating lazy PLT relocations' memoization.}

Global variables' addresses are replaced with a unique address within a mapped but
inaccessible page.  Whenever the program tries to read or write such an address, a
segmentation fault occurs; \textit{libgotcha} handles the fault, disassembles the
faulting instruction to determine the base address register of its address
calculation, loads the address from this register, computes the location of the
shadow GOT entry based on the fake address, checks the thread's next libset, and
replaces the register's contents with the appropriate resolved address.  It then
returns, causing the faulting instruction to be reexecuted with the valid address
this time\footnote{Although it is possible to
generate code sequences that are incompatible with this approach (e.g., because they
perform in-place pointer arithmetic on a register rather than using displacement-mode
addressing with a base address), we employ a few heuristics based on the context of
the instruction and fault; in our experience, these cover the common cases.}.

\solb{THESIS: Give more details on global variable interpositions, especially
heuristics.}


\subsection{Uninterruptible code}

The library-copying approach to memory isolation works for the common case, and
allows us to handle most third-party libraries with no configuration.  However, in
rare cases it is not appropriate.  The main example is the \texttt{malloc()} family
of functions:\@ in Section~\ref{sec:intro}, we observed that not sharing a common
heap complicates ownership transfer of objects allocated from inside a preemptible
function.  To support dynamic memory allocation and a few other special cases,
\textit{libgotcha} has an internal whitelist of \textbf{uninterruptible} symbols.

From \textit{libgotcha}'s perspective, uninterruptible symbols differ only in what
happens on a libset switch.  If code executing in any libset other than the
application's \textbf{starting libset} calls an uninterruptible symbol, a libset
switch still occurs, but it returns to the starting libset instead of the next
libset; thus, all calls to an uninterruptible symbol are routed to a single,
globally-shared definition.  When the function call that caused one of these special
libset switches returns, the next libset is restored to its prior value.  The
\textit{libgotcha} control API provides one more function,
\texttt{libset\_register\_interruptible\_callback()}, that allows others to request
a notification when one of these libset restorations occurs.

Because it is never safe to preempt while executing in the starting libset, the
first thing the \textit{libinger} preemption handler described in
Section~\ref{sec:libinger:signals} does is check whether the thread's next libset
is set to the starting one; if so, it disables preemption interrupts and immediately
returns.  However, \textit{libinger} registers an interruptible callback that it uses
to reenable preemption as soon as any uninterruptible function returns.

\solb{THESIS: Draw a figure depicting what happens w.r.t. the current libset,
preemptibility, and the notification callbacks when a preemptible function calls
an uninterruptible function (say, malloc()).}


\subsection{Case study: Auto async-signal safety}

\solb{Replace the term ``whitelisted'' with ``uninterruptible.''}

There are two ways to weaken the semantics of this program to prevent the deadlock
without modifying the program's source code.  (1) We can elide the file descriptor
lock, which in this case may occasionally allow the signal handler's output to
interleave with any (hypothetical) output from the main program (if the signal
handler interrupts a \texttt{write} syscall from the stream library implementation).
(2) We can defer handling of any signal that arrives during a call to
\texttt{fflush()} until that function returns.

In 127 lines of C, we wrote a signal-handling client library, \textit{libas-safe},
that can use libgotcha to automatically transform the program in either of these
ways.  It
injects code before \texttt{main()} to switch to a new libset, and provides a custom
implementation of \texttt{sigaction()} that switches the current libset back to the
main one while each signal handler is running.  This is enough to achieve
transformation (1), since it causes \texttt{main()} and \texttt{handler()} to use
distinct copies of the buffered \texttt{stdio} object.  One other \textit{libas-safe}
feature enables transformation (2):\@ whenever the main libset is already selected
when a signal handler runs, that handler is deferred (using libgotcha's callback
mechanism) until the current whitelisted call returns.  This transformation can be
demonstrated for this program by whitelisting the stdio functions and streams.

\solb{THESIS: Walk through example(s) of programs that are automatically repaired by
\textit{libas-safe}.}

\solb{THESIS: Explore \textit{libac-safe} idea?}

\solb{THESIS: Use \textit{libas-safe} to prototype a library that enables safe signal
handling in Rust.}

\solb{THESIS: It's been suggested that \texttt{libgotcha} could let you switch
between multiple versions of the same library (e.g., different revisions, feature
sets, or even release vs. debug).  This probably merits additional thought.}

\solb{THESIS: Another possible use for (an enhanced) \textit{libgotcha} is some kind
of scary runtime aspect-oriented programming thing (i.e., a generalization of
ltrace).}
