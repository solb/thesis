\chapter{Nonreentrancy and selective relinking: \\ the \textit{libgotcha} runtime}
\label{chap:libgotcha}

\ifdefined\chapquotes
\vspace{-1in}
\begin{chapquote}[1.5in]{James S.\@ A.\@ Corey, \textit{Nemesis Games}}
`Alien superweapons were used,' Alex said, walking into the room, \\
sleep-sweaty hair standing out from his skull in every direction. \\
`The laws of physics were altered, mistakes were made.'
\end{chapquote}
\fi

In Section~\ref{sec:libinger:reentrancy}, we saw that it is not safe in general for a
preemptible function to call into stateful code that was written without the
preemptible function abstraction in mind.  However, such code is prolific in the
modern systems stack, and in order to support interoperability with it, we need to
automatically transform the program to fix the safety hole.  This chapter covers a
novel software system designed to do just that, dubbed \textit{libgotcha}.

\begin{figure}
\begin{center}
\includegraphics[width=0.7\columnwidth]{figs/procimg_perobj}
\end{center}
\caption{Layout of a typical module within the process image.  \textbf{Bold} sections
contain program data; \textit{italicized} ones contain metadata for the runtime.}
\label{fig:procimgobj}
\end{figure}

\begin{swallowsections}
\input[functions]{gotcha_gotcha}
\end{swallowsections}
\hspace{-2.5em}
Our discussion in this chapter uses \textit{libinger} as a motivating example of a
\textit{libgotcha} user, as this configuration was the inspiration for the runtime's
creation.  However, we have found that the described techniques to be general and
equally relevant to applications besides timed functions.  As such,
\textit{libgotcha} exposes a general API that allows any \textbf{control library} to
configure its behavior for the process.  We give more details later in the chapter,
and study other examples of control libraries in Chapter~\ref{chap:safety}.


\section{A brief tour of linking}
\label{sec:libgotcha:link}

We begin with background about linking, a two-stage process that ultimately produces
an in-memory \textbf{process image} containing a program's code, all the data it
needs to execute, and the code and data of all its dependencies.  Linking operates on
\textbf{object files} that can take the form of either an \textbf{executable} or a
\textbf{shared library}.  Once a program is running, its process image contains a
region corresponding to each loaded object file.  We will refer to each such region as
a \textbf{module}, regardless of whether it corresponds to an executable or a shared
library.  Each module is divided into logical \textbf{sections}, each containing a
particular type of information.  Figure~\ref{fig:procimgobj} shows a typical module's
layout; notice that it contains both data corresponding to the source code and
generated metadata for runtime consumption.

The linking process occurs in two parts.  Static linking occurs at compile time and
forms the last step of the traditional build process.  Dynamic linking occurs at a
phase of runtime we will refer to as \textbf{load time}, because it starts before the
program has been loaded from disk or the language runtime initialized.


\subsection{Static linking}

Invoking the \texttt{cc} compiler driver does more than just compile C code:\@ it
runs the C preprocessor \texttt{cpp}, the C compiler (\texttt{cc1} in GCC's case),
then the static linker \texttt{ld}.

The output of the second step is a relocatable object file containing code and data
with referenced addresses identified by named \textbf{symbols}.  In a relocatable
object file, symbol \textbf{references} such as instructions making function calls
or accessing global variables are encoded with a null address as a placeholder.  Each
object file contains a \textbf{relocation table} in a separate section that
associates each placeholder with a symbol name, which may or may not be located in
the same file.  Each object file also contains a \textbf{symbol table} to identify
the symbols it defines and associate them with the file offset of their definition.
Note that only non-\texttt{static} C symbols generate global symbol table entries
that can be referenced from other object files; this keyword is confusingly named and
does not refer to static linking.  The compiler's ultimate output is one relocatable
object file for each source file.

The static linker is responsible for combining one or more relocatable object files
into a single executable or shared library, where either type of output file is
ready for loading into memory for execution.  This process consists of verifying that
there is a definition corresponding to each symbol reference, unifying the sections
across object files and choosing a final address (or relative address) for each
symbol, encoding the chosen addresses at the location recorded in each relocation
table entry, and writing the resulting file to disk.  This output file does not
preserve the relocation table because the linker has already fixed the null pointers
it described.  The file does contain a symbol table because it can be useful for
debugging (e.g., to generate stack traces), but this can be removed using the
\texttt{strip} utility without affecting the program semantics.

With the exception of macOS, most modern Unix systems use ELF (Executable and
Linkable Format) object files.  One advantage of this format is that executables and
shared libraries are themselves ELF object files.


\subsection{Dynamic linking}
\label{sec:libgotcha:dylink}
\label{sec:relinking}

Static linking allows programs to reuse ``libraries'' of precompiled object files,
but each program must be built with its own copy of all its libraries within the
executable.  This means that every time an application is loaded, its libraries' code
and data must be read back from disk, even if another running program uses the same
libraries; it also means that updating a library requires recompiling all dependent
programs installed on the system.  Dynamic linking solves both problems by separating
libraries into separate files that are not read until the executable runs.\footnote{
Specifically, this separation obviates the need to read the files from disk multiple
times because the runtime maps them into the process image using the \texttt{mmap()}
family of system calls.  The kernel tracks regions that are already mapped and serves
recurring requests from memory instead of disk, mapping to the same physical memory
if the pages are read-only or creating copy-on-write page mappings otherwise.}

By splitting libraries into their own files, dynamic linking introduces a build-time
challenge:\@ the relative position and offset of modules cannot be known until
runtime.  As such, rather than performing the relocations for inter-module symbol
references, the static linker leaves the placeholder addresses and adds a separate
dynamic relocation table and dynamic symbol table into the output object file.
Unlike the tables used for static linking, these are needed to launch the program, so
tools such as \texttt{strip} leave them in place.  For executables, the linker also
writes the path to an ``interpreter'' program into the ELF program header.

When asked to load a program that declares an interpreter, the kernel loads and jumps
to the interpreter instead of the executed program.  Usually, this interpreter is the
system \textbf{dynamic linker}, traditionally named \texttt{ld.so}.  Before jumping
into the program code, the dynamic linker loads all the modules and processes the
entries in each of their dynamic relocation tables.  The relocations are not
restricted to modifying writeable memory:\@ they can update constant global data and
even executable instructions.  Even if they leave the code unchanged, its position
relative to the rest of the module matters.  These points are critical to our use
case, as they mean that in order to duplicate modules' data, we must also duplicate
their code.

Another consequence of relocations being able to alter read-only memory is that the
dynamic linker must change the page protections of these regions after it is finished
processing relocations.  To support this, the compiler splits up module components
into fine-grained sections by purpose.  Non-\texttt{const} global variables are
placed in the \texttt{.data} and \texttt{.bss} sections, which must remain writeable
at runtime and therefore require no special action.  In contrast, \texttt{const}
globals are split between the \texttt{.rodata} and \texttt{.data.rel.ro} sections
based on whether they require relocation; in the latter case, the dynamic linker
marks the pages read-only before passing control to the program.

If relocations routinely modified scattered locations throughout the executable
\texttt{.text} section, the dynamic linker would have to change page protections on
most or all of each module's code pages.  This would require a lot of system calls,
but it would also require copy-on-write code mappings, preventing instruction cache
hits between processes using the same library.  To avoid these problems, the compiler
indirects references to dynamic symbols via a structure called the GOT (Global Offset
Table).

\begin{figure*}
\begin{minipage}{\textwidth}
	\includegraphics[width=\textwidth]{figs/gotables-crop}
	\subcaption{Reading a library's global variable: \texttt{size\_t tmp = data;}}
	\label{fig:dytabs:got}
	\end{minipage}

	\begin{minipage}{\textwidth}
	\includegraphics[width=\textwidth]{figs/pltables-crop}
	\subcaption{Calling an eagerly-resolved library function: \texttt{fun()}}
	\label{fig:dytabs:plt}
	\end{minipage}

	\begin{minipage}{\textwidth}
	\includegraphics[width=\textwidth]{figs/jstables-crop}
	\subcaption{Calling a lazily-resolved library function.  In step \textcircled{5},
	the dynamic linker memoizes the resolved address into the GOT; subsequent calls
	proceed as above.}
	\label{fig:dytabs:lazy}
	\end{minipage}
\caption{Table references required to reference global symbols in dynamically-linked
programs}
\label{fig:dytabs}
\end{figure*}

The GOT is a table of relocated pointers to symbol definitions, whether those
definitions are within the same module or in a different one.  To avoid generating
code pages that require relocations, the compiler compiles each reference to or
dereference of non-\texttt{static} global data into a position-independent load of
the corresponding pointer from the GOT.  Figure~\ref{fig:dytabs:got} shows an example
of the two instructions and one table reference needed for a dereference.  A
reference would generate only the first \texttt{mov} instruction, as would taking a
pointer to a function.

Calling a global function works differently and relies on another indirection
structure called the PLT (Procedure Linkage Table), which contains code instead of
pointers.  For each call to a non-\texttt{static} function, the compiler generates a
position-independent call to a PLT entry corresponding to the function being called.
It generates a PLT entry, which is a short sequence of instructions that loads the
pointer to the real definition from the GOT, then executes and indirect jump to that
location.  Figure~\ref{fig:dytabs:plt} shows an example function call.  As with GOT
entries, there are PLT entries for functions defined both within and outside the
referencing module.

Not all function calls are this simple.  To save the dynamic linker some work at load
time, many function calls resolve lazily on their first execution.  Such resolution
involves a series of jumps designed to memoize the address so that subsequent calls
to the function from the same module do not repeat the expensive lookup.
Figure~\ref{fig:dytabs:lazy} shows the effect of the first call to such a
function:\footnote{This representation is slightly simplified for brevity.  In
practice, it is undesirable to hardcode the address of a dynamic linker function into
each module.  Therefore, instead of jumping directly to the symbol resolver, the slow
lookup path jumps to a dedicated PLT stub that loads its address from another GOT
entry.  Technically, there are separate identifiers for the symbol and the module,
each pushed to the stack by one of these two involved PLT stubs.}  \textcircled{1}
The program calls the PLT stub, just as it would for an eagerly-resolved function.
\textcircled{2} The PLT stub is longer (three instructions instead of one), but still
begins with an indirect jump to the pointer found in the corresponding GOT entry.
\textcircled{3} The GOT entry initially contains the address of the PLT stub's second
instruction, so the indirect jump is a no-op and merely advances the instruction
pointer.  \textcircled{4} The rest of the PLT stub pushes a constant identifying the
module and symbol onto the stack, then jumps to a symbol-lookup function in the
dynamic linker.  \textcircled{5} After looking up the address of the symbol's
definition, the dynamic linker uses the identifier from the stack to find and update
the GOT entry in the calling module.  \textcircled{6} The dynamic linker jumps to the
symbol in the defining module.  Because the GOT entry has been updated, future calls
proceed exactly like eagerly-resolved ones and jump directly to the symbol definition
from the first instruction of the PLT stub.  Of course, the GOT entries associated
with lazy PLT stubs must be writeable at runtime; this is why
Figure~\ref{fig:procimgobj} shows the GOT as split between two sections.

The dynamic linker performs all relocations and other standard module setup
automatically at load time, but the initialization process is pluggable.  In
particular, modules can include \textbf{constructor} functions to be invoked before
control is transferred to the runtime and ultimately the program's main function.  As
we will see, our work leverages this feature to override certain relocations at the
conclusion of load time.


\begin{promotesubsections}
\input[functions]{gotcha_namespaces}


\input[functions]{gotcha_libsets}
\end{promotesubsections}

Thus, selective relinking is selective in two ways, only affecting execution when the
next libset differs from the current libset and the program references a dynamic
symbol defined in a module that is not currently executing on that thread.

\solb{Expand interface listing and add comments with section references}


\subsection{Detecting cross-module symbol references}

Identifying which GOT entries correspond to cross-module symbol references is a
multi-step process:
First, we traverse the relocation table for each loaded module, cross referencing
each of its relocation entries against the local module's symbol table.  If the
symbol table does not contain a definition matching the relocation entry's target, we
conclude that the relocation must correspond to a cross-module call.  Otherwise, we
check the address in the GOT entry corresponding to the relocation:  If this address
is outside the memory bounds of the current module, it is a cross-module call.
Otherwise, if this address matches the one from the symbol table entry, it is not a
cross-module call, and should be skipped.  The trickiest case is when the GOT entry
does not match but does point somewhere within the current module, since this means
it probably still refers to the PLT stub (because the symbol reference is lazy and
has not yet been resolved, as covered at the end of
Section~\ref{sec:libgotcha:dylink}).  In this case, we resolve the symbol early,
update the GOT entry, and recheck whether it resolved to the local definition to
determine whether it is a cross-module call.


\begin{promotesubsections}
\input[functions]{gotcha_init}
\end{promotesubsections}

If a preemptible function is canceled rather than being allowed to return, execution
might be interrupted within a call to a library function.  For this reason,
\textit{libgotcha} must treat the libset's shared state as corrupted; it provides the
\texttt{libset\_reinit()} function shown in Listing~\ref{lst:gotchaapi} to allow
control libraries to inform it of such a situation so it can \textbf{reinitialize}
the libset before returning it to the pool.

Our early approach to reinitialization was to unload and reload all objects in the
libset by calling \texttt{dlclose()} followed by \texttt{dlmopen()}.  While this
approach theoretically allowed us to delegate the work to the dynamic linker, in
practice it introduced significant complications.\footnote{Most notably, some shared
libraries are marked with a special configuration flag, \texttt{DF\_1\_NODELETE},
which prevents the dynamic linker from ever removing them once they have been loaded.
Because almost all libraries depend on libc, the presence of even one such library
would prevent us from reinitializing a libset.  The flag is mostly used on libraries
that need to monkey-patch some other loaded library, such that the two subsequently
have a circular dependency.  Fortunately, this was not generally a problem for us
because when we unload one library from a libset, we then unload the rest.  Whenever
we encountered a \texttt{NODELETE} object file, we would make a special copy with the
flag cleared, for loading into every namespace except the main one.}  Worse, it
required the dynamic linker to reprocess all relocations throughout the libset, which
introduced prohibitive runtime latency.  We measured reinitialization taking almost 5
ms (over 10 million cycles on modern processors) on even small minimal example
programs~\cite{boucher:atc2020}.  With such delays, the only reasonable way for the
control library to handle cancellation was to delegate the reinitialization to a
separate thread to take it off the critical path; of course, this approach only works
as long as the number of libsets is not a bottleneck.

We have since redesigned reinitialization around a significantly faster approach:\@
checkpointing only portions of each module.  The key insight is that, as we saw in
Section~\ref{sec:libgotcha:link}, only some sections are writeable at runtime.  We
can therefore assume that these are the only memory regions of each module that can
change.  After populating the libset pool at application start, \textit{libgotcha}
iterates through each module of each libset and makes a backup copy of all its
writeable regions.  When a control library calls \texttt{libset\_reinit()},
\textit{libgotcha} restores each such region from the backup before returning the
affected libset to the pool.  We summarize this approach, which has reduced the
latency of reinitialization by two orders of magnitude, in
Figure~\ref{fig:reinit}.\footnote{We will address the version watermark alluded to
therein later in this chapter.}  To avoid having to repeat relocations and rerun any
module constructors, we capture the backup after dynamic relocation is complete and
all constructors have run; the tradeoff is that we actually have to copy memory,
rather than leveraging copy on write to later restore to the version on disk.

\begin{figure}
\includegraphics[width=\columnwidth]{figs/reinit-crop}
\caption{Libset reinitialization to support asynchronous cancellation}
\label{fig:reinit}
\end{figure}


\section{Selective relinking}

Most of the complexity of \textit{libgotcha} lies in the implementation of selective
relinking, the mechanism underlying libset switches.  To establish the libset
abstraction, it must arrange to conditionally intercept cross-module symbol
uses based on the currently-configured next libset.

As we saw in Section~\ref{sec:libgotcha:dylink}, whenever a program references a
dynamic symbol, it looks up the address of the definition in a data structure called
the global offset table (GOT).  Selective relinking works by shadowing the
GOT.\footnote{Hence the name \textit{lib\textbf{got}cha}.}  Just after the dynamic
linker populates the GOTs, \textit{libgotcha} replaces every entry that should
sometimes trigger a libset switch with a fake address.  It stores the original
address in its shadow GOT, which is organized by the libset that houses the
definition.  The fake address used depends upon the type of symbol:


\subsection{Intercepting function calls}

When setting up selective relinking, we do not know whether a particular function
call needs to be rerouted until runtime.  However, the fact that dynamic function
calls consult the GOT to determine which code to execute makes it efficient and
relatively straightforward to receive a notification whenever they occur.  To set
this up, at load time, we replace each such cross-module GOT entry with the address
of the special \textit{libgotcha} function \texttt{procedure\_linkage\_override()}.
Whenever the program tries to call one of the affected functions, control transfers
to this function instead; it then checks the thread's next libset, looks up the
appropriate symbol definition in the shadow GOT, and jumps to that location.  Because
\texttt{procedure\_linkage\_override()} runs between the caller's \texttt{call}
instruction and the real function, it is written in assembly to avoid clobbering
registers (e.g., those used for argument passing).

There is one major complication that necessitates an additional level of indirection
beyond what we have described.  Recall from the eagerly-resolved function calling
sequence in Figure~\ref{fig:dytabs:plt} that each function call site calls a
one-instruction PLT stub that performs an indirect jump to the real definition via
the GOT.  This means that if we simply replaced all the GOT entries with the address
of \texttt{procedure\_linkage\_override()}, that function would not know which GOT
entry it was being called via, and therefore which symbol to look up.  Instead, we
introduce our own table of executable stubs called the PLOT (Procedure Linkage
Override Table).  Unlike PLT entries, ours always push an identifier indicating which
function is being called.  For this, we use indices into a custom data structure
called the GOOT (Global Offset Override Table), which stores enough information to
find the symbol's shadow GOT entries while being practical to traverse in handwritten
assembly code.  Figure~\ref{fig:override} summarizes the modified dynamic function
call sequence under selective relinking.

\begin{figure}
\includegraphics[width=\textwidth]{figs/tables-crop}
\caption{Calling an eagerly-resolved library function under selective relinking}
\label{fig:override}
\end{figure}

A subtle but important point about dynamic linking is that pointers to the same
definition must compare equal, regardless of where they are obtained.  For instance,
the reader might notice that invocation is not the only thing a program can do with a
function:\@ it might also pass around the function's address.  In fact, after taking
the address, it could pass it to code within a different module, which might need to
know whether a third module passed a pointer to the same function.  To support such
comparisons, the compiler exclusively generates eagerly-resolved relocations for any
function that a particular module obtains a pointer to.  This way, the \texttt{mov}
to retrieve the pointer always finds the resolved address of the real definition in
the GOT.  To avoid breaking pointer comparison, \textit{libgotcha} associates each
PLOT entry with its function's definition, not its call site or calling module.  This
provides correct comparison semantics because all references to a particular function
receive the same pointer to a particular PLOT entry, and although this pointer
technically refers to the corresponding symbol's definitions in all libsets, at any
one time all calls to it will only resolve to the definition in the next libset.
Since at any given time there can only be one next libset, calls to pointers that
compare equal always refer to the same copy of the definition.

The setup described so far works for eagerly-resolved function calls.  However,
recall that some function calls resolve to their definition lazily at runtime.  For
such calls, the dynamic linker memoizes the resolved address by updating the GOT
entry, as shown in Figure~\ref{fig:dytabs:lazy}.  Unfortunately, replacing this GOT
entry would overwrite the PLOT pointer installed by \textit{libgotcha} at load time,
thereby preventing it from intercepting future calls to the function.  The write to
the GOT happens within the symbol-lookup code in the dynamic linker, so there is no
way to skip it.  Luckily, the dynamic linker keeps each module's dynamic relocation
table in memory and uses that to determine which GOT entry to update.  The
\textit{libgotcha} constructor exploits this by marking the relocation table pages
writeable, changing the relocation entries corresponding to cross-library calls, then
restoring the protection bits.  This fools the dynamic linker's lazy symbol lookup
into later updating the shadow GOT entry instead.  Not only does this avoid breaking
selective relinking, it also preserves memoization.


\subsection{Intercepting global variable accesses}

Unlike function calls, global variable accesses do not provide an opportunity for
hijacking the flow of control to detect the dereference, so we rely on operating
system assistance to implement a mechanism similar to demand paging.  At load time,
we replace each cross-module global variable GOT entry with a carefully-chosen
address within a mapped but inaccessible memory region.  The program is therefore
able to retrieve a ``pointer to'' the global variable, but whenever it attempts to
read from or write to the location, it generates a segmentation fault;
\textit{libgotcha} registers a signal handler so such signals notify it rather than
crashing the program.  The handler disassembles the faulting instruction to determine
the base address register of its address calculation and attempts to reconstruct a
GOOT pointer based on the invalid address in that register.  If successful, it checks
the thread's next libset, retrieves the address of that libset's definition of the
symbol from the appropriate shadow GOT, and replaces the base address register's
contents with this address.  It then returns, causing the processor to reexecute the
faulting instruction with the valid address this time.  From the application's
perspective, it is as if dereferencing the phony pointer causes it to change into a
real address.  To avoid breaking applications with their own segmentation fault
handlers, \textit{libgotcha} intercepts calls to \texttt{sigaction()} and keeps a
pointer to the third-party handler.  Whenever its handler is unable to resolve a
segmentation fault, it forwards the signal to the third-party one.

The above approach assumes that the program will read or write from the global
variable, but the global variable could instead contain a function pointer.  If it
does and the program tries to invoke it, it will use an indirect call instruction and
the jump will succeed but transfer control to an invalid location.  In this
situation, it is important that we do not attempt to disassemble the faulting
instruction, as the instruction pointer is pointing to unreadable memory.  However,
we can recognize this case because the address of the fault matches the instruction
pointer itself (instead of whatever address the instruction would have been trying to
load data from).  To find the indirect call instruction, we load the return address
from the stack; this gives us the subsequent instruction, so we subtract the length
of an indirect call instruction.  We alter the signal handler's context so that the
operating system will transfer control back to this instruction when our handler
returns, then we disassemble the instruction and follow our usual approach on its
register operand.

It is possible to generate other code sequences that are incompatible with the
approach (e.g., because they perform in-place pointer arithmetic rather than using a
displacement-mode address calculation with a base address), so we also employ a few
heuristics that consider the context of the instruction and fault.  If the code is
reading or writing to a faulting location that we cannot translate into a GOOT
pointer, it might have applied a linear offset to the last address we successfully
translated.  If any of the following indicators point to this, we compute the offset
between the faulting address and the last invalid address we replaced, then compute
the replacement register value by adding this offset to the last replacement address
we substituted:

\begin{itemize}
\item The client code is using the same base address register as it was when
	we last intercepted a global variable access.  This might indicate that
	said code is using the register as an address accumulator, but doing
	so in concert with some other temporary register: because of this
	indirection, overwriting the register with the temporary after we
	had preformed the original address resolution would have left us
	unable to process any subsequent values accumulated into the register.
\item The base address register is different than the one updated on our last
	interception, but the value of the latter has
	remained unchanged since we updated it.  Because it contains a memory
	address we had to resolve, this strongly suggests that the client code
	has only executed a few instructions since then, which we can infer
	even if that set included one or more branch instructions.
\item The current return address points to the instruction immediately
	following the one that last faulted,
	and the current base address register's value has
	remained the same since the faulting instruction was executed.  This
	implies that said instruction was an indirect procedure call, and that
	the register was probably just used to pass a pointer argument.
	Because we didn't resolve the address of the indirect call until the
	client code was already transferring control, there was no way for it
	to have passed a pointer without performing arithmetic directly on the
	dummy address present before the call.
\end{itemize}

In our experience, these heuristics cover the common cases in compiler-generated
code.  We do not allow heuristics to chain (that is, we never use a
heuristically-calculated address as the basis of the offset calculation for another),
but we do apply heuristics multiple times based on the same base address.

While our current approach has proven successful, it does have some downsides.  It is
complex, relies on heuristics, and incurs a performance cost on the order of
microseconds.  It also suffers from a design flaw affecting large structures:\@ it
does not account for the size of globals when ``allocating'' them fake addresses
within the inaccessible memory region.  If a fake address gets assigned to a global
whose size is less than the difference between that address and the end of the
inaccessible region, it is possible for a correct program to dereference outside the
inaccessible region and exhibit emergent undefined behavior.  The ELF dynamic symbol
table includes objects' sizes, so it would be possible to account for this when
assigning fake addresses.

One could go further with this idea and redesign global variable interception without
the need for heuristics or the dependency on a disassembler.  By allocating each
global its own inaccessible region matching its real size, the address of the
faulting access could be made to reveal the access's offset within the global.
Mapping the fake address back to a symbol would require a lookup data structure; one
option is a hash table with an entry for each of our inaccessible pages.  To
translate a fake address, one would zero out its page offset bits, consult the lookup
structure to find our metadata about the page, and use this to convert to a real
symbol definition and offset within it.  This final conversion could be done either
by starting each global's fake region on a page boundary (at the cost of more virtual
memory) or binary searching a list of the addresses within the inaccessible page that
corresponded to the starts of new symbols\footnote{The faulting address would not be
found if the program was dereferencing at an offset into the global, but one would
just return the next-lowest entry.} (at the cost of logarithmic worst-case lookups
instead of constant average-case ones).


\section{Uninterruptible functions}

Unlike prior work, we support safe asynchronous pausing and cancellation on almost
almost any instruction boundary, including within most third-party libraries without
the need for configuration or code annotation.  However, there are still some cases
where we have to briefly defer preemption.

The most obvious is the \texttt{malloc()} family of dynamic memory allocation
functions.  This case is significant because the allocator manages the heap, a
resource shared among all threads of the application.  As we saw in
Chapter~\ref{chap:functions}, na\"ive attempts to provide asynchronous cancellation
often corrupt corrupt the heap if they interrupt the allocator.  It is even unsafe to
call into the allocator from a thread that has only been asynchronously paused while
allocating, as it can cause a deadlock on the locks intended to protect the heap from
concurrent access by different threads.  This is the reason why signal handlers are
not allowed to allocate memory.  One way around these problems would be to use a
separate heap for each preemptible function, but we have avoided this because it
would complicate the ownership of objects that are allocated by a preemptible
function but escape its scope before it terminates.

Instead, we consider the interfaces to the dynamic allocator to be
\textbf{uninterruptible} functions.  Although each libset contains a separate copy of
them, all except one are inactive.  Specifically, we route all calls to
uninterruptible functions back to the \textbf{starting libset}, the set of modules
loaded before \textit{libgotcha} loaded any additional copies.  The set of
uninterruptible functions is currently governed by an internal allowlist within
\textit{libgotcha}.  During load time, the constructor transcribes this information
into the shadow GOTs so lookups will incur no additional runtime overhead.

\begin{sloppypar}
Although the next libset does not determine which copy of an uninterruptible function
gets invoked, it is relevant during the call.  To avoid creating a dependency between
the starting libset and the current one, it is important that the next libset be set
to the starting libset while any uninterruptible code is running.  To ensure maintain
this invariant, whenever \texttt{procedure\_linkage\_override()} detects any libset
other than the starting one calling an uninterruptible function, it resets the next
libset to the starting libset, storing a backup of its previous value.  Then, just
before invoking the function, it pushes the address of a trampoline function onto the
stack.  When the function eventually returns, this trampoline runs; before
transferring control back to the call site, it restores the next libset.
\end{sloppypar}

In addition to controlling \textit{libgotcha}'s treatment of calls to uninterruptible
functions, the next libset also communicates valuable information to the control
library.  The starting libset always has to be valid, and because we maintain the
invariant that the next libset is always equal to the starting libset when the
current libset is, it is safe to preempt execution if and only if the starting libset
is not equal to the starting one.  It is crucial that the control library check this
before deciding to preempt, and as we saw in Listing~\ref{lst:gotchaapi}, it can do
so using the \texttt{libset\_thread\_get\_next()} function.


\subsection{Other uncopyable functions}

The memory allocator interfaces are not the only functions in the allowlist.  The
dynamic linker behaves specially with respect to namespaces:\@ although it appears to
be loaded into every namespace, it refuses to load additional copies of itself and
instead includes special logic that proxies calls to it from other namespaces back to
the main one.  If such calls were not considered nonpreemptible, the proxying would
change the current libset out from under \textit{libgotcha}, violating the invariant
that the next libset must equal the starting libset when the current one does.  To
avoid this, we add all of the dynamic linker's functions to the allowlist.

The dynamic linker introduces other complications as well.  While itself dependency
free, the GNU implementation is part of the glibc project, and other glibc modules
depend on it, including on internal interfaces that should not be exposed to the rest
of the program.  To keep these interfaces private, the dynamic linker does not export
them as dynamic symbols, and instead exposes them via an opaque data region whose
layout is partially known to the other glibc modules.  Fortunately, the region is
split into separate regions under the \texttt{\_rtld\_global\_ro} and
\texttt{\_rtld\_global} dynamic symbols based on whether the area is writeable, which
helps us determine whether a particular use has the potential to corrupt the dynamic
linker state.  In particular, we have allowlisted all the functions that access the
latter structure, a set currently consisting of \texttt{fork()},
\texttt{posix\_spawn()}, \texttt{uselocale()}, and
\texttt{\_\_cxa\_thread\_atexit\_impl()} from \texttt{libc.so} and
\texttt{pthread\_create()} from \texttt{libpthread.so}.  To flag potential breakage
from future changes in the region's use, \textit{libgotcha} emits a warning at load
time whenever it encounters an unexpected access to \texttt{\_rtld\_global}.

We have encountered one instance where a glibc module modifies
\texttt{\_rtld\_global} without a corresponding dynamic function call.  The
libpthread constructor monkey patches the dynamic linker to replace pointers to
stubbed-out mutex functions with its own proper implementation before the application
can spawn any POSIX threads.\footnote{It also installs hooks to support stack
execution protection and enable full support for thread-local variables.  As with the
mutex changes, these tweaks appear to replace stubbed placeholders rather than
establish information flow from the dynamic linker to the specific copy of
libpthread.}  These changes would create a hazardous dependency between the dynamic
linker and whichever copy of libpthread was last loaded (in our case, the one in the
last libset).  To avoid this problem, \textit{libgotcha}'s constructor checks for
libraries that (1) directly access \texttt{\_rtld\_global}, (2) have the type of
constructor in question, and (3) are marked with the ELF configuration flag
\texttt{DF\_1\_NODELETE} to indicate that they are unsafe to unload once present in
the process image.  Before loading copies of a library with all of these properties
into any libsets, we create a temporary copy of its shared library with its ELF
metadata tweaked to prevent the constructor from running.  We add these patched
libraries to the beginning of the search path so libsets do not modify the dynamic
linker at load time and it continues to depend on the copy of libpthread in the
starting libset.

In a few places, a glibc module asks the dynamic linker to load or unload another
shared library at runtime by calling the internal \texttt{\_dl\_open()} or
\texttt{\_dl\_close()} interface using a function pointer hidden in
\texttt{\_rtld\_global\_ro}.  The most obvious of these is the public-facing
functions in \texttt{libdl.so}, the same interface that \textit{libgotcha} uses to
populate libsets.  We considered adding all of this library's functions to the
allowlist, but this presents a problem:\@ in order to decide which namespace to load
the library into, \texttt{dlopen()} checks which module contains its return address.
Treating it as uninterruptible would result in a libset switch when calling it from
outside the starting libset, pushing a \textit{libgotcha} trampoline ``return''
address onto the stack and thereby causing all dynamically-loaded libraries to be
added to the starting libset instead of the current libset.  Other functions that
rely on the same mechanism include the \texttt{iconv()} family of
character-conversion functions, \texttt{getaddrinfo()} and the other DNS-translation
functions (which can load GNU Libidn to handle internationalized domain names), and
the modular Name Switch Service system for accessing the users, hosts, protocols,
and services databases.  Adding these functions to the allowlist would not break
them, but it would treat what are potentially long-running operations (even including
network communication) as nonpreemptible code.  We handle both of these situations by
replacing the \texttt{\_dl\_open()} and \texttt{\_dl\_close()} pointers in
\texttt{\_rtld\_global\_ro} with our own hook functions that transition to
uninterruptible code only while modules are being loaded or unloaded.  Since the
region is opaque and its region is subject to change, we find the appropriate
pointers by repeatedly replacing an entry with a probe function and executing no-op
\texttt{dlopen()} and \texttt{dlclose()} operations until the probe function gets
called.  Once we have found both pointers, we record their original values, mark
their containing page writeable, replace them with pointers to our hook functions,
and restore the page protections.


\subsection{Control library callbacks}

\begin{figure}
\begin{lstlisting}[label=lst:gotchacbapi,caption=\textit{libgotcha} C callback interface]
// Pointer to function taking and returning void
typedef void (*libset_cb_t)(void);

void libset_register_callback(libset_cb_t);
void libset_register_returnback(libset_cb_t);
libset_t libset_of_caller(void);
\end{lstlisting}
\end{figure}

While a control library can tell whether it is safe to preempt the thread by checking
whether its next libset is not equal to the starting libset, many control libraries
will benefit from active notification.  For this purpose, \textit{libgotcha} provides
a callback interface that allows the control library to register functions that
should be invoked whenever an uninterruptible function is called or returns.  These
can be used to disable and reenable preemption mechanisms or establish a critical
section around uninterruptible code (e.g., by taking a mutex or blocking signals).
Callbacks run when we automatically switch to the starting libset from any other;
since this change is idempotent, a callback is only invoked once at the beginning or
end of each uninterruptible region, even if the function calls others within the
starting libset.  Figure~\ref{fig:gotchahooks} shows the effect of such callbacks on
function call interception by comparing against both interruptible calls and
uninterruptible calls when no callbacks are registered.

\begin{figure*}
	\begin{minipage}{\textwidth}
	\includegraphics[width=\textwidth]{figs/calltree_function-crop}
	\subcaption{Interruptible call}
	\end{minipage}

	\begin{minipage}{\textwidth}
	\includegraphics[width=\textwidth]{figs/calltree_function_switch-crop}
	\subcaption{Uninterruptible call when no callbacks are registered}
	\end{minipage}

	\begin{minipage}{\textwidth}
	\includegraphics[width=\textwidth]{figs/calltree_function_hook-crop}
	\subcaption{Uninterruptible call when callbacks are registered for both calls and returns}
	\end{minipage}
\caption{Interception of cross-module function calls. Color indicates that the next libset is set to the starting libset.}
\label{fig:gotchahooks}
\end{figure*}

Listing~\ref{lst:gotchacbapi} shows the functions for managing callbacks, which form
an extension to the main \textit{libgotcha} control API.  The control library can
pass a function pointer to either of the registration functions to have it invoked on
entry to or exit from uninterruptible code.  In developing this interface, we
discovered it was very hard to write correct callbacks that could tolerate being
preempted, so we elected to run all callbacks with the next libset set to the
starting one.  Recall that it is never safe to pause or cancel execution in this
state, so the control library's preemption mechanism will defer preemption in
callbacks, just as it was already required to do in other such places.  Because the
control library's callback might want to know which libset control switched from, we
provide a \texttt{libset\_of\_caller()} function for retrieving the previous value of
the next libset (which is also the value it will be restored to when exiting the
uninterruptible region).

The way that we currently implement callbacks places some restrictions on what they
are allowed to do.  The \textit{libgotcha} assembly trampoline that invokes return
callbacks backs up the integer return registers, but such callbacks cannot use
floating points unless they manually save and restore the floating-point return
registers.  As an implementation shortcut, \texttt{procedure\_linkage\_override()}
invokes the call callback via a \texttt{SIGTRAP} handler by executing an
\texttt{int3} instruction, in order to avoid having to save and restore a large set
of registers itself (since the return registers account for only two of the many
caller-saved registers).  The signal occurs at a well-known point in execution (e.g.,
not in the middle of memory allocation), so it does not subject the callback function
to the usual safety constraints on signal handlers, but it does make this type of
callback orders of magnitude slower.  Fortunately, we anticipate rarer need for them;
\textit{libinger}, for example, only uses a return callback.

\begin{promotesubsections}
\input[functions]{gotcha_uncopyable}

\solb{\textbf{Subsection on callbacks with its own API listing}}

\solb{Must tie this into preemption}

\solb{Add the effects in the above TODO to the UML diagram?}

\solb{Stipulate that libgotcha itself is always uncopyable}

\solb{Say that the hook function runs in the interrupted module's namespace}

\solb{Mention pre-call hooks}

\solb{Give the limitations of each type of hook}

\solb{\textbf{Subsection on other uncopyable functions}}

\solb{Backdoors directly into the dynamic linker}

\solb{Monkey patching of ld.so and library header rewriting trick}

\solb{Interception of internal dynamic linker interfaces}

\solb{\textbf{Section More on control libraries}}

\solb{Types of control libraries from the frontmatter}

\solb{Address monomorphization}

\solb{\textbf{Subsection on thread-local storage}}

\solb{Diagram of thread-local data layout}

\solb{Reinitialization diagram (TLS part)}

\solb{Remove all uses of the term uncopyable}


\input[functions]{gotcha_tls}

\solb{Drop TLS stuff, incorporating whatever is salvageable earlier}

\input[functions]{gotcha_linker}

\solb{Recompiling glibc from the frontmatter}

\input[functions]{gotcha_relocations}
\end{promotesubsections}


\section{Evaluation}

\input[functions]{eval_ugotcha}

\input[functions]{eval_testbed}

\solb{Thread creation, TLS allocation, and libtlsblock}
