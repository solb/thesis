\section{Shared state: \textit{libgotcha}}
\label{sec:libgotcha}

We now present our third artifact, \textit{libgotcha}.
Despite the name, it is more like a runtime that isolates hidden shared state
within an application.  Although the rest of the
program does not interact directly with \textit{libgotcha}, its presence has a
global effect:\@ once loaded into the process image, it employs a technique we call
\textbf{selective relinking} to dynamically intercept and reroute many of the
program's function
calls and global variable accesses.

The goal of \textit{libgotcha} is to establish around every preemptible function a
memory isolation boundary encompassing whatever third-party libraries that function
interacts with (Section~\ref{sec:libinger:reentrancy}).  The result is that the only
state shared across the boundary is that explicitly passed via arguments,
return value, or closure---the same state the application programmer is responsible
for protecting from concurrency violations (Section~\ref{sec:libinger:concurrency}).
Listing~\ref{lst:exmplstate} shows the impact on an example program.

\begin{figure}
\begin{lstlisting}[label=lst:exmplstate,caption=Demo of isolated \textnormal{(1)} vs.\ shared \textnormal{(2\&3)} state]
static bool two;
bool three;

linger_t caller(const char *s, u64 timeout) {
  stdout = NULL;
  two = true;
  three = true;
  return launch(timed, timeout, s);
}

void timed(void *s) {
  assert(stdout); // (1)
  assert(two); // (2)
  assert(three); // (3)
}
\end{lstlisting}
\end{figure}

Note that \textit{libgotcha} operates at runtime, which constrains its visibility
into the program and therefore the granularity of its operation.  Because all static
relocations (e.g., between the object files and static libraries linked into the
program executable) have already been resolved at build time via the static linker,
they are invisible to \textit{libgotcha}.  This means it cannot protect an
application's use of nonreentrant static libraries:\@ from \textit{libgotcha}'s
perspective, interactions with such a library are indistinguishable from those with
any other part of the executable.  However, whenever a dynamic relocation is involved
(e.g., a function call or global variable access between runtime-loaded objects such
as the executable and shared libraries), \textit{libgotcha} can tell the nature of
the symbol access and may choose to redirect it.

Before introducing the \textit{libgotcha} API and explaining selective relinking, we
will now briefly motivate the need for libgotcha by demonstrating how existing system
interfaces fail to provide the isolation we require.


\subsection{Library copying: namespaces}

Expanding a preemptible function's isolation boundary to include libraries requires
providing it with private copies of those libraries.  POSIX has long provided a
\texttt{dlopen()} interface to the dynamic linker for loading shared objects at
runtime; however, opening an already-loaded library just increments
a reference count, and this function is therefore of no use for making copies.
Fortunately, the GNU dynamic linker (\texttt{ld-linux.so}) also supports
Solaris-style \textbf{namespaces}, or isolated sets of loaded libraries.  For each
namespace, \texttt{ld-linux.so} maintains a separate set of loaded libraries whose
dependency graph and reference counts are tracked independently from the rest of the
program~\cite{dlmopen-manpage}.

It may seem like namespaces provide the isolation we need:\@ whenever we
\texttt{launch(\textnormal{\textit{F}})}, we can initialize a namespace with a copy
of the whole application and transfer control into that namespace's copy of
\textit{F}, rather than the original.  The problem with this approach is that it
breaks the lexical scoping of static variables.  For example,
Listing~\ref{lst:exmplstate} would fail assertion (2).

\solb{THESIS: Cover the algorithm for identifying GOT entries that correspond to
cross-library symbols.}


\subsection{Library copying: libsets}

We just saw that namespaces provide too much isolation
for our needs:\@ because they have completely independent dependency graphs, they
never encounter any state from another namespace, even according to normal scoping
rules.  However, we can use namespaces to build the abstraction we need, which we
term a \textbf{libset}.  A libset is like a namespace, except that the program can
explicitly control whether symbols referenced within a libset resolve to the same
libset or a different one.  Libraries such as \textit{libinger} configure such
\textbf{libset switches} via \textbf{libgotcha}'s private control API, shown
in Listing~\ref{lst:gotchaapi}.

\begin{figure}
\begin{lstlisting}[label=lst:gotchaapi,caption=libgotcha C interface]
typedef long libset_t;

bool libset_thread_set_next(libset_t);
libset_t libset_thread_get_next(void);
bool libset_reinit(libset_t);
\end{lstlisting}
\end{figure}

This abstraction serves our needs:\@ when a
\texttt{launch(\textnormal{\textit{F}})} happens, \textit{libinger} assigns an
available \texttt{libset\_t} exclusively to that preemptible function.  Just before
calling \textit{F}, it informs \textit{libgotcha} by calling
\texttt{libset\_thread\_set\_next()} to set the thread's \textbf{next libset}:\@ any
dynamic symbols used by the preemptible function will resolve to this libset.  The
thread's \textbf{current libset} remains
unchanged, however, so the preemptible function itself executes from the same libset
as its caller and the two share access to the same global variables.

One scoping issue remains, though.  Because dynamic symbols can resolve back
to a definition in the same executable or shared object that used them,
Listing~\ref{lst:gotchaapi} would fail assertion (3) under the described rules.
We want global variables defined in \textit{F}'s object file to have the same scoping
semantics regardless of whether they are declared \texttt{static}, so
\textit{libgotcha} only performs a namespace switch when the use of a dynamic symbol
occurs in a different executable or shared library than that symbol's definition.


\subsection{Managing libsets}

At program start, \textit{libgotcha} initializes a pool of libsets, each with a full
complement of the program's loaded object files.  Throughout the program's run
\textit{libinger} tracks the libset assigned to each preemptible function that has
started running but not yet reached successful completion.  When a preemptible
function completes, \textit{libinger} assumes it has not corrupted its libset and
returns it to the pool of available ones.  However, if a preemptible function
is canceled rather than being allowed to return, \textit{libinger} must
assume that its libset's shared state could be corrupted.  It unloads and reloads
all objects in such a libset by calling \texttt{libset\_reinit()}.

\solb{THESIS: Can we (re)initialize libsets more efficiently than that (e.g., by
restoring only their writable sections)?}

While libinger in principle runs on top of an unmodified \texttt{ld-linux.so}, in
practice initializing more than one namespace tends to exhaust the
statically-allocated thread-local storage area.  We work around this by rebuilding
glibc with an increased \texttt{TLS\_STATIC\_SURPLUS}.  It is useful to also raise
the maximum number of namespaces by increasing \texttt{DL\_NNS}.

\solb{THESIS: Explain the trouble with COPY relocations and the need to use
\texttt{-fpic} as a workaround, ideally showing the performance ramifications
(e.g., via the nginx experiment).}

\solb{THESIS: Cover the \texttt{NODELETE} flag, ld.so monkey patching, and the
library header rewriting trick I use to circumvent the issue.}

\solb{THESIS: Describe (and hopefully even address) the monomorphization problem.}


\subsection{Selective relinking}

Most of the complexity of \textit{libgotcha} lies in the implementation of selective
relinking, the mechanism underlying libset switches.

Whenever a program uses a dynamic symbol, it looks up its address in a data structure
called the Global Offset Table (GOT).  As it loads the program, \texttt{ld-linux.so}
eagerly resolves the addresses of all global variables and some functions and stores
them in the GOT\footnote{Some other functions are instead resolved lazily at their
first invocation.}.

Selective relinking works by shadowing the GOT\footnote{Hence the name
\textit{libGOTcha}.}.  As soon as \texttt{ld-linux.so} finishes populating
the GOT, \textit{libgotcha} replaces every entry that should trigger a libset switch
with a fake address, storing the original one in its shadow GOT, which is organized
by the libset that houses the definition.  The fake address used depends upon the
type of symbol:

\solb{THESIS: Draw a diagram explaining our custom tables and the series of lookups
performed by \texttt{procedure\_linkage\_override()}.}

\solb{THESIS: Talk about PLOTs and pointer comparison.}

Functions' addresses are replaced by the address of a special function,
\texttt{procedure\_linkage\_override()}.  Whenever the program tries to call one of
the affected functions, this intermediary checks the thread's next libset, looks up
the address of the appropriate definition in the shadow GOT, and jumps to it.
Because \texttt{procedure\_linkage\_override()} runs between the caller's
\texttt{call} instruction and the real function, it is written in assembly to avoid
clobbering registers.

\solb{THESIS: Cover trick for defeating lazy PLT relocations' memoization.}

Global variables' addresses are replaced with a unique address within a mapped but
inaccessible page.  When the program tries to read or write such an address, a
segmentation fault occurs; \textit{libgotcha} handles the fault, disassembles the
faulting instruction to determine the base address register of its address
calculation\footnote{Although it is possible to
generate code sequences that are incompatible with this approach (e.g., because they
perform in-place pointer arithmetic on a register rather than using displacement-mode
addressing with a base address), we employ a few heuristics based on the context of
the instruction and fault; in our experience, these cover the common cases.},
loads the address from this register, computes the location of the
shadow GOT entry based on the fake address, checks the thread's next libset, and
replaces the register's contents with the appropriate resolved address.  It then
returns, causing the faulting instruction to be reexecuted with the valid address
this time\footnote{This does not break applications with existing segfault
handlers:\@ we intercept their calls to \texttt{sigaction()}, and forward the signal
along to their handler whenever we are unable to resolve an address ourselves.}.

\solb{THESIS: Give more details on global variable interpositions, especially
heuristics.}


\subsection{Uninterruptible code}

The library-copying approach to memory isolation works for the common case, and
allows us to handle most third-party libraries with no configuration.  However, in
rare cases it is not appropriate.  The main example is the \texttt{malloc()} family
of functions:\@ in Section~\ref{sec:intro}, we observed that not sharing a common
heap complicates ownership transfer of objects allocated from inside a preemptible
function.  To support dynamic memory allocation and a few other special cases,
\textit{libgotcha} has an internal whitelist of \textbf{uninterruptible} symbols.

From \textit{libgotcha}'s perspective, uninterruptible symbols differ only in what
happens on a libset switch.  If code executing in any libset other than the
application's \textbf{starting libset} calls an uninterruptible symbol, a libset
switch still occurs, but it returns to the starting libset instead of the next
libset; thus, all calls to an uninterruptible symbol are routed to a single,
globally-shared definition.  When the function call that caused one of these special
libset switches returns, the next libset is restored to its prior value.  The
\textit{libgotcha} control API provides one more function,
\texttt{libset\_register\_interruptible\_callback()}, that allows others to request
a notification when one of these libset restorations occurs.

Because it is never safe to preempt while executing in the starting libset, the
first thing the \textit{libinger} preemption handler described in
Section~\ref{sec:libinger:signals} does is check whether the thread's next libset
is set to the starting one; if so, it disables preemption interrupts and immediately
returns.  However, \textit{libinger} registers an interruptible callback that it uses
to reenable preemption as soon as any uninterruptible function returns.

\solb{THESIS: Draw a figure depicting what happens w.r.t. the current libset,
preemptibility, and the notification callbacks when a preemptible function calls
an uninterruptible function (say, malloc()).}


\subsection{Case study: auto async-signal safety}

We have now described the role of \textit{libgotcha}, and how \textit{libinger} uses
it to handle nonreentrancy.  Before concluding our discussion, however, we note that
\textit{libgotcha} has other interesting uses in its own right.

As an example, we have used it to implement a small library, \textit{libas-safe},
that transparently allows an application's signal handlers to call functions that
are not async-signal safe, which is forbidden by POSIX because it is normally unsafe.

Written in 127 lines of C, \textit{libas-safe} works by injecting code before
\texttt{main()} to switch the program away from its starting libset.  It shadows
the system's \texttt{sigaction()}, providing an implementation that:
\begin{itemize}
\item Provides copy-based library isolation for signal handlers by switching the
	thread's next libset to the starting libset while a signal handler is running.
\item Allows use of uninterruptible code such as \texttt{malloc()} from a signal
	handler by deferring signal arrival whenever the thread is already executing
	in the starting libset, then delivering the deferred signal when the
	interruptible callback fires.
\end{itemize}

In addition to making signal handlers a lot easier to write, \textit{libas-safe} can
be used to automatically ``fix'' deadlocks and other misbehaviors in misbehaved
signal-handling programs just by loading it via \texttt{LD\_PRELOAD}.

We can imagine extending \textit{libgotcha} to support other use cases, such as
simultaneously using different versions or build configurations of the same library
from a single application.

\solb{THESIS: Walk through example(s) of programs that are automatically repaired by
\textit{libas-safe}.}

\solb{THESIS: Explore \textit{libac-safe} idea?}

\solb{THESIS: Use \textit{libas-safe} to prototype a library that enables safe signal
handling in Rust.}

\solb{THESIS: It's been suggested that \texttt{libgotcha} could let you switch
between multiple versions of the same library (e.g., different revisions, feature
sets, or even release vs. debug).  This probably merits additional thought.}

\solb{THESIS: Another possible use for (an enhanced) \textit{libgotcha} is some kind
of scary runtime aspect-oriented programming thing (i.e., a generalization of
ltrace).}
