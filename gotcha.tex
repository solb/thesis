\chapter{Nonreentrancy and selective relinking: \\ the \textit{libgotcha} runtime}
\label{chap:libgotcha}

\ifdefined\chapquotes
\vspace{-1in}
\begin{chapquote}[1.5in]{James S.\@ A.\@ Corey, \textit{Nemesis Games}}
`Alien superweapons were used,' Alex said, walking into the room, \\
sleep-sweaty hair standing out from his skull in every direction. \\
`The laws of physics were altered, mistakes were made.'
\end{chapquote}
\fi

In Section~\ref{sec:libinger:reentrancy}, we saw that it is not safe in general for a
preemptible function to call into stateful code that was written without the
preemptible function abstraction in mind.  However, such code is prolific in the
modern systems stack, and in order to support interoperability with it, we need to
automatically transform the program to fix the safety hole.  This chapter covers a
novel software system designed to do just that, dubbed \textit{libgotcha}.

\begin{figure}
\begin{center}
\includegraphics[width=0.7\columnwidth]{figs/procimg_perobj}
\end{center}
\caption{Layout of a typical module within the process image.  \textbf{Bold} sections
contain program data; \textit{italicized} ones contain metadata for the runtime.}
\label{fig:procimgobj}
\end{figure}

\begin{promotesubsections}
\begin{swallowsections}
\input[functions]{gotcha_gotcha}
\end{swallowsections}
\end{promotesubsections}
\hspace{-2.5em}
Our discussion in this chapter uses \textit{libinger} as a motivating example of a
\textit{libgotcha} user, as this configuration was the inspiration for the runtime's
creation.  However, we have found that the described techniques to be general and
equally relevant to applications besides timed functions.  As such,
\textit{libgotcha} exposes a general API that allows any \textbf{control library} to
configure its behavior for the process.  We give more details later in the chapter,
and study other examples of control libraries in Chapter~\ref{chap:safety}.


\section{A brief tour of linking}
\label{sec:libgotcha:link}

We begin with background about linking, a two-stage process that ultimately produces
an in-memory \textbf{process image} containing a program's code, all the data it
needs to execute, and the code and data of all its dependencies.  Linking operates on
\textbf{object files} that can take the form of either an \textbf{executable} or a
\textbf{shared library}.  Once a program is running, its process image contains a
region corresponding to each loaded object file.  We will refer to each such region as
a \textbf{module}, regardless of whether it corresponds to an executable or a shared
library.  Each module is divided into logical \textbf{sections}, each containing a
particular type of information.  Figure~\ref{fig:procimgobj} shows a typical module's
layout; notice that it contains both data corresponding to the source code and
generated metadata for runtime consumption.

The linking process occurs in two parts.  Static linking occurs at compile time and
forms the last step of the traditional build process.  Dynamic linking occurs at a
phase of runtime we will refer to as \textbf{load time}, because it starts before the
program has been loaded from disk or the language runtime initialized.


\subsection{Static linking}

Invoking the \texttt{cc} compiler driver does more than just compile C code:\@ it
runs the C preprocessor \texttt{cpp}, the C compiler (\texttt{cc1} in GCC's case),
then the static linker \texttt{ld}.

The output of the second step is a relocatable object file containing code and data
with referenced addresses identified by named \textbf{symbols}.  In a relocatable
object file, symbol \textbf{references} such as instructions making function calls
or accessing global variables are encoded with a null address as a placeholder.  Each
object file contains a \textbf{relocation table} in a separate section that
associates each placeholder with a symbol name, which may or may not be located in
the same file.  Each object file also contains a \textbf{symbol table} to identify
the symbols it defines and associate them with the file offset of their definition.
Note that only non-\texttt{static} C symbols generate global symbol table entries
that can be referenced from other object files; this keyword is confusingly named and
does not refer to static linking.  The compiler's ultimate output is one relocatable
object file for each source file.

The static linker is responsible for combining one or more relocatable object files
into a single executable or shared library, where either type of output file is
ready for loading into memory for execution.  This process consists of verifying that
there is a definition corresponding to each symbol reference, unifying the sections
across object files and choosing a final address (or relative address) for each
symbol, encoding the chosen addresses at the location recorded in each relocation
table entry, and writing the resulting file to disk.  This output file does not
preserve the relocation table because the linker has already fixed the null pointers
it described.  The file does contain a symbol table because it can be useful for
debugging (e.g., to generate stack traces), but this can be removed using the
\texttt{strip} utility without affecting the program semantics.

With the exception of macOS, most modern Unix systems use ELF (Executable and
Linkable Format) object files.  One advantage of this format is that executables and
shared libraries are themselves ELF object files.


\subsection{Dynamic linking}
\label{sec:libgotcha:dylink}

Static linking allows programs to reuse ``libraries'' of precompiled object files,
but each program must be built with its own copy of all its libraries within the
executable.  This means that every time an application is loaded, its libraries' code
and data must be read back from disk, even if another running program uses the same
libraries; it also means that updating a library requires recompiling all dependent
programs installed on the system.  Dynamic linking solves both problems by separating
libraries into separate files that are not read until the executable runs.\footnote{
Specifically, this separation obviates the need to read the files from disk multiple
times because the runtime maps them into the process image using the \texttt{mmap()}
family of system calls.  The kernel tracks regions that are already mapped and serves
recurring requests from memory instead of disk, mapping to the same physical memory
if the pages are read-only or creating copy-on-write page mappings otherwise.}

By splitting libraries into their own files, dynamic linking introduces a build-time
challenge:\@ the relative position and offset of modules cannot be known until
runtime.  As such, rather than performing the relocations for inter-module symbol
references, the static linker leaves the placeholder addresses and adds a separate
dynamic relocation table and dynamic symbol table into the output object file.
Unlike the tables used for static linking, these are needed to launch the program, so
tools such as \texttt{strip} leave them in place.  For executables, the linker also
writes the path to an ``interpreter'' program into the ELF program header.

When asked to load a program that declares an interpreter, the kernel loads and jumps
to the interpreter instead of the executed program.  Usually, this interpreter is the
system \textbf{dynamic linker}, traditionally named \texttt{ld.so}.  Before jumping
into the program code, the dynamic linker loads all the modules and processes the
entries in each of their dynamic relocation tables.  The relocations are not
restricted to modifying writeable memory:\@ they can update constant global data and
even executable instructions.  Even if they leave the code unchanged, its position
relative to the rest of the module matters.  These points are critical to our use
case, as they mean that in order to duplicate modules' data, we must also duplicate
their code.

Another consequence of relocations being able to alter read-only memory is that the
dynamic linker must change the page protections of these regions after it is finished
processing relocations.  To support this, the compiler splits up module components
into fine-grained sections by purpose.  Non-\texttt{const} global variables are
placed in the \texttt{.data} and \texttt{.bss} sections, which must remain writeable
at runtime and therefore require no special action.  In contrast, \texttt{const}
globals are split between the \texttt{.rodata} and \texttt{.data.rel.ro} sections
based on whether they require relocation; in the latter case, the dynamic linker
marks the pages read-only before passing control to the program.

If relocations routinely modified scattered locations throughout the executable
\texttt{.text} section, the dynamic linker would have to change page protections on
most or all of each module's code pages.  This would require a lot of system calls,
but it would also require copy-on-write code mappings, preventing instruction cache
hits between processes using the same library.  To avoid these problems, the compiler
indirects references to dynamic symbols via a structure called the GOT (Global Offset
Table).

\begin{figure*}
\begin{minipage}{\textwidth}
	\includegraphics[width=\textwidth]{figs/gotables-crop}
	\subcaption{Reading a library's global variable: \texttt{size\_t tmp = data;}}
	\label{fig:dytabs:got}
	\end{minipage}

	\begin{minipage}{\textwidth}
	\includegraphics[width=\textwidth]{figs/pltables-crop}
	\subcaption{Calling an eagerly-resolved library function: \texttt{fun()}}
	\label{fig:dytabs:plt}
	\end{minipage}

	\begin{minipage}{\textwidth}
	\includegraphics[width=\textwidth]{figs/jstables-crop}
	\subcaption{Calling a lazily-resolved library function.  In step \textcircled{5},
	the dynamic linker memoizes the resolved address into the GOT; subsequent calls
	proceed as above.}
	\label{fig:dytabs:lazy}
	\end{minipage}
\caption{Table references required to reference global symbols in dynamically-linked
programs}
\label{fig:dytabs}
\end{figure*}

The GOT is a table of relocated pointers to symbol definitions, whether those
definitions are within the same module or in a different one.  To avoid generating
code pages that require relocations, the compiler compiles each reference to or
dereference of non-\texttt{static} global data into a position-independent load of
the corresponding pointer from the GOT.  Figure~\ref{fig:dytabs:got} shows an example
of the two instructions and one table reference needed for a dereference.  A
reference would generate only the first \texttt{mov} instruction, as would taking a
pointer to a function.

Calling a global function works differently and relies on another indirection
structure called the PLT (Procedure Linkage Table), which contains code instead of
pointers.  For each call to a non-\texttt{static} function, the compiler generates a
position-independent call to a PLT entry corresponding to the function being called.
It generates a PLT entry, which is a short sequence of instructions that loads the
pointer to the real definition from the GOT, then executes and indirect jump to that
location.  Figure~\ref{fig:dytabs:plt} shows an example function call.  As with GOT
entries, there are PLT entries for functions defined both within and outside the
referencing module.

Not all function calls are this simple.  To save the dynamic linker some work at load
time, many function calls resolve lazily on their first execution.  Such resolution
involves a series of jumps designed to memoize the address so that subsequent calls
to the function from the same module do not repeat the expensive lookup.
Figure~\ref{fig:dytabs:lazy} shows the effect of the first call to such a
function:\footnote{This representation is slightly simplified for brevity.  In
practice, it is undesirable to hardcode the address of a dynamic linker function into
each module.  Therefore, instead of jumping directly to the symbol resolver, the slow
lookup path jumps to a dedicated PLT stub that loads its address from another GOT
entry.  Technically, there are separate identifiers for the symbol and the module,
each pushed to the stack by one of these two involved PLT stubs.}  \textcircled{1}
The program calls the PLT stub, just as it would for an eagerly-resolved function.
\textcircled{2} The PLT stub is longer (three instructions instead of one), but still
begins with an indirect jump to the pointer found in the corresponding GOT entry.
\textcircled{3} The GOT entry initially contains the address of the PLT stub's second
instruction, so the indirect jump is a no-op and merely advances the instruction
pointer.  \textcircled{4} The rest of the PLT stub pushes a constant identifying the
module and symbol onto the stack, then jumps to a symbol-lookup function in the
dynamic linker.  \textcircled{5} After looking up the address of the symbol's
definition, the dynamic linker uses the identifier from the stack to find and update
the GOT entry in the calling module.  \textcircled{6} The dynamic linker jumps to the
symbol in the defining module.  Because the GOT entry has been updated, future calls
proceed exactly like eagerly-resolved ones and jump directly to the symbol definition
from the first instruction of the PLT stub.  Of course, the GOT entries associated
with lazy PLT stubs must be writeable at runtime; this is why
Figure~\ref{fig:procimgobj} shows the GOT as split between two sections.

The dynamic linker performs all relocations and other standard module setup
automatically at load time, but the initialization process is pluggable.  In
particular, modules can include \textbf{constructor} functions to be invoked before
control is transferred to the runtime and ultimately the program's main function.  As
we will see, our work leverages this feature to override certain relocations at the
conclusion of load time.


\begin{promotesubsections}
\begin{swallowsections}
\input[functions]{gotcha_namespaces}


\input[functions]{gotcha_libsets}

Thus, selective relinking is selective in two ways, only affecting execution when the
next libset differs from the current libset and the program references a dynamic
symbol defined in a module that is not currently executing on that thread.

\solb{Expand interface listing and add comments with section references}
\end{swallowsections}
\end{promotesubsections}


\subsection{Detecting cross-module symbol references}

Identifying which GOT entries correspond to cross-module symbol references is a
multi-step process:
First, we traverse the relocation table for each loaded module, cross referencing
each of its relocation entries against the local module's symbol table.  If the
symbol table does not contain a definition matching the relocation entry's target, we
conclude that the relocation must correspond to a cross-module call.  Otherwise, we
check the address in the GOT entry corresponding to the relocation:  If this address
is outside the memory bounds of the current module, it is a cross-library call.
Otherwise, if this address matches the one from the symbol table entry, it is not a
cross-library call, and should be skipped.  The trickiest case is when the GOT entry
does not match but does point somewhere within the current module, since this means
it probably still refers to the PLT stub (because the symbol reference is lazy and
has not yet been resolved, as covered at the end of
Section~\ref{sec:libgotcha:dylink}).  In this case, we resolve the symbol early,
update the GOT entry, and recheck whether it resolved to the local definition to
determine whether it is a cross-module call.


\begin{promotesubsections}
\begin{swallowsections}
\input[functions]{gotcha_init}

If a preemptible function is canceled rather than being allowed to return, execution
might be interrupted within a call to a library function.  For this reason,
\textit{libgotcha} must treat the libset's shared state as corrupted; it provides the
\texttt{libset\_reinit()} function shown in Listing~\ref{lst:gotchaapi} to allow
control libraries to inform it of such a situation so it can \textbf{reinitialize}
the libset before returning it to the pool.

Our early approach to reinitialization was to unload and reload all objects in the
libset by calling \texttt{dlclose()} followed by \texttt{dlmopen()}.  While this
approach theoretically allowed us to delegate the work to the dynamic linker, in
practice it introduced significant complications.\footnote{Most notably, some shared
libraries are marked with a special configuration flag, \texttt{DF\_1\_NODELETE},
which prevents the dynamic linker from ever removing them once they have been loaded.
Because almost all libraries depend on libc, the presence of even one such library
would prevent us from reinitializing a libset.  The flag is mostly used on libraries
that need to monkey-patch some other loaded library, such that the two subsequently
have a circular dependency.  Fortunately, this was not generally a problem for us
because when we unload one library from a libset, we then unload the rest.  Whenever
we encountered a \texttt{NODELETE} object file, we would make a special copy with the
flag cleared, for loading into every namespace except the main one.}  Worse, it
required the dynamic linker to reprocess all relocations throughout the libset, which
introduced prohibitive runtime latency.  We measured reinitialization taking almost 5
ms (over 10 million cycles on modern processors) on even small minimal example
programs~\cite{boucher:atc2020}.  With such delays, the only reasonable way for the
control library to handle cancellation was to delegate the reinitialization to a
separate thread to take it off the critical path; of course, this approach only works
as long as the number of libsets is not a bottleneck.

We have since redesigned reinitialization around a significantly faster approach:\@
checkpointing only portions of each module.  The key insight is that, as we saw in
Section~\ref{sec:libgotcha:link}, only some sections are writeable at runtime.  We
can therefore assume that these are the only memory regions of each module that can
change.  After populating the libset pool at application start, \textit{libgotcha}
iterates through each module of each libset and makes a backup copy of all its
writeable regions.  When a control library calls \texttt{libset\_reinit()},
\textit{libgotcha} restores each such region from the backup before returning the
affected libset to the pool.  We summarize this approach, which has reduced the
latency of reinitialization by two orders of magnitude, in
Figure~\ref{fig:reinit}.\footnote{We will address the version watermark alluded to
therein later in this chapter.}  To avoid having to repeat relocations and rerun any
module constructors, we capture the backup after dynamic relocation is complete and
all constructors have run; the tradeoff is that we actually have to copy memory,
rather than leveraging copy on write to later restore to the version on disk.

\begin{figure}
\includegraphics[width=\columnwidth]{figs/reinit-crop}
\caption{Libset reinitialization to support asynchronous cancellation}
\label{fig:reinit}
\end{figure}


\input[functions]{gotcha_goot}

\solb{\textbf{Subsections?}}

\input[functions]{gotcha_plot}
\hspace{-1.5em}
\input[functions]{gotcha_lazy}

\solb{Rewrite this now that we already describe lazy relocations earlier}

\input[functions]{gotcha_globals}

\solb{\textbf{Subsection on thread-local storage}}

\solb{Diagram of thread-local data layout}

\solb{Reinitialization diagram (TLS part)}


\input[functions]{gotcha_uncopyable}

\solb{Add the effects in the above TODO to the UML diagram?}

\solb{Stipulate that libgotcha itself is always uncopyable}

\solb{Say that the hook function runs in the interrupted module's namespace}

\solb{Mention pre-call hooks}

\solb{Give the limitations of each type of hook}

\solb{\textbf{Section More on control libraries}}

\solb{Types of control libraries from the frontmatter}

\solb{Address monomorphization}

\solb{Monkey patching of ld.so and library header rewriting trick}


\input[functions]{gotcha_tls}

\solb{Drop TLS stuff, incorporating whatever is salvageable earlier}

\input[functions]{gotcha_linker}

\solb{Recompiling glibc from the frontmatter}

\input[functions]{gotcha_relocations}

\end{swallowsections}
\end{promotesubsections}


\section{Evaluation}

\input[functions]{eval_ugotcha}

\input[functions]{eval_testbed}

\solb{Thread creation, TLS allocation, and libtlsblock}
