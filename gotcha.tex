\section{Shared state: \textit{libgotcha}}
\label{sec:libgotcha}

\solb{Replace the term ``whitelisted'' with ``uninterruptible.''}

\subsection{Principle}

This brings us to unaware code, and the purpose of libgotcha.  This library employs
a technique we call \textbf{selective relinking} to redirect at runtime each use of a
function or global variable from outside the current object file\footnote{Whenevee we
refer to an object file, we mean specifically a relocated object file (i.e.,
executable or dynamic shared library); that is, one that is loaded into the process's
memory image.} to one of numerous possible copies.  Depending on the symbol accessed,
libinger uses libgotcha to accomplish one of two things:  In the common case, it
gives each preemptible function its own copy of the symbol, complete with its own
shared state.  Although this approach works for many libraries, it is sometimes
inappropriate; for instance, using multiple copies of the dynamic allocator would
cause them to manage the same heap with different free lists.  In such cases, it
instead defers preemption until the function call into the library returns.

The libgotcha API, show in Listing~\ref{lst:gotchaapi}, is based on something we term
a \textbf{libset}, which is a full copy of the program's set of loaded
libraries\footnote{Technically, a libset also includes the executable, which is
needed in case one of the application's libraries uses preemptible functions that use
symbols from the executable file.}.  Every program has a \textbf{main libset} (the
program itself, as originally loaded), and libgotcha may open any number of
additional libsets.  Users of libgotcha may explicitly reinitialize a libset, closing
all its object files then reopening them to prepare for fresh use.  While execution
is within one libset, it remains there until directed to change via one of two
explicit mechanisms.

\begin{figure}
\begin{lstlisting}[label=lst:gotchaapi,caption=libgotcha C interface]
typedef long libset_t;

libset_t libset_new(void);
bool libset_reinit(libset_t);

// Returns previously-selected libset
bool libset_thread_set_current(libset_t);
libset_t libset_thread_get_current(void);

void libset_register_whitelist_callback(void (*)(void)):
\end{lstlisting}
\end{figure}

Each thread has an attribute called the \textbf{current libset} that controls which
libset symbol uses are redirected to.  This does not determine the libset from which
the current code is being executed, but rather the libset that will be used to
provide any function or global variable defined external to the current object file.
One way to move between libsets is to change the current libset, then use such a
symbol.

The other mechanism for changing libsets is a \textbf{whitelist} of symbols (such as
the dynamic allocator) that should share a single definition throughout the entire
application.  Whenever a global variable from this list is accessed, libgotcha serves
the definition from the main libset.  Whenever a function from the list is called,
libgotcha automatically changes the thread's current libset to the main one before
performing the call, then restores its original value as soon as the function
returns.  Users of libgotcha can optionally install a callback function to be
notified whenever the whitelist causes the current libset to change.

One activates the functionality of libgotcha simply by linking against it:\@ once
loaded into the process image, it immediately instruments the boundaries between
object files.  The libinger shared library is statically linked against
libgotcha\footnote{The attentive reader will notice that both libgotcha and libinger
contain shared state (the current libset and thread preemption signal, respectively).
To handle this, libgotcha automatically adds all the symbols defined by its own
object file to the whitelist.  By statically linking to it, libinger gains this same
protection.} so that the latter is active in any program using preemptible functions.
Execution will not, of course, leave the main libset until such an action is
requested via libgotcha's API.

Use of this API by libinger is straightforward.  The \texttt{launch()} function
allocates a new libset by either using an unused one, reusing one from a preemptible
function that ran to completion, or reinitializing one from a preemptible function
that was canceled prematurely\footnote{We assume that any canceled preemptible
function has left its libset in an undefined state.  While libinger currently
performs libset reinitialization synchronously, this somewhat costly step could be
moved off the critical path by assigning a separate reaper thread.}.  It installs
this as the current libset just before enabling preemption.  Right after checking
whether the received signal was intended for the current thread, the preemption
signal handler checks the thread's current libset; in the case of the main one
(indicating the preemptible function is currently in whitelisted code), it blocks the
preemption signal and immediately returns, effectively deferring
preemption\footnote{When whitelisting the dynamic allocator, it is important not to
whitelist all of libc as collateral damage, since preemptible functions could easily
exploit this to run forever (e.g., by performing their work in the \texttt{qsort()}
function's comparator callback).  Fortunately, libc uses dynamic calls when it needs
to invoke the allocator internally, allowing us to whitelist that component alone.}.
The deferral is not indefinite:\@ libinger uses libgotcha's callback mechanism to
both call the handler and unblock the signal as soon as the function returns.

\solb{THESIS: Draw a figure depicting what happens w.r.t. the current libset,
preemptibility, and the notification callbacks when a preemptible function calls
an uninterruptible function (say, malloc()).}

\subsection{Mechanics}

The rest of this section covers the implementation of libgotcha, which isolates
shared state at the granularity of object files by intercepting many dynamic function
calls and global variable accesses.  To accomplish this, it must collect all uses of
dynamic symbols, discriminate between intra- and \textbf{cross-library} uses of those
symbols, and interpose cross-library uses by shadowing the existing structures that
support dynamic symbol resolution.  The libgotcha library includes a constructor that
gets invoked by the dynamic linker after all shared libraries have been loaded but
before the call to \texttt{main()}:\@ the aforementioned steps are performed here so
interposing is already active by the time control is transferred to the application.

\paragraph{Just enough dynamic linking}

\solb{Define GOT\footnote{It is this structure that gives \textit{lib\textbf{got}cha}
its name.}}

\paragraph{Implementing libsets}

When a dynamically-linked application is run, the kernel first passes control to the
dynamic linker, which reads its shared library dependencies\footnote{The dependency
list is found in the executable's ELF headers, alongside other dynamic linking
metadata such as the relocation table.}.  It then loads these libraries into the
process image, repeats with
\textit{their} dependencies, and so on.  The linker also provides a \texttt{dlopen()}
that can be used to load additional shared object files at runtime.  The GNU dynamic
linker extends this interface with the Solaris concept of namespaces, each of which
represents an independent dependency graph of loaded
libraries~\cite{dlmopen-manpage}.  It is this feature upon which we build the libset
abstraction, which extends this notion of duplicate copies of a library to allow one
namespace's use of a symbol to resolve to a definition in a different namespace.

\paragraph{Identifying cross-library symbol uses}

It is important to realize that dynamic calls and references are resolved based on
the name of a symbol, which may be ambiguous between multiple libraries within the
same namespace; as such, the library associated with each dynamic relocation is not
determined until runtime.  In fact, a dynamic relocation might even resolve back to
the same object file that contains it; this is most common when a shared library
makes an internal reference to one of its own public interfaces (since the
application might replace that public interface with its own implementation or one
from a different library).  Note that other internal references within such a shared
library are linked statically, leaving no way to locate them at runtime.  In order to
provide consistent semantics, we only instrument cross-library variable
references and function calls, where the use and definition occur in different object
files.

Identifying which GOT entries correspond to cross-library symbol uses
is is a multi-step process:
First, we traverse the relocation table for each loaded object file, cross
referencing each of its relocation entries against the local object file's symbol
table.  If the symbol table does not contain a definition matching the relocation
entry's target, we conclude that the relocation must correspond to a cross-library
call.  Otherwise, we check the address in the GOT entry corresponding to the
relocation entry:  If this address is outside the bounds of the current object file,
it is a cross-library call.  Otherwise, if this address matches the one from the
symbol table entry, it is not a cross-library call, and should be skipped.  The last
case is the trickiest, since the GOT entry probably still refers to the PLT stub
(because the symbol reference has not yet been resolved).  In this case, we resolve
the symbol
early, update the GOT entry, and recheck whether it resolved to the local definition
to determine whether it is a cross-library call.

\paragraph{Intercepting cross-library calls}

Dynamic linking gives us a powerful tool for intercepting cross-library function
calls:\@ each PLT entry already executes by branching to an address stored in the
GOT, so the libgotcha constructor has only to change the latter to one of its own
functions, and any calls through that PLT entry will be sent to libgotcha instead.

The constructor allocates one or more executable pages full of custom PLT-like
stubs, which we refer to as the \textbf{procedure linkage override tables (PLOTs)}.
Each PLOT is associated with one \textbf{shadow GOT} for each namespace:\@ when a
particular PLOT stub is executed, it pushes an index to the stack and calls a
function, \texttt{procedure\_linkage\_override()}, that decides which libset the call
should target, locates the corresponding shadow GOT, and transfers control to the
address listed at the appropriate index in that table.  (Because this function
is injected into the "middle" of function calls, it is written in assembly to avoid
clobbering any of the application's registers.)  The constructor sets up this system
by replacing each GOT entry corresponding to a cross-library call with a fresh PLOT
entry, storing its previous value in the shadow GOT for the main namespace.  It then
opens a fixed number of additional libsets, redirects the cross-library calls from
each new copy of a library to the same PLOT stubs as before, and creates a shadow GOT
for each libset.

\solb{THESIS: Cover trick for defeating lazy PLT relocations' memoization.}

\solb{THESIS: Draw a diagram explaining our custom tables and the series of lookups
performed by \texttt{procedure\_linkage\_override()}.}

\paragraph{Preserving equality comparisons}

A subtle but important point in the semantics of dynamic linking is that pointers to
the same definition must compare equal, regardless of where they are obtained.  For
instance,
the reader might notice that invocation is not the only thing a program can do with a
function:\@ it might also pass around the function's address.  In fact, after taking
the address, it could pass it to code within a different object file, which might
compare it\footnote{In order for such comparisons to correctly indicate whether the
same code will be run, the compiler loads such addresses directly from the GOT via
instructions of the special position-independent relocation form
\texttt{mov~\textit{symbol}@gotpcrel(\%rip),~\%\textit{dest}}, and the dynamic linker
resolves the calls and populates their GOT entries eagerly at load time.}.  To avoid
breaking pointer comparison, libgotcha makes sure to share the same PLOT
stub between all GOT entries to a given symbol that use this type of
relocation.  As long as the current libset remains the same between the time of a
function pointer comparison and the time of its invocation, such a comparison
guarantees that \texttt{procedure\_linkage\_override()} will dispatch to the same
copy when invoked using either pointer.

\paragraph{Intercepting cross-library references}

Handling references to global data besides functions is more challenging, and less
efficient, because such accesses use the aforementioned position-independent
relocation but do not include a PLT-style codepath for us to co-opt.
In order to capture (hopefully rare) cross-library references to global variables,
we use a different approach.  After each shadow GOT page, we allocate an inaccessible
page with no protection bits set.  Each time the libgotcha constructor encounters a
relocation entry corresponding to a data symbol, we migrate the contents of its GOT
entry into an available shadow GOT entry, replacing it with an address the same
number of bytes into the shadow GOT's corresponding inaccessible page\footnote{For
security reasons, the dynamic linker leaves the portion of each GOT corresponding to
eargerly-resolved symbol uses read-only.  We restore write access to these entries
using \texttt{mprotect()}, then remove it again after updating the entries.}.  Thus,
whenever the program takes the address of a particular symbol, it gets the same fake
address.  Any attempt to read from or write to this address results in a segmentation
fault, which libgotcha catches; we then look up the real address in the shadow GOT
corresponding to the currently-selected libset, disassemble the offending
instruction(s), and replace the contents of the memory-address register with the
found address.  Once the signal handler returns, the instruction executes again, this
time with a valid memory address in its register\footnote{Although it is possible to
generate code sequences that are incompatible with this approach (e.g., because they
perform in-place pointer arithmetic on a register rather than using displacement-mode
addressing with a base address), in our experience public shared data is rare enough
that we have not yet encountered any cases where programs do this.}.

\paragraph{Shortcomings and workarounds}

The libgotcha approach has known conflicts with two modern extensions to the
dynamic-linking model.  Here we discuss these shortcomings and our proposed
workarounds.

When an executable directly accesses a global variable defined in a shared library,
the assembler migrates it into the executable, allowing the main program to access it
via static relocations instead of via the GOT.  The static linker generates a COPY
relocation that causes the dynamic linker to copy the variable's contents from the
shared library at load time.  Unfortunately, this approach makes
it impossible for us to intercept cross-library references occurring within the
executable, and causes associated dynamic references in the defining shared library
to be erroneously treated as cross-library references.  For this reason, libgotcha
emits a warning when it detects a COPY relocation.  Developers can avoid the problem
by building any executables that use libgotcha with the C compiler's \texttt{-fpic}
flag to skip generating such relocations.

Some shared libraries are marked with a special configuration flag,
\texttt{DF\_1\_NODELETE}, which prevents the dynamic linker from ever removing them
once they have been loaded.  Because almost all libraries depend on libc, the
presence of even one such library prevents us from reinitializing a libset for reuse
after its preemptible function has been canceled!  The flag is mostly used on
libraries that need
to monkey-patch some other loaded library, such that the two subsequently have a
circular dependency.  Fortunately, this is not usually a problem because when we
unload one library from a libset, we then unload the rest, so whenever we encounter a
\texttt{NODELETE} object file, we make a special copy with the flag cleared, for
loading into every namespace except the main one.  The one place this does not work
is when a library monkey-patches the dynamic linker itself.  This
requires the use of a private interface, and the only offending library to our
knowledge is GNU libpthread, which replaces function pointers in order to cause the
dynamic linker to take locks when performing potentially concurrent operations; we
handle this by preventing the monkey-patching constructor code from running in our
modified copy of that library.

\paragraph{Execution environment}

While libinger in principle runs on top of an unmodified version of the GNU dynamic
linker, in practice initializing more than one namespace tends to exhaust the
statically-allocated thread-local storage area.  We currently work around this
problem by rebuilding \texttt{ld.so} with the \texttt{TLS\_STATIC\_SURPLUS} macro set
to a larger value.  At the same time, it is possible to raise the default limit
of 16 linker namespaces by increasing the value of \texttt{DL\_NNS}.  With this
change, the only remaining scaling limit is the number of kernel threads running
timed functions, which is limited to the number of signals earmarked for preemption;
however, this number could be increased to over 32 by using realtime
signals~\cite{signal-manpage}, and beyond by rebuilding Linux and glibc with a larger
\texttt{\_NSIG}.

\vspace{\parsep}
In case the reader presently struggles to reason about the implications of libgotcha
in the somewhat complex context of preemptible functions, the following section gives
a simpler example that seeks to illuminate the situation.

\subsection{Case study: Auto async-signal safety}
\label{sec:statefulness}

There are two ways to weaken the semantics of this program to prevent the deadlock
without modifying the program's source code.  (1) We can elide the file descriptor
lock, which in this case may occasionally allow the signal handler's output to
interleave with any (hypothetical) output from the main program (if the signal
handler interrupts a \texttt{write} syscall from the stream library implementation).
(2) We can defer handling of any signal that arrives during a call to
\texttt{fflush()} until that function returns.

In 127 lines of C, we wrote a signal-handling client library, \textit{libas-safe},
that can use libgotcha to automatically transform the program in either of these
ways\footnote{While libas-safe reestablishes async-signal safety, it would also be
possible to write a libgotcha client library that did the same for what POSIX calls
async-cancellation safety.  The obvious application of this would be supporting
asynchronous thread cancellation (in the common case where whitelisted code was not
currently executing):\@ as we saw in Section~\ref{sec:intro}, today's POSIX and
Windows interfaces for this are broken to the point of practical uselessness.}.  It
injects code before \texttt{main()} to switch to a new libset, and provides a custom
implementation of \texttt{sigaction()} that switches the current libset back to the
main one while each signal handler is running.  This is enough to achieve
transformation (1), since it causes \texttt{main()} and \texttt{handler()} to use
distinct copies of the buffered \texttt{stdio} object.  One other \textit{libas-safe}
feature enables transformation (2):\@ whenever the main libset is already selected
when a signal handler runs, that handler is deferred (using libgotcha's callback
mechanism) until the current whitelisted call returns.  This transformation can be
demonstrated for this program by whitelisting the stdio functions and streams.

\solb{THESIS: Walk through example(s) of programs that are automatically repaired by
\textit{libas-safe}.}

\solb{THESIS: Use \textit{libas-safe} to prototype a library that enables safe signal
handling in Rust.}
