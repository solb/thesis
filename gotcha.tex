\section{Shared state: \textit{libgotcha}}
\label{sec:libgotcha}

\solb{Replace the term ``whitelisted'' with ``uninterruptible.''}

Having covered \textit{libinger} and \textit{libturquoise}, two libraries providing
tools intended for use by application programmers, we now turn our attention to the
reclusive \textit{libgotcha}.  Just as the shared state it protects is hidden behind
deceptive nonreentrant interfaces, \textit{libgotcha} lurks behind the scenes of
\textit{libinger}, which controls it using a private API.  Although the rest of the
program does not interact directly with \textit{libgotcha}, its presence has a
profound effect:\@ once loaded into the process image, it employs a technique we call
\textbf{selective relinking} to intercept and reroute many of the program's function
calls and global variable accesses at runtime.

The goal of \textit{libgotcha} is to establish around every preemptible function a
memory isolation boundary encompassing whatever third-party libraries that function
interacts with (Section~\ref{sec:libinger:reentrancy}).  The result is that the only
state shared across the boundary is that explicitly passed between via arguments,
return value, or closure---the same state the application programmer is responsible
for protecting from concurrency violations (Section~\ref{sec:libinger:concurrency}).

Note that \textit{libgotcha} operates at runtime, which constrains its visibility
into the program and therefore the granularity of its operation.  Because all static
relocations (e.g., between the object files and static libraries linked to form the
program executable) have already been resolved at build time via the static linker,
they are invisible to \textit{libgotcha}.  This means it cannot protect an
application's use of nonreentrant static libraries:\@ from \textit{libgotcha}'s
perspective, interactions with such a library are indistinguishable from those with
any other part of the executable.  However, whenever a dynamic relocation is involved
(e.g., a function call or global variable access between runtime-loaded objects such
as the executable and shared libraries), \textit{libgotcha} can tell the nature of
the symbol access and may choose to redirect it.

Before explaining selective relinking and introducing the \textit{libgotcha} API, we
will now briefly motivate the need for libgotcha by demonstrating how existing system
interfaces fail to provide the isolation we require.


\subsection{Library copying}

Expanding a preemptible function's isolation boundary to include libraries requires
providing it with private copies of said libraries.  POSIX has long provided a
\texttt{dlopen()} interface to the dynamic linker for loading shared objects at
runtime; however, opening an already-loaded library does nothing more than increment
a reference count, and this function is therefore of no use for making copies.
Fortunately, the GNU dynamic linker (\texttt{ld-linux.so}) also supports
Solaris-style \textbf{namespaces}, or isolated sets of loaded libraries.  For each
namespace, \texttt{ld-linux.so} maintains a separate set of loaded libraries whose
dependency graph and reference counts are tracked independently from the rest of the
program~\cite{dlmopen-manpage}.

It may seem like namespaces provide the isolation we need:\@ whenever we
\texttt{launch(\textnormal{\textit{F}})}, we can initialize a namespace with a copy
of the whole application and transfer control into that namespace's copy of
\textit{F}, rather than the original.  The problem with this approach is that it
breaks lexical scoping.  For instance, the user would expect static variables in the
object file where \textit{F} is defined to be visible from both inside and outside of
the preemptible function, since they represent explicitly-shared state.


\subsection{Principle}

This brings us to unaware code, and the purpose of libgotcha.  This library employs
a technique we call \textbf{selective relinking} to redirect at runtime each use of a
function or global variable from outside the current object file\footnote{Whenevee we
refer to an object file, we mean specifically a relocated object file (i.e.,
executable or dynamic shared library); that is, one that is loaded into the process's
memory image.} to one of numerous possible copies.  Depending on the symbol accessed,
libinger uses libgotcha to accomplish one of two things:  In the common case, it
gives each preemptible function its own copy of the symbol, complete with its own
shared state.  Although this approach works for many libraries, it is sometimes
inappropriate; for instance, using multiple copies of the dynamic allocator would
cause them to manage the same heap with different free lists.  In such cases, it
instead defers preemption until the function call into the library returns.

The libgotcha API, show in Listing~\ref{lst:gotchaapi}, is based on something we term
a \textbf{libset}, which is a full copy of the program's set of loaded
libraries\footnote{Technically, a libset also includes the executable, which is
needed in case one of the application's libraries uses preemptible functions that use
symbols from the executable file.}.  Every program has a \textbf{main libset} (the
program itself, as originally loaded), and libgotcha may open any number of
additional libsets.  Users of libgotcha may explicitly reinitialize a libset, closing
all its object files then reopening them to prepare for fresh use.  While execution
is within one libset, it remains there until directed to change via one of two
explicit mechanisms.

\begin{figure}
\begin{lstlisting}[label=lst:gotchaapi,caption=libgotcha C interface]
typedef long libset_t;

libset_t libset_new(void);
bool libset_reinit(libset_t);

// Returns previously-selected libset
bool libset_thread_set_current(libset_t);
libset_t libset_thread_get_current(void);

void libset_register_whitelist_callback(
  void (*)(void)):
\end{lstlisting}
\end{figure}

Each thread has an attribute called the \textbf{current libset} that controls which
libset symbol uses are redirected to.  This does not determine the libset from which
the current code is being executed, but rather the libset that will be used to
provide any function or global variable defined external to the current object file.
One way to move between libsets is to change the current libset, then use such a
symbol.

The other mechanism for changing libsets is a \textbf{whitelist} of symbols (such as
the dynamic allocator) that should share a single definition throughout the entire
application.  Whenever a global variable from this list is accessed, libgotcha serves
the definition from the main libset.  Whenever a function from the list is called,
libgotcha automatically changes the thread's current libset to the main one before
performing the call, then restores its original value as soon as the function
returns.  Users of libgotcha can optionally install a callback function to be
notified whenever the whitelist causes the current libset to change.

One activates the functionality of libgotcha simply by linking against it:\@ once
loaded into the process image, it immediately instruments the boundaries between
object files.  The libinger shared library is statically linked against
libgotcha\footnote{The attentive reader will notice that both libgotcha and libinger
contain shared state (the current libset and thread preemption signal, respectively).
To handle this, libgotcha automatically adds all the symbols defined by its own
object file to the whitelist.  By statically linking to it, libinger gains this same
protection.} so that the latter is active in any program using preemptible functions.
Execution will not, of course, leave the main libset until such an action is
requested via libgotcha's API.

Use of this API by libinger is straightforward.  The \texttt{launch()} function
allocates a new libset by either using an unused one, reusing one from a preemptible
function that ran to completion, or reinitializing one from a preemptible function
that was canceled prematurely.  It installs
this as the current libset just before enabling preemption.  Right after checking
whether the received signal was intended for the current thread, the preemption
signal handler checks the thread's current libset; in the case of the main one
(indicating the preemptible function is currently in whitelisted code), it blocks the
preemption signal and immediately returns, effectively deferring
preemption\footnote{When whitelisting the dynamic allocator, it is important not to
whitelist all of libc as collateral damage, since preemptible functions could easily
exploit this to run forever (e.g., by performing their work in the \texttt{qsort()}
function's comparator callback).  Fortunately, libc uses dynamic calls when it needs
to invoke the allocator internally, allowing us to whitelist that component alone.}.
The deferral is not indefinite:\@ libinger uses libgotcha's callback mechanism to
both call the handler and unblock the signal as soon as the function returns.

\solb{THESIS: Draw a figure depicting what happens w.r.t. the current libset,
preemptibility, and the notification callbacks when a preemptible function calls
an uninterruptible function (say, malloc()).}

\subsection{Mechanics}

The rest of this section covers the implementation of libgotcha, which isolates
shared state at the granularity of object files by intercepting many dynamic function
calls and global variable accesses.  To accomplish this, it must collect all uses of
dynamic symbols, discriminate between intra- and \textbf{cross-library} uses of those
symbols, and interpose cross-library uses by shadowing the existing structures that
support dynamic symbol resolution.  The libgotcha library includes a constructor that
gets invoked by the dynamic linker after all shared libraries have been loaded but
before the call to \texttt{main()}:\@ the aforementioned steps are performed here so
interposing is already active by the time control is transferred to the application.

\paragraph{Just enough dynamic linking}

\solb{Define GOT\footnote{It is this structure that gives \textit{lib\textbf{got}cha}
its name.}}

\paragraph{Identifying cross-library symbol uses}

It is important to realize that dynamic calls and references are resolved based on
the name of a symbol, which may be ambiguous between multiple libraries within the
same namespace; as such, the library associated with each dynamic relocation is not
determined until runtime.  In fact, a dynamic relocation might even resolve back to
the same object file that contains it; this is most common when a shared library
makes an internal reference to one of its own public interfaces (since the
application might replace that public interface with its own implementation or one
from a different library).  Note that other internal references within such a shared
library are linked statically, leaving no way to locate them at runtime.  In order to
provide consistent semantics, we only instrument cross-library variable
references and function calls, where the use and definition occur in different object
files.

\solb{THESIS: Cover the algorithm for identifying GOT entries that correspond to
cross-library symbols.}

\paragraph{Intercepting cross-library calls}

Dynamic linking gives us a powerful tool for intercepting cross-library function
calls:\@ each PLT entry already executes by branching to an address stored in the
GOT, so the libgotcha constructor has only to change the latter to one of its own
functions, and any calls through that PLT entry will be sent to libgotcha instead.

The constructor allocates one or more executable pages full of custom PLT-like
stubs, which we refer to as the \textbf{procedure linkage override tables (PLOTs)}.
Each PLOT is associated with one \textbf{shadow GOT} for each namespace:\@ when a
particular PLOT stub is executed, it pushes an index to the stack and calls a
function, \texttt{procedure\_linkage\_override()}, that decides which libset the call
should target, locates the corresponding shadow GOT, and transfers control to the
address listed at the appropriate index in that table.  (Because this function
is injected into the "middle" of function calls, it is written in assembly to avoid
clobbering any of the application's registers.)  The constructor sets up this system
by replacing each GOT entry corresponding to a cross-library call with a fresh PLOT
entry, storing its previous value in the shadow GOT for the main namespace.  It then
opens a fixed number of additional libsets, redirects the cross-library calls from
each new copy of a library to the same PLOT stubs as before, and creates a shadow GOT
for each libset.

\solb{THESIS: Cover trick for defeating lazy PLT relocations' memoization.}

\solb{THESIS: Draw a diagram explaining our custom tables and the series of lookups
performed by \texttt{procedure\_linkage\_override()}.}

\paragraph{Preserving equality comparisons}

A subtle but important point in the semantics of dynamic linking is that pointers to
the same definition must compare equal, regardless of where they are obtained.  For
instance,
the reader might notice that invocation is not the only thing a program can do with a
function:\@ it might also pass around the function's address.  In fact, after taking
the address, it could pass it to code within a different object file, which might
compare it\footnote{In order for such comparisons to correctly indicate whether the
same code will be run, the compiler loads such addresses directly from the GOT via
instructions of the special position-independent relocation form
\texttt{mov~\textit{symbol}@gotpcrel(\%rip),~\%\textit{dest}}, and the dynamic linker
resolves the calls and populates their GOT entries eagerly at load time.}.  To avoid
breaking pointer comparison, libgotcha makes sure to share the same PLOT
stub between all GOT entries to a given symbol that use this type of
relocation.  As long as the current libset remains the same between the time of a
function pointer comparison and the time of its invocation, such a comparison
guarantees that \texttt{procedure\_linkage\_override()} will dispatch to the same
copy when invoked using either pointer.

\paragraph{Intercepting cross-library references}

Handling references to global data besides functions is more challenging, and less
efficient, because such accesses use the aforementioned position-independent
relocation but do not include a PLT-style codepath for us to co-opt.
In order to capture (hopefully rare) cross-library references to global variables,
we use a different approach.  After each shadow GOT page, we allocate an inaccessible
page with no protection bits set.  Each time the libgotcha constructor encounters a
relocation entry corresponding to a data symbol, we migrate the contents of its GOT
entry into an available shadow GOT entry, replacing it with an address the same
number of bytes into the shadow GOT's corresponding inaccessible page\footnote{For
security reasons, the dynamic linker leaves the portion of each GOT corresponding to
eargerly-resolved symbol uses read-only.  We restore write access to these entries
using \texttt{mprotect()}, then remove it again after updating the entries.}.  Thus,
whenever the program takes the address of a particular symbol, it gets the same fake
address.  Any attempt to read from or write to this address results in a segmentation
fault, which libgotcha catches; we then look up the real address in the shadow GOT
corresponding to the currently-selected libset, disassemble the offending
instruction(s), and replace the contents of the memory-address register with the
found address.  Once the signal handler returns, the instruction executes again, this
time with a valid memory address in its register\footnote{Although it is possible to
generate code sequences that are incompatible with this approach (e.g., because they
perform in-place pointer arithmetic on a register rather than using displacement-mode
addressing with a base address), in our experience public shared data is rare enough
that we have not yet encountered any cases where programs do this.}.

\solb{THESIS: Explain the trouble with COPY relocations and the need to use
\texttt{-fpic} as a workaround, ideally showing the performance ramifications
(e.g., via the nginx experiment).}

\solb{THESIS: Cover the \texttt{NODELETE} flag, ld.so monkey patching, and the
library header rewriting trick I use to circumvent the issue.}

\solb{THESIS: Describe (and hopefully even address) the monomorphization problem.}

\paragraph{Execution environment}

While libinger in principle runs on top of an unmodified version of the GNU dynamic
linker, in practice initializing more than one namespace tends to exhaust the
statically-allocated thread-local storage area.  We currently work around this
problem by rebuilding \texttt{ld.so} with the \texttt{TLS\_STATIC\_SURPLUS} macro set
to a larger value.  At the same time, it is possible to raise the default limit
of 16 linker namespaces by increasing the value of \texttt{DL\_NNS}.  With this
change, the only remaining scaling limit is the number of kernel threads running
timed functions, which is limited to the number of signals earmarked for preemption;
however, this number could be increased to over 32 by using realtime
signals~\cite{signal-manpage}, and beyond by rebuilding Linux and glibc with a larger
\texttt{\_NSIG}.

\vspace{\parsep}
In case the reader presently struggles to reason about the implications of libgotcha
in the somewhat complex context of preemptible functions, the following section gives
a simpler example that seeks to illuminate the situation.

\subsection{Case study: Auto async-signal safety}
\label{sec:statefulness}

There are two ways to weaken the semantics of this program to prevent the deadlock
without modifying the program's source code.  (1) We can elide the file descriptor
lock, which in this case may occasionally allow the signal handler's output to
interleave with any (hypothetical) output from the main program (if the signal
handler interrupts a \texttt{write} syscall from the stream library implementation).
(2) We can defer handling of any signal that arrives during a call to
\texttt{fflush()} until that function returns.

In 127 lines of C, we wrote a signal-handling client library, \textit{libas-safe},
that can use libgotcha to automatically transform the program in either of these
ways.  It
injects code before \texttt{main()} to switch to a new libset, and provides a custom
implementation of \texttt{sigaction()} that switches the current libset back to the
main one while each signal handler is running.  This is enough to achieve
transformation (1), since it causes \texttt{main()} and \texttt{handler()} to use
distinct copies of the buffered \texttt{stdio} object.  One other \textit{libas-safe}
feature enables transformation (2):\@ whenever the main libset is already selected
when a signal handler runs, that handler is deferred (using libgotcha's callback
mechanism) until the current whitelisted call returns.  This transformation can be
demonstrated for this program by whitelisting the stdio functions and streams.

\solb{THESIS: Walk through example(s) of programs that are automatically repaired by
\textit{libas-safe}.}

\solb{THESIS: Explore \textit{libac-safe} idea?}

\solb{THESIS: Use \textit{libas-safe} to prototype a library that enables safe signal
handling in Rust.}

\solb{THESIS: It's been suggested that \texttt{libgotcha} could let you switch
between multiple versions of the same library (e.g., different revisions, feature
sets, or even release vs. debug).  This probably merits additional thought.}

\solb{THESIS: Another possible use for (an enhanced) \textit{libgotcha} is some kind
of scary runtime aspect-oriented programming thing (i.e., a generalization of
ltrace).}
