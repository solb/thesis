Global variables' addresses are replaced with a unique address within a mapped but
inaccessible page.  When the program tries to read or write such an address, a
segmentation fault occurs; \textit{libgotcha} handles the fault, disassembles the
faulting instruction to determine the base address register of its address
calculation,\footnote{Although it is possible to
generate code sequences that are incompatible with this approach (e.g., because they
perform in-place pointer arithmetic on a register rather than using displacement-mode
addressing with a base address), we employ a few heuristics based on the context of
the instruction and fault; in our experience, these cover the common cases.}
loads the address from this register, computes the location of the
shadow GOT entry based on the fake address, checks the thread's next libset, and
replaces the register's contents with the appropriate resolved address.  It then
returns, causing the faulting instruction to be reexecuted with the valid address
this time.\footnote{This does not break applications with existing segfault
handlers:\@ we intercept their calls to \texttt{sigaction()}, and forward the signal
along to their handler when we are unable to resolve an address ourselves.}

\thesis{Give more details on global variable interpositions, especially
heuristics.}
